[
 {
  "docstring": "Sequentially read the file containing the edge list data for the\ngraphs in the atlas and generate the graphs one at a time.\n\nThis function reads the file given in :data:`.ATLAS_FILE`.",
  "code": "def _generate_graphs():\n    with gzip.open(ATLAS_FILE, 'rb') as f:\n        line = f.readline()\n        while line and line.startswith(b'GRAPH'):\n            graph_index = int(line[6:].rstrip())\n            line = f.readline()\n            num_nodes = int(line[6:].rstrip())\n            edgelist = []\n            line = f.readline()\n            while line and (not line.startswith(b'GRAPH')):\n                edgelist.append(line.rstrip())\n                line = f.readline()\n            G = nx.Graph()\n            G.name = f'G{graph_index}'\n            G.add_nodes_from(range(num_nodes))\n            G.add_edges_from((tuple(map(int, e.split())) for e in edgelist))\n            yield G"
 },
 {
  "docstring": "Returns graph number `i` from the Graph Atlas.\n\nFor more information, see :func:`.graph_atlas_g`.\n\nParameters\n----------\ni : int\n    The index of the graph from the atlas to get. The graph at index\n    0 is assumed to be the null graph.\n\nReturns\n-------\nlist\n    A list of :class:`~networkx.Graph` objects, the one at index *i*\n    corresponding to the graph *i* in the Graph Atlas.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef graph_atlas(i):\n    if not 0 <= i < NUM_GRAPHS:\n        raise ValueError(f'index must be between 0 and {NUM_GRAPHS}')\n    return next(islice(_generate_graphs(), i, None))"
 },
 {
  "docstring": "Returns the list of all graphs with up to seven nodes named in the\nGraph Atlas.\n\nThe graphs are listed in increasing order by\n\n1. number of nodes,\n2. number of edges,\n3. degree sequence (for example 111223 < 112222),\n4. number of automorphisms,\n\nin that order, with three exceptions as described in the *Notes*\nsection below. This causes the list to correspond with the index of\nthe graphs in the Graph Atlas [atlas]_, with the first graph,\n``G[0]``, being the null graph.\n\nReturns\n-------\nlist\n    A list of :class:`~networkx.Graph` objects, the one at index *i*\n    corresponding to the graph *i* in the Graph Atlas.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef graph_atlas_g():\n    return list(_generate_graphs())"
 },
 {
  "docstring": "Creates a full r-ary tree of `n` nodes.\n\nSometimes called a k-ary, n-ary, or m-ary tree.\n\"... all non-leaf nodes have exactly r children and all levels\nare full except for some rightmost position of the bottom level\n(if a leaf at the bottom level is missing, then so are all of the\nleaves to its right.\" [1]_\n\nParameters\n----------\nr : int\n    branching factor of the tree\nn : int\n    Number of nodes in the tree\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    An r-ary tree with n nodes\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef full_rary_tree(r, n, create_using=None):\n    G = empty_graph(n, create_using)\n    G.add_edges_from(_tree_edges(n, r))\n    return G"
 },
 {
  "docstring": "Returns the perfectly balanced `r`-ary tree of height `h`.\n\nParameters\n----------\nr : int\n    Branching factor of the tree; each node will have `r`\n    children.\n\nh : int\n    Height of the tree.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : NetworkX graph\n    A balanced `r`-ary tree of height `h`.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef balanced_tree(r, h, create_using=None):\n    if r == 1:\n        n = h + 1\n    else:\n        n = (1 - r ** (h + 1)) // (1 - r)\n    return full_rary_tree(r, n, create_using=create_using)"
 },
 {
  "docstring": "Returns the Barbell Graph: two complete graphs connected by a path.\n\nParameters\n----------\nm1 : int\n    Size of the left and right barbells, must be greater than 2.\n\nm2 : int\n    Length of the path connecting the barbells.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n   Only undirected Graphs are supported.\n\nReturns\n-------\nG : NetworkX graph\n    A barbell graph.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef barbell_graph(m1, m2, create_using=None):\n    if m1 < 2:\n        raise NetworkXError('Invalid graph description, m1 should be >=2')\n    if m2 < 0:\n        raise NetworkXError('Invalid graph description, m2 should be >=0')\n    G = complete_graph(m1, create_using)\n    if G.is_directed():\n        raise NetworkXError('Directed Graph not supported')\n    G.add_nodes_from(range(m1, m1 + m2 - 1))\n    if m2 > 1:\n        G.add_edges_from(pairwise(range(m1, m1 + m2)))\n    G.add_edges_from(((u, v) for u in range(m1 + m2, 2 * m1 + m2) for v in range(u + 1, 2 * m1 + m2)))\n    G.add_edge(m1 - 1, m1)\n    if m2 > 0:\n        G.add_edge(m1 + m2 - 1, m1 + m2)\n    return G"
 },
 {
  "docstring": "Returns the Binomial Tree of order n.\n\nThe binomial tree of order 0 consists of a single node. A binomial tree of order k\nis defined recursively by linking two binomial trees of order k-1: the root of one is\nthe leftmost child of the root of the other.\n\nParameters\n----------\nn : int\n    Order of the binomial tree.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : NetworkX graph\n    A binomial tree of $2^n$ nodes and $2^n - 1$ edges.",
  "code": "@nx._dispatch(graphs=None)\ndef binomial_tree(n, create_using=None):\n    G = nx.empty_graph(1, create_using)\n    N = 1\n    for i in range(n):\n        edges = [(u + N, v + N) for u, v in G.edges()]\n        G.add_edges_from(edges)\n        G.add_edge(0, N)\n        N *= 2\n    return G"
 },
 {
  "docstring": "Return the complete graph `K_n` with n nodes.\n\nA complete graph on `n` nodes means that all pairs\nof distinct nodes have an edge connecting them.\n\n.. plot::\n\n    >>> nx.draw(nx.complete_graph(5))\n\nParameters\n----------\nn : int or iterable container of nodes\n    If n is an integer, nodes are from range(n).\n    If n is a container of nodes, those nodes appear in the graph.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nExamples\n--------\n>>> G = nx.complete_graph(9)\n>>> len(G)\n9\n>>> G.size()\n36\n>>> G = nx.complete_graph(range(11, 14))\n>>> list(G.nodes())\n[11, 12, 13]\n>>> G = nx.complete_graph(4, nx.DiGraph())\n>>> G.is_directed()\nTrue",
  "code": "@nx._dispatch(graphs=None)\n@nodes_or_number(0)\ndef complete_graph(n, create_using=None):\n    _, nodes = n\n    G = empty_graph(nodes, create_using)\n    if len(nodes) > 1:\n        if G.is_directed():\n            edges = itertools.permutations(nodes, 2)\n        else:\n            edges = itertools.combinations(nodes, 2)\n        G.add_edges_from(edges)\n    return G"
 },
 {
  "docstring": "Returns the circular ladder graph $CL_n$ of length n.\n\n$CL_n$ consists of two concentric n-cycles in which\neach of the n pairs of concentric nodes are joined by an edge.\n\nNode labels are the integers 0 to n-1",
  "code": "@nx._dispatch(graphs=None)\ndef circular_ladder_graph(n, create_using=None):\n    G = ladder_graph(n, create_using)\n    G.add_edge(0, n - 1)\n    G.add_edge(n, 2 * n - 1)\n    return G"
 },
 {
  "docstring": "Returns the circulant graph $Ci_n(x_1, x_2, ..., x_m)$ with $n$ nodes.\n\nThe circulant graph $Ci_n(x_1, ..., x_m)$ consists of $n$ nodes $0, ..., n-1$\nsuch that node $i$ is connected to nodes $(i + x) \\mod n$ and $(i - x) \\mod n$\nfor all $x$ in $x_1, ..., x_m$. Thus $Ci_n(1)$ is a cycle graph.\n\nParameters\n----------\nn : integer\n    The number of nodes in the graph.\noffsets : list of integers\n    A list of node offsets, $x_1$ up to $x_m$, as described above.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX Graph of type create_using\n\nExamples\n--------\nMany well-known graph families are subfamilies of the circulant graphs;\nfor example, to create the cycle graph on n points, we connect every\nnode to nodes on either side (with offset plus or minus one). For n = 10,\n\n>>> G = nx.circulant_graph(10, [1])\n>>> edges = [\n...     (0, 9),\n...     (0, 1),\n...     (1, 2),\n...     (2, 3),\n...     (3, 4),\n...     (4, 5),\n...     (5, 6),\n...     (6, 7),\n...     (7, 8),\n...     (8, 9),\n... ]\n...\n>>> sorted(edges) == sorted(G.edges())\nTrue\n\nSimilarly, we can create the complete graph\non 5 points with the set of offsets [1, 2]:\n\n>>> G = nx.circulant_graph(5, [1, 2])\n>>> edges = [\n...     (0, 1),\n...     (0, 2),\n...     (0, 3),\n...     (0, 4),\n...     (1, 2),\n...     (1, 3),\n...     (1, 4),\n...     (2, 3),\n...     (2, 4),\n...     (3, 4),\n... ]\n...\n>>> sorted(edges) == sorted(G.edges())\nTrue",
  "code": "@nx._dispatch(graphs=None)\ndef circulant_graph(n, offsets, create_using=None):\n    G = empty_graph(n, create_using)\n    for i in range(n):\n        for j in offsets:\n            G.add_edge(i, (i - j) % n)\n            G.add_edge(i, (i + j) % n)\n    return G"
 },
 {
  "docstring": "Returns the cycle graph $C_n$ of cyclically connected nodes.\n\n$C_n$ is a path with its two end-nodes connected.\n\nParameters\n----------\nn : int or iterable container of nodes\n    If n is an integer, nodes are from `range(n)`.\n    If n is a container of nodes, those nodes appear in the graph.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\n",
  "code": "@nx._dispatch(graphs=None)\n@nodes_or_number(0)\ndef cycle_graph(n, create_using=None):\n    _, nodes = n\n    G = empty_graph(nodes, create_using)\n    G.add_edges_from(pairwise(nodes, cyclic=True))\n    return G"
 },
 {
  "docstring": "Returns the hierarchically constructed Dorogovtsev-Goltsev-Mendes graph.\n\nThe Dorogovtsev-Goltsev-Mendes [1]_ procedure produces a scale-free graph\ndeterministically with the following properties for a given `n`:\n- Total number of nodes = ``3 * (3**n + 1) / 2``\n- Total number of edges = ``3 ** (n + 1)``\n\nParameters\n----------\nn : integer\n   The generation number.\n\ncreate_using : NetworkX Graph, optional\n   Graph type to be returned. Directed graphs and multi graphs are not\n   supported.\n\nReturns\n-------\nG : NetworkX Graph\n\nExamples\n--------\n>>> G = nx.dorogovtsev_goltsev_mendes_graph(3)\n>>> G.number_of_nodes()\n15\n>>> G.number_of_edges()\n27\n>>> nx.is_planar(G)\nTrue\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef dorogovtsev_goltsev_mendes_graph(n, create_using=None):\n    G = empty_graph(0, create_using)\n    if G.is_directed():\n        raise NetworkXError('Directed Graph not supported')\n    if G.is_multigraph():\n        raise NetworkXError('Multigraph not supported')\n    G.add_edge(0, 1)\n    if n == 0:\n        return G\n    new_node = 2\n    for i in range(1, n + 1):\n        last_generation_edges = list(G.edges())\n        number_of_edges_in_last_generation = len(last_generation_edges)\n        for j in range(number_of_edges_in_last_generation):\n            G.add_edge(new_node, last_generation_edges[j][0])\n            G.add_edge(new_node, last_generation_edges[j][1])\n            new_node += 1\n    return G"
 },
 {
  "docstring": "Returns the empty graph with n nodes and zero edges.\n\nParameters\n----------\nn : int or iterable container of nodes (default = 0)\n    If n is an integer, nodes are from `range(n)`.\n    If n is a container of nodes, those nodes appear in the graph.\ncreate_using : Graph Instance, Constructor or None\n    Indicator of type of graph to return.\n    If a Graph-type instance, then clear and use it.\n    If None, use the `default` constructor.\n    If a constructor, call it to create an empty graph.\ndefault : Graph constructor (optional, default = nx.Graph)\n    The constructor to use if create_using is None.\n    If None, then nx.Graph is used.\n    This is used when passing an unknown `create_using` value\n    through your home-grown function to `empty_graph` and\n    you want a default constructor other than nx.Graph.\n\nExamples\n--------\n>>> G = nx.empty_graph(10)\n>>> G.number_of_nodes()\n10\n>>> G.number_of_edges()\n0\n>>> G = nx.empty_graph(\"ABC\")\n>>> G.number_of_nodes()\n3\n>>> sorted(G)\n['A', 'B', 'C']\n\n",
  "code": "@nx._dispatch(graphs=None)\n@nodes_or_number(0)\ndef empty_graph(n=0, create_using=None, default=Graph):\n    if create_using is None:\n        G = default()\n    elif isinstance(create_using, type):\n        G = create_using()\n    elif not hasattr(create_using, 'adj'):\n        raise TypeError('create_using is not a valid NetworkX graph type or instance')\n    else:\n        create_using.clear()\n        G = create_using\n    _, nodes = n\n    G.add_nodes_from(nodes)\n    return G"
 },
 {
  "docstring": "Returns the Ladder graph of length n.\n\nThis is two paths of n nodes, with\neach pair connected by a single edge.\n\nNode labels are the integers 0 to 2*n - 1.",
  "code": "@nx._dispatch(graphs=None)\ndef ladder_graph(n, create_using=None):\n    G = empty_graph(2 * n, create_using)\n    if G.is_directed():\n        raise NetworkXError('Directed Graph not supported')\n    G.add_edges_from(pairwise(range(n)))\n    G.add_edges_from(pairwise(range(n, 2 * n)))\n    G.add_edges_from(((v, v + n) for v in range(n)))\n    return G"
 },
 {
  "docstring": "Returns the Lollipop Graph; ``K_m`` connected to ``P_n``.\n\nThis is the Barbell Graph without the right barbell.\n\nParameters\n----------\nm, n : int or iterable container of nodes\n    If an integer, nodes are from ``range(m)`` and ``range(m, m+n)``.\n    If a container of nodes, those nodes appear in the graph.\n    Warning: `m` and `n` are not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\n\n    The nodes for `m` appear in the complete graph $K_m$ and the nodes\n    for `n` appear in the path $P_n$\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkx graph\n   A complete graph with `m` nodes connected to a path of length `n`.\n\n",
  "code": "@nx._dispatch(graphs=None)\n@nodes_or_number([0, 1])\ndef lollipop_graph(m, n, create_using=None):\n    m, m_nodes = m\n    M = len(m_nodes)\n    if M < 2:\n        raise NetworkXError('Invalid description: m should indicate at least 2 nodes')\n    n, n_nodes = n\n    if isinstance(m, numbers.Integral) and isinstance(n, numbers.Integral):\n        n_nodes = list(range(M, M + n))\n    N = len(n_nodes)\n    G = complete_graph(m_nodes, create_using)\n    if G.is_directed():\n        raise NetworkXError('Directed Graph not supported')\n    G.add_nodes_from(n_nodes)\n    if N > 1:\n        G.add_edges_from(pairwise(n_nodes))\n    if len(G) != M + N:\n        raise NetworkXError('Nodes must be distinct in containers m and n')\n    if M > 0 and N > 0:\n        G.add_edge(m_nodes[-1], n_nodes[0])\n    return G"
 },
 {
  "docstring": "Returns the Null graph with no nodes or edges.\n\nSee empty_graph for the use of create_using.",
  "code": "@nx._dispatch(graphs=None)\ndef null_graph(create_using=None):\n    G = empty_graph(0, create_using)\n    return G"
 },
 {
  "docstring": "Returns the Path graph `P_n` of linearly connected nodes.\n\nParameters\n----------\nn : int or iterable\n    If an integer, nodes are 0 to n - 1.\n    If an iterable of nodes, in the order they appear in the path.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.",
  "code": "@nx._dispatch(graphs=None)\n@nodes_or_number(0)\ndef path_graph(n, create_using=None):\n    _, nodes = n\n    G = empty_graph(nodes, create_using)\n    G.add_edges_from(pairwise(nodes))\n    return G"
 },
 {
  "docstring": "Return the star graph\n\nThe star graph consists of one center node connected to n outer nodes.\n\nParameters\n----------\nn : int or iterable\n    If an integer, node labels are 0 to n with center 0.\n    If an iterable of nodes, the center is the first.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\n",
  "code": "@nx._dispatch(graphs=None)\n@nodes_or_number(0)\ndef star_graph(n, create_using=None):\n    n, nodes = n\n    if isinstance(n, numbers.Integral):\n        nodes.append(n)\n    G = empty_graph(nodes, create_using)\n    if G.is_directed():\n        raise NetworkXError('Directed Graph not supported')\n    if len(nodes) > 1:\n        hub, *spokes = nodes\n        G.add_edges_from(((hub, node) for node in spokes))\n    return G"
 },
 {
  "docstring": "Returns the (m,n)-tadpole graph; ``C_m`` connected to ``P_n``.\n\nThis graph on m+n nodes connects a cycle of size `m` to a path of length `n`.\nIt looks like a tadpole. It is also called a kite graph or a dragon graph.\n\nParameters\n----------\nm, n : int or iterable container of nodes\n    If an integer, nodes are from ``range(m)`` and ``range(m,m+n)``.\n    If a container of nodes, those nodes appear in the graph.\n    Warning: `m` and `n` are not checked for duplicates and if present the\n    resulting graph may not be as desired.\n\n    The nodes for `m` appear in the cycle graph $C_m$ and the nodes\n    for `n` appear in the path $P_n$.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkx graph\n   A cycle of size `m` connected to a path of length `n`.\n\nRaises\n------\nNetworkXError\n    If ``m < 2``. The tadpole graph is undefined for ``m<2``.\n\n",
  "code": "@nx._dispatch(graphs=None)\n@nodes_or_number([0, 1])\ndef tadpole_graph(m, n, create_using=None):\n    m, m_nodes = m\n    M = len(m_nodes)\n    if M < 2:\n        raise NetworkXError('Invalid description: m should indicate at least 2 nodes')\n    n, n_nodes = n\n    if isinstance(m, numbers.Integral) and isinstance(n, numbers.Integral):\n        n_nodes = list(range(M, M + n))\n    G = cycle_graph(m_nodes, create_using)\n    if G.is_directed():\n        raise NetworkXError('Directed Graph not supported')\n    nx.add_path(G, [m_nodes[-1]] + list(n_nodes))\n    return G"
 },
 {
  "docstring": "Return the Trivial graph with one node (with label 0) and no edges.",
  "code": "@nx._dispatch(graphs=None)\ndef trivial_graph(create_using=None):\n    G = empty_graph(1, create_using)\n    return G"
 },
 {
  "docstring": "Return the Turan Graph\n\nThe Turan Graph is a complete multipartite graph on $n$ nodes\nwith $r$ disjoint subsets. That is, edges connect each node to\nevery node not in its subset.\n\nGiven $n$ and $r$, we create a complete multipartite graph with\n$r-(n \\mod r)$ partitions of size $n/r$, rounded down, and\n$n \\mod r$ partitions of size $n/r+1$, rounded down.\n\nParameters\n----------\nn : int\n    The number of nodes.\nr : int\n    The number of partitions.\n    Must be less than or equal to n.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef turan_graph(n, r):\n    if not 1 <= r <= n:\n        raise NetworkXError('Must satisfy 1 <= r <= n')\n    partitions = [n // r] * (r - n % r) + [n // r + 1] * (n % r)\n    G = complete_multipartite_graph(*partitions)\n    return G"
 },
 {
  "docstring": "Return the wheel graph\n\nThe wheel graph consists of a hub node connected to a cycle of (n-1) nodes.\n\nParameters\n----------\nn : int or iterable\n    If an integer, node labels are 0 to n with center 0.\n    If an iterable of nodes, the center is the first.\n    Warning: n is not checked for duplicates and if present the\n    resulting graph may not be as desired. Make sure you have no duplicates.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nNode labels are the integers 0 to n - 1.",
  "code": "@nx._dispatch(graphs=None)\n@nodes_or_number(0)\ndef wheel_graph(n, create_using=None):\n    _, nodes = n\n    G = empty_graph(nodes, create_using)\n    if G.is_directed():\n        raise NetworkXError('Directed Graph not supported')\n    if len(nodes) > 1:\n        hub, *rim = nodes\n        G.add_edges_from(((hub, node) for node in rim))\n        if len(rim) > 1:\n            G.add_edges_from(pairwise(rim, cyclic=True))\n    return G"
 },
 {
  "docstring": "Returns the complete multipartite graph with the specified subset sizes.\n\nParameters\n----------\nsubset_sizes : tuple of integers or tuple of node iterables\n   The arguments can either all be integer number of nodes or they\n   can all be iterables of nodes. If integers, they represent the\n   number of nodes in each subset of the multipartite graph.\n   If iterables, each is used to create the nodes for that subset.\n   The length of subset_sizes is the number of subsets.\n\nReturns\n-------\nG : NetworkX Graph\n   Returns the complete multipartite graph with the specified subsets.\n\n   For each node, the node attribute 'subset' is an integer\n   indicating which subset contains the node.\n\nExamples\n--------\nCreating a complete tripartite graph, with subsets of one, two, and three\nnodes, respectively.\n\n    >>> G = nx.complete_multipartite_graph(1, 2, 3)\n    >>> [G.nodes[u][\"subset\"] for u in G]\n    [0, 1, 1, 2, 2, 2]\n    >>> list(G.edges(0))\n    [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]\n    >>> list(G.edges(2))\n    [(2, 0), (2, 3), (2, 4), (2, 5)]\n    >>> list(G.edges(4))\n    [(4, 0), (4, 1), (4, 2)]\n\n    >>> G = nx.complete_multipartite_graph(\"a\", \"bc\", \"def\")\n    >>> [G.nodes[u][\"subset\"] for u in sorted(G)]\n    [0, 1, 1, 2, 2, 2]\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef complete_multipartite_graph(*subset_sizes):\n    G = Graph()\n    if len(subset_sizes) == 0:\n        return G\n    try:\n        extents = pairwise(itertools.accumulate((0,) + subset_sizes))\n        subsets = [range(start, end) for start, end in extents]\n    except TypeError:\n        subsets = subset_sizes\n    else:\n        if any((size < 0 for size in subset_sizes)):\n            raise NetworkXError(f'Negative number of nodes not valid: {subset_sizes}')\n    try:\n        for i, subset in enumerate(subsets):\n            G.add_nodes_from(subset, subset=i)\n    except TypeError as err:\n        raise NetworkXError('Arguments must be all ints or all iterables') from err\n    for subset1, subset2 in itertools.combinations(subsets, 2):\n        G.add_edges_from(itertools.product(subset1, subset2))\n    return G"
 },
 {
  "docstring": "Returns a random cograph with $2 ^ n$ nodes.\n\nA cograph is a graph containing no path on four vertices.\nCographs or $P_4$-free graphs can be obtained from a single vertex\nby disjoint union and complementation operations.\n\nThis generator starts off from a single vertex and performs disjoint\nunion and full join operations on itself.\nThe decision on which operation will take place is random.\n\nParameters\n----------\nn : int\n    The order of the cograph.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : A random graph containing no path on four vertices.\n\nSee Also\n--------\nfull_join\nunion\n\n",
  "code": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_cograph(n, seed=None):\n    R = nx.empty_graph(1)\n    for i in range(n):\n        RR = nx.relabel_nodes(R.copy(), lambda x: x + len(R))\n        if seed.randint(0, 1) == 0:\n            R = nx.full_join(R, RR)\n        else:\n            R = nx.disjoint_union(R, RR)\n    return R"
 },
 {
  "docstring": "Returns a caveman graph of `l` cliques of size `k`.\n\nParameters\n----------\nl : int\n  Number of cliques\nk : int\n  Size of cliques\n\nReturns\n-------\nG : NetworkX Graph\n  caveman graph\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef caveman_graph(l, k):\n    G = nx.empty_graph(l * k)\n    if k > 1:\n        for start in range(0, l * k, k):\n            edges = itertools.combinations(range(start, start + k), 2)\n            G.add_edges_from(edges)\n    return G"
 },
 {
  "docstring": "Returns a connected caveman graph of `l` cliques of size `k`.\n\nThe connected caveman graph is formed by creating `n` cliques of size\n`k`, then a single edge in each clique is rewired to a node in an\nadjacent clique.\n\nParameters\n----------\nl : int\n  number of cliques\nk : int\n  size of cliques (k at least 2 or NetworkXError is raised)\n\nReturns\n-------\nG : NetworkX Graph\n  connected caveman graph\n\nRaises\n------\nNetworkXError\n    If the size of cliques `k` is smaller than 2.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef connected_caveman_graph(l, k):\n    if k < 2:\n        raise nx.NetworkXError('The size of cliques in a connected caveman graph must be at least 2.')\n    G = nx.caveman_graph(l, k)\n    for start in range(0, l * k, k):\n        G.remove_edge(start, start + 1)\n        G.add_edge(start, (start - 1) % (l * k))\n    return G"
 },
 {
  "docstring": "Returns a relaxed caveman graph.\n\nA relaxed caveman graph starts with `l` cliques of size `k`.  Edges are\nthen randomly rewired with probability `p` to link different cliques.\n\nParameters\n----------\nl : int\n  Number of groups\nk : int\n  Size of cliques\np : float\n  Probability of rewiring each edge.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : NetworkX Graph\n  Relaxed Caveman Graph\n\nRaises\n------\nNetworkXError\n If p is not in [0,1]\n\nExamples\n--------\n>>> G = nx.relaxed_caveman_graph(2, 3, 0.1, seed=42)\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef relaxed_caveman_graph(l, k, p, seed=None):\n    G = nx.caveman_graph(l, k)\n    nodes = list(G)\n    for u, v in G.edges():\n        if seed.random() < p:\n            x = seed.choice(nodes)\n            if G.has_edge(u, x):\n                continue\n            G.remove_edge(u, v)\n            G.add_edge(u, x)\n    return G"
 },
 {
  "docstring": "Returns the random partition graph with a partition of sizes.\n\nA partition graph is a graph of communities with sizes defined by\ns in sizes. Nodes in the same group are connected with probability\np_in and nodes of different groups are connected with probability\np_out.\n\nParameters\n----------\nsizes : list of ints\n  Sizes of groups\np_in : float\n  probability of edges with in groups\np_out : float\n  probability of edges between groups\ndirected : boolean optional, default=False\n  Whether to create a directed graph\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : NetworkX Graph or DiGraph\n  random partition graph of size sum(gs)\n\nRaises\n------\nNetworkXError\n  If p_in or p_out is not in [0,1]\n\nExamples\n--------\n>>> G = nx.random_partition_graph([10, 10, 10], 0.25, 0.01)\n>>> len(G)\n30\n>>> partition = G.graph[\"partition\"]\n>>> len(partition)\n3\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_partition_graph(sizes, p_in, p_out, seed=None, directed=False):\n    if not 0.0 <= p_in <= 1.0:\n        raise nx.NetworkXError('p_in must be in [0,1]')\n    if not 0.0 <= p_out <= 1.0:\n        raise nx.NetworkXError('p_out must be in [0,1]')\n    num_blocks = len(sizes)\n    p = [[p_out for s in range(num_blocks)] for r in range(num_blocks)]\n    for r in range(num_blocks):\n        p[r][r] = p_in\n    return stochastic_block_model(sizes, p, nodelist=None, seed=seed, directed=directed, selfloops=False, sparse=True)"
 },
 {
  "docstring": "Returns the planted l-partition graph.\n\nThis model partitions a graph with n=l*k vertices in\nl groups with k vertices each. Vertices of the same\ngroup are linked with a probability p_in, and vertices\nof different groups are linked with probability p_out.\n\nParameters\n----------\nl : int\n  Number of groups\nk : int\n  Number of vertices in each group\np_in : float\n  probability of connecting vertices within a group\np_out : float\n  probability of connected vertices between groups\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool,optional (default=False)\n  If True return a directed graph\n\nReturns\n-------\nG : NetworkX Graph or DiGraph\n  planted l-partition graph\n\nRaises\n------\nNetworkXError\n  If `p_in`, `p_out` are not in `[0, 1]`\n\nExamples\n--------\n>>> G = nx.planted_partition_graph(4, 3, 0.5, 0.1, seed=42)\n\nSee Also\n--------\nrandom_partition_model\n\n",
  "code": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef planted_partition_graph(l, k, p_in, p_out, seed=None, directed=False):\n    return random_partition_graph([k] * l, p_in, p_out, seed=seed, directed=directed)"
 },
 {
  "docstring": "Generate a Gaussian random partition graph.\n\nA Gaussian random partition graph is created by creating k partitions\neach with a size drawn from a normal distribution with mean s and variance\ns/v. Nodes are connected within clusters with probability p_in and\nbetween clusters with probability p_out[1]\n\nParameters\n----------\nn : int\n  Number of nodes in the graph\ns : float\n  Mean cluster size\nv : float\n  Shape parameter. The variance of cluster size distribution is s/v.\np_in : float\n  Probability of intra cluster connection.\np_out : float\n  Probability of inter cluster connection.\ndirected : boolean, optional default=False\n  Whether to create a directed graph or not\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : NetworkX Graph or DiGraph\n  gaussian random partition graph\n\nRaises\n------\nNetworkXError\n  If s is > n\n  If p_in or p_out is not in [0,1]\n\n",
  "code": "@py_random_state(6)\n@nx._dispatch(graphs=None)\ndef gaussian_random_partition_graph(n, s, v, p_in, p_out, directed=False, seed=None):\n    if s > n:\n        raise nx.NetworkXError('s must be <= n')\n    assigned = 0\n    sizes = []\n    while True:\n        size = int(seed.gauss(s, s / v + 0.5))\n        if size < 1:\n            continue\n        if assigned + size >= n:\n            sizes.append(n - assigned)\n            break\n        assigned += size\n        sizes.append(size)\n    return random_partition_graph(sizes, p_in, p_out, seed=seed, directed=directed)"
 },
 {
  "docstring": "Defines a \"ring of cliques\" graph.\n\nA ring of cliques graph is consisting of cliques, connected through single\nlinks. Each clique is a complete graph.\n\nParameters\n----------\nnum_cliques : int\n    Number of cliques\nclique_size : int\n    Size of cliques\n\nReturns\n-------\nG : NetworkX Graph\n    ring of cliques graph\n\nRaises\n------\nNetworkXError\n    If the number of cliques is lower than 2 or\n    if the size of cliques is smaller than 2.\n\nExamples\n--------\n>>> G = nx.ring_of_cliques(8, 4)\n\nSee Also\n--------\nconnected_caveman_graph\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef ring_of_cliques(num_cliques, clique_size):\n    if num_cliques < 2:\n        raise nx.NetworkXError('A ring of cliques must have at least two cliques')\n    if clique_size < 2:\n        raise nx.NetworkXError('The cliques must have at least two nodes')\n    G = nx.Graph()\n    for i in range(num_cliques):\n        edges = itertools.combinations(range(i * clique_size, i * clique_size + clique_size), 2)\n        G.add_edges_from(edges)\n        G.add_edge(i * clique_size + 1, (i + 1) * clique_size % (num_cliques * clique_size))\n    return G"
 },
 {
  "docstring": "Generate a windmill graph.\nA windmill graph is a graph of `n` cliques each of size `k` that are all\njoined at one node.\nIt can be thought of as taking a disjoint union of `n` cliques of size `k`,\nselecting one point from each, and contracting all of the selected points.\nAlternatively, one could generate `n` cliques of size `k-1` and one node\nthat is connected to all other nodes in the graph.\n\nParameters\n----------\nn : int\n    Number of cliques\nk : int\n    Size of cliques\n\nReturns\n-------\nG : NetworkX Graph\n    windmill graph with n cliques of size k\n\nRaises\n------\nNetworkXError\n    If the number of cliques is less than two\n    If the size of the cliques are less than two\n\nExamples\n--------\n>>> G = nx.windmill_graph(4, 5)\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef windmill_graph(n, k):\n    if n < 2:\n        msg = 'A windmill graph must have at least two cliques'\n        raise nx.NetworkXError(msg)\n    if k < 2:\n        raise nx.NetworkXError('The cliques must have at least two nodes')\n    G = nx.disjoint_union_all(itertools.chain([nx.complete_graph(k)], (nx.complete_graph(k - 1) for _ in range(n - 1))))\n    G.add_edges_from(((0, i) for i in range(k, G.number_of_nodes())))\n    return G"
 },
 {
  "docstring": "Returns a stochastic block model graph.\n\nThis model partitions the nodes in blocks of arbitrary sizes, and places\nedges between pairs of nodes independently, with a probability that depends\non the blocks.\n\nParameters\n----------\nsizes : list of ints\n    Sizes of blocks\np : list of list of floats\n    Element (r,s) gives the density of edges going from the nodes\n    of group r to nodes of group s.\n    p must match the number of groups (len(sizes) == len(p)),\n    and it must be symmetric if the graph is undirected.\nnodelist : list, optional\n    The block tags are assigned according to the node identifiers\n    in nodelist. If nodelist is None, then the ordering is the\n    range [0,sum(sizes)-1].\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : boolean optional, default=False\n    Whether to create a directed graph or not.\nselfloops : boolean optional, default=False\n    Whether to include self-loops or not.\nsparse: boolean optional, default=True\n    Use the sparse heuristic to speed up the generator.\n\nReturns\n-------\ng : NetworkX Graph or DiGraph\n    Stochastic block model graph of size sum(sizes)\n\nRaises\n------\nNetworkXError\n  If probabilities are not in [0,1].\n  If the probability matrix is not square (directed case).\n  If the probability matrix is not symmetric (undirected case).\n  If the sizes list does not match nodelist or the probability matrix.\n  If nodelist contains duplicate.\n\nExamples\n--------\n>>> sizes = [75, 75, 300]\n>>> probs = [[0.25, 0.05, 0.02], [0.05, 0.35, 0.07], [0.02, 0.07, 0.40]]\n>>> g = nx.stochastic_block_model(sizes, probs, seed=0)\n>>> len(g)\n450\n>>> H = nx.quotient_graph(g, g.graph[\"partition\"], relabel=True)\n>>> for v in H.nodes(data=True):\n...     print(round(v[1][\"density\"], 3))\n...\n0.245\n0.348\n0.405\n>>> for v in H.edges(data=True):\n...     print(round(1.0 * v[2][\"weight\"] / (sizes[v[0]] * sizes[v[1]]), 3))\n...\n0.051\n0.022\n0.07\n\nSee Also\n--------\nrandom_partition_graph\nplanted_partition_graph\ngaussian_random_partition_graph\ngnp_random_graph\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef stochastic_block_model(sizes, p, nodelist=None, seed=None, directed=False, selfloops=False, sparse=True):\n    if len(sizes) != len(p):\n        raise nx.NetworkXException(\"'sizes' and 'p' do not match.\")\n    for row in p:\n        if len(p) != len(row):\n            raise nx.NetworkXException(\"'p' must be a square matrix.\")\n    if not directed:\n        p_transpose = [list(i) for i in zip(*p)]\n        for i in zip(p, p_transpose):\n            for j in zip(i[0], i[1]):\n                if abs(j[0] - j[1]) > 1e-08:\n                    raise nx.NetworkXException(\"'p' must be symmetric.\")\n    for row in p:\n        for prob in row:\n            if prob < 0 or prob > 1:\n                raise nx.NetworkXException(\"Entries of 'p' not in [0,1].\")\n    if nodelist is not None:\n        if len(nodelist) != sum(sizes):\n            raise nx.NetworkXException(\"'nodelist' and 'sizes' do not match.\")\n        if len(nodelist) != len(set(nodelist)):\n            raise nx.NetworkXException('nodelist contains duplicate.')\n    else:\n        nodelist = range(sum(sizes))\n    block_range = range(len(sizes))\n    if directed:\n        g = nx.DiGraph()\n        block_iter = itertools.product(block_range, block_range)\n    else:\n        g = nx.Graph()\n        block_iter = itertools.combinations_with_replacement(block_range, 2)\n    size_cumsum = [sum(sizes[0:x]) for x in range(len(sizes) + 1)]\n    g.graph['partition'] = [set(nodelist[size_cumsum[x]:size_cumsum[x + 1]]) for x in range(len(size_cumsum) - 1)]\n    for block_id, nodes in enumerate(g.graph['partition']):\n        for node in nodes:\n            g.add_node(node, block=block_id)\n    g.name = 'stochastic_block_model'\n    parts = g.graph['partition']\n    for i, j in block_iter:\n        if i == j:\n            if directed:\n                if selfloops:\n                    edges = itertools.product(parts[i], parts[i])\n                else:\n                    edges = itertools.permutations(parts[i], 2)\n            else:\n                edges = itertools.combinations(parts[i], 2)\n                if selfloops:\n                    edges = itertools.chain(edges, zip(parts[i], parts[i]))\n            for e in edges:\n                if seed.random() < p[i][j]:\n                    g.add_edge(*e)\n        else:\n            edges = itertools.product(parts[i], parts[j])\n        if sparse:\n            if p[i][j] == 1:\n                for e in edges:\n                    g.add_edge(*e)\n            elif p[i][j] > 0:\n                while True:\n                    try:\n                        logrand = math.log(seed.random())\n                        skip = math.floor(logrand / math.log(1 - p[i][j]))\n                        next(itertools.islice(edges, skip, skip), None)\n                        e = next(edges)\n                        g.add_edge(*e)\n                    except StopIteration:\n                        break\n        else:\n            for e in edges:\n                if seed.random() < p[i][j]:\n                    g.add_edge(*e)\n    return g"
 },
 {
  "docstring": "Returns a random value chosen from the bounded Zipf distribution.\n\nRepeatedly draws values from the Zipf distribution until the\nthreshold is met, then returns that value.",
  "code": "def _zipf_rv_below(gamma, xmin, threshold, seed):\n    result = nx.utils.zipf_rv(gamma, xmin, seed)\n    while result > threshold:\n        result = nx.utils.zipf_rv(gamma, xmin, seed)\n    return result"
 },
 {
  "docstring": "Returns a list of numbers obeying a constrained power law distribution.\n\n``gamma`` and ``low`` are the parameters for the Zipf distribution.\n\n``high`` is the maximum allowed value for values draw from the Zipf\ndistribution. For more information, see :func:`_zipf_rv_below`.\n\n``condition`` and ``length`` are Boolean-valued functions on\nlists. While generating the list, random values are drawn and\nappended to the list until ``length`` is satisfied by the created\nlist. Once ``condition`` is satisfied, the sequence generated in\nthis way is returned.\n\n``max_iters`` indicates the number of times to generate a list\nsatisfying ``length``. If the number of iterations exceeds this\nvalue, :exc:`~networkx.exception.ExceededMaxIterations` is raised.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.",
  "code": "def _powerlaw_sequence(gamma, low, high, condition, length, max_iters, seed):\n    for i in range(max_iters):\n        seq = []\n        while not length(seq):\n            seq.append(_zipf_rv_below(gamma, low, high, seed))\n        if condition(seq):\n            return seq\n    raise nx.ExceededMaxIterations('Could not create power law sequence')"
 },
 {
  "docstring": "The Hurwitz zeta function, or the Riemann zeta function of two arguments.\n\n``x`` must be greater than one and ``q`` must be positive.\n\nThis function repeatedly computes subsequent partial sums until\nconvergence, as decided by ``tolerance``.",
  "code": "def _hurwitz_zeta(x, q, tolerance):\n    z = 0\n    z_prev = -float('inf')\n    k = 0\n    while abs(z - z_prev) > tolerance:\n        z_prev = z\n        z += 1 / (k + q) ** x\n        k += 1\n    return z"
 },
 {
  "docstring": "Returns a minimum degree from the given average degree.",
  "code": "def _generate_min_degree(gamma, average_degree, max_degree, tolerance, max_iters):\n    try:\n        from scipy.special import zeta\n    except ImportError:\n\n        def zeta(x, q):\n            return _hurwitz_zeta(x, q, tolerance)\n    min_deg_top = max_degree\n    min_deg_bot = 1\n    min_deg_mid = (min_deg_top - min_deg_bot) / 2 + min_deg_bot\n    itrs = 0\n    mid_avg_deg = 0\n    while abs(mid_avg_deg - average_degree) > tolerance:\n        if itrs > max_iters:\n            raise nx.ExceededMaxIterations('Could not match average_degree')\n        mid_avg_deg = 0\n        for x in range(int(min_deg_mid), max_degree + 1):\n            mid_avg_deg += x ** (-gamma + 1) / zeta(gamma, min_deg_mid)\n        if mid_avg_deg > average_degree:\n            min_deg_top = min_deg_mid\n            min_deg_mid = (min_deg_top - min_deg_bot) / 2 + min_deg_bot\n        else:\n            min_deg_bot = min_deg_mid\n            min_deg_mid = (min_deg_top - min_deg_bot) / 2 + min_deg_bot\n        itrs += 1\n    return round(min_deg_mid)"
 },
 {
  "docstring": "Returns a list of sets, each of which represents a community.\n\n``degree_seq`` is the degree sequence that must be met by the\ngraph.\n\n``community_sizes`` is the community size distribution that must be\nmet by the generated list of sets.\n\n``mu`` is a float in the interval [0, 1] indicating the fraction of\nintra-community edges incident to each node.\n\n``max_iters`` is the number of times to try to add a node to a\ncommunity. This must be greater than the length of\n``degree_seq``, otherwise this function will always fail. If\nthe number of iterations exceeds this value,\n:exc:`~networkx.exception.ExceededMaxIterations` is raised.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nThe communities returned by this are sets of integers in the set {0,\n..., *n* - 1}, where *n* is the length of ``degree_seq``.",
  "code": "def _generate_communities(degree_seq, community_sizes, mu, max_iters, seed):\n    result = [set() for _ in community_sizes]\n    n = len(degree_seq)\n    free = list(range(n))\n    for i in range(max_iters):\n        v = free.pop()\n        c = seed.choice(range(len(community_sizes)))\n        s = round(degree_seq[v] * (1 - mu))\n        if s < community_sizes[c]:\n            result[c].add(v)\n        else:\n            free.append(v)\n        if len(result[c]) > community_sizes[c]:\n            free.append(result[c].pop())\n        if not free:\n            return result\n    msg = 'Could not assign communities; try increasing min_community'\n    raise nx.ExceededMaxIterations(msg)"
 },
 {
  "docstring": "Returns the LFR benchmark graph.\n\nThis algorithm proceeds as follows:\n\n1) Find a degree sequence with a power law distribution, and minimum\n   value ``min_degree``, which has approximate average degree\n   ``average_degree``. This is accomplished by either\n\n   a) specifying ``min_degree`` and not ``average_degree``,\n   b) specifying ``average_degree`` and not ``min_degree``, in which\n      case a suitable minimum degree will be found.\n\n   ``max_degree`` can also be specified, otherwise it will be set to\n   ``n``. Each node *u* will have $\\mu \\mathrm{deg}(u)$ edges\n   joining it to nodes in communities other than its own and $(1 -\n   \\mu) \\mathrm{deg}(u)$ edges joining it to nodes in its own\n   community.\n2) Generate community sizes according to a power law distribution\n   with exponent ``tau2``. If ``min_community`` and\n   ``max_community`` are not specified they will be selected to be\n   ``min_degree`` and ``max_degree``, respectively.  Community sizes\n   are generated until the sum of their sizes equals ``n``.\n3) Each node will be randomly assigned a community with the\n   condition that the community is large enough for the node's\n   intra-community degree, $(1 - \\mu) \\mathrm{deg}(u)$ as\n   described in step 2. If a community grows too large, a random node\n   will be selected for reassignment to a new community, until all\n   nodes have been assigned a community.\n4) Each node *u* then adds $(1 - \\mu) \\mathrm{deg}(u)$\n   intra-community edges and $\\mu \\mathrm{deg}(u)$ inter-community\n   edges.\n\nParameters\n----------\nn : int\n    Number of nodes in the created graph.\n\ntau1 : float\n    Power law exponent for the degree distribution of the created\n    graph. This value must be strictly greater than one.\n\ntau2 : float\n    Power law exponent for the community size distribution in the\n    created graph. This value must be strictly greater than one.\n\nmu : float\n    Fraction of inter-community edges incident to each node. This\n    value must be in the interval [0, 1].\n\naverage_degree : float\n    Desired average degree of nodes in the created graph. This value\n    must be in the interval [0, *n*]. Exactly one of this and\n    ``min_degree`` must be specified, otherwise a\n    :exc:`NetworkXError` is raised.\n\nmin_degree : int\n    Minimum degree of nodes in the created graph. This value must be\n    in the interval [0, *n*]. Exactly one of this and\n    ``average_degree`` must be specified, otherwise a\n    :exc:`NetworkXError` is raised.\n\nmax_degree : int\n    Maximum degree of nodes in the created graph. If not specified,\n    this is set to ``n``, the total number of nodes in the graph.\n\nmin_community : int\n    Minimum size of communities in the graph. If not specified, this\n    is set to ``min_degree``.\n\nmax_community : int\n    Maximum size of communities in the graph. If not specified, this\n    is set to ``n``, the total number of nodes in the graph.\n\ntol : float\n    Tolerance when comparing floats, specifically when comparing\n    average degree values.\n\nmax_iters : int\n    Maximum number of iterations to try to create the community sizes,\n    degree distribution, and community affiliations.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : NetworkX graph\n    The LFR benchmark graph generated according to the specified\n    parameters.\n\n    Each node in the graph has a node attribute ``'community'`` that\n    stores the community (that is, the set of nodes) that includes\n    it.\n\nRaises\n------\nNetworkXError\n    If any of the parameters do not meet their upper and lower bounds:\n\n    - ``tau1`` and ``tau2`` must be strictly greater than 1.\n    - ``mu`` must be in [0, 1].\n    - ``max_degree`` must be in {1, ..., *n*}.\n    - ``min_community`` and ``max_community`` must be in {0, ...,\n      *n*}.\n\n    If not exactly one of ``average_degree`` and ``min_degree`` is\n    specified.\n\n    If ``min_degree`` is not specified and a suitable ``min_degree``\n    cannot be found.\n\nExceededMaxIterations\n    If a valid degree sequence cannot be created within\n    ``max_iters`` number of iterations.\n\n    If a valid set of community sizes cannot be created within\n    ``max_iters`` number of iterations.\n\n    If a valid community assignment cannot be created within ``10 *\n    n * max_iters`` number of iterations.\n\nExamples\n--------\nBasic usage::\n\n    >>> from networkx.generators.community import LFR_benchmark_graph\n    >>> n = 250\n    >>> tau1 = 3\n    >>> tau2 = 1.5\n    >>> mu = 0.1\n    >>> G = LFR_benchmark_graph(\n    ...     n, tau1, tau2, mu, average_degree=5, min_community=20, seed=10\n    ... )\n\nContinuing the example above, you can get the communities from the\nnode attributes of the graph::\n\n    >>> communities = {frozenset(G.nodes[v][\"community\"]) for v in G}\n\n",
  "code": "@py_random_state(11)\n@nx._dispatch(graphs=None)\ndef LFR_benchmark_graph(n, tau1, tau2, mu, average_degree=None, min_degree=None, max_degree=None, min_community=None, max_community=None, tol=1e-07, max_iters=500, seed=None):\n    if not tau1 > 1:\n        raise nx.NetworkXError('tau1 must be greater than one')\n    if not tau2 > 1:\n        raise nx.NetworkXError('tau2 must be greater than one')\n    if not 0 <= mu <= 1:\n        raise nx.NetworkXError('mu must be in the interval [0, 1]')\n    if max_degree is None:\n        max_degree = n\n    elif not 0 < max_degree <= n:\n        raise nx.NetworkXError('max_degree must be in the interval (0, n]')\n    if not (min_degree is None) ^ (average_degree is None):\n        raise nx.NetworkXError('Must assign exactly one of min_degree and average_degree')\n    if min_degree is None:\n        min_degree = _generate_min_degree(tau1, average_degree, max_degree, tol, max_iters)\n    low, high = (min_degree, max_degree)\n\n    def condition(seq):\n        return sum(seq) % 2 == 0\n\n    def length(seq):\n        return len(seq) >= n\n    deg_seq = _powerlaw_sequence(tau1, low, high, condition, length, max_iters, seed)\n    if min_community is None:\n        min_community = min(deg_seq)\n    if max_community is None:\n        max_community = max(deg_seq)\n    low, high = (min_community, max_community)\n\n    def condition(seq):\n        return sum(seq) == n\n\n    def length(seq):\n        return sum(seq) >= n\n    comms = _powerlaw_sequence(tau2, low, high, condition, length, max_iters, seed)\n    max_iters *= 10 * n\n    communities = _generate_communities(deg_seq, comms, mu, max_iters, seed)\n    G = nx.Graph()\n    G.add_nodes_from(range(n))\n    for c in communities:\n        for u in c:\n            while G.degree(u) < round(deg_seq[u] * (1 - mu)):\n                v = seed.choice(list(c))\n                G.add_edge(u, v)\n            while G.degree(u) < deg_seq[u]:\n                v = seed.choice(range(n))\n                if v not in c:\n                    G.add_edge(u, v)\n            G.nodes[u]['community'] = c\n    return G"
 },
 {
  "docstring": "Returns a list of degree-repeated node numbers.\n\n``degree_sequence`` is a list of nonnegative integers representing\nthe degrees of nodes in a graph.\n\nThis function returns a list of node numbers with multiplicities\naccording to the given degree sequence. For example, if the first\nelement of ``degree_sequence`` is ``3``, then the first node number,\n``0``, will appear at the head of the returned list three times. The\nnode numbers are assumed to be the numbers zero through\n``len(degree_sequence) - 1``.\n\nExamples\n--------\n\n>>> degree_sequence = [1, 2, 3]\n>>> _to_stublist(degree_sequence)\n[0, 1, 1, 2, 2, 2]\n\nIf a zero appears in the sequence, that means the node exists but\nhas degree zero, so that number will be skipped in the returned\nlist::\n\n>>> degree_sequence = [2, 0, 1]\n>>> _to_stublist(degree_sequence)\n[0, 0, 2]",
  "code": "def _to_stublist(degree_sequence):\n    return list(chaini(([n] * d for n, d in enumerate(degree_sequence))))"
 },
 {
  "docstring": "Helper function for generating either undirected or directed\nconfiguration model graphs.\n\n``deg_sequence`` is a list of nonnegative integers representing the\ndegree of the node whose label is the index of the list element.\n\n``create_using`` see :func:`~networkx.empty_graph`.\n\n``directed`` and ``in_deg_sequence`` are required if you want the\nreturned graph to be generated using the directed configuration\nmodel algorithm. If ``directed`` is ``False``, then ``deg_sequence``\nis interpreted as the degree sequence of an undirected graph and\n``in_deg_sequence`` is ignored. Otherwise, if ``directed`` is\n``True``, then ``deg_sequence`` is interpreted as the out-degree\nsequence and ``in_deg_sequence`` as the in-degree sequence of a\ndirected graph.\n\n.. note::\n\n   ``deg_sequence`` and ``in_deg_sequence`` need not be the same\n   length.\n\n``seed`` is a random.Random or numpy.random.RandomState instance\n\nThis function returns a graph, directed if and only if ``directed``\nis ``True``, generated according to the configuration model\nalgorithm. For more information on the algorithm, see the\n:func:`configuration_model` or :func:`directed_configuration_model`\nfunctions.",
  "code": "def _configuration_model(deg_sequence, create_using, directed=False, in_deg_sequence=None, seed=None):\n    n = len(deg_sequence)\n    G = nx.empty_graph(n, create_using)\n    if n == 0:\n        return G\n    if directed:\n        pairs = zip_longest(deg_sequence, in_deg_sequence, fillvalue=0)\n        out_deg, in_deg = zip(*pairs)\n        out_stublist = _to_stublist(out_deg)\n        in_stublist = _to_stublist(in_deg)\n        seed.shuffle(out_stublist)\n        seed.shuffle(in_stublist)\n    else:\n        stublist = _to_stublist(deg_sequence)\n        n = len(stublist)\n        half = n // 2\n        seed.shuffle(stublist)\n        out_stublist, in_stublist = (stublist[:half], stublist[half:])\n    G.add_edges_from(zip(out_stublist, in_stublist))\n    return G"
 },
 {
  "docstring": "Returns a random graph with the given degree sequence.\n\nThe configuration model generates a random pseudograph (graph with\nparallel edges and self loops) by randomly assigning edges to\nmatch the given degree sequence.\n\nParameters\n----------\ndeg_sequence :  list of nonnegative integers\n    Each list entry corresponds to the degree of a node.\ncreate_using : NetworkX graph constructor, optional (default MultiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : MultiGraph\n    A graph with the specified degree sequence.\n    Nodes are labeled starting at 0 with an index\n    corresponding to the position in deg_sequence.\n\nRaises\n------\nNetworkXError\n    If the degree sequence does not have an even sum.\n\nSee Also\n--------\nis_graphical\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef configuration_model(deg_sequence, create_using=None, seed=None):\n    if sum(deg_sequence) % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)\n    if G.is_directed():\n        raise nx.NetworkXNotImplemented('not implemented for directed graphs')\n    G = _configuration_model(deg_sequence, G, seed=seed)\n    return G"
 },
 {
  "docstring": "Returns a directed_random graph with the given degree sequences.\n\nThe configuration model generates a random directed pseudograph\n(graph with parallel edges and self loops) by randomly assigning\nedges to match the given degree sequences.\n\nParameters\n----------\nin_degree_sequence :  list of nonnegative integers\n   Each list entry corresponds to the in-degree of a node.\nout_degree_sequence :  list of nonnegative integers\n   Each list entry corresponds to the out-degree of a node.\ncreate_using : NetworkX graph constructor, optional (default MultiDiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : MultiDiGraph\n    A graph with the specified degree sequences.\n    Nodes are labeled starting at 0 with an index\n    corresponding to the position in deg_sequence.\n\nRaises\n------\nNetworkXError\n    If the degree sequences do not have the same sum.\n\nSee Also\n--------\nconfiguration_model\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef directed_configuration_model(in_degree_sequence, out_degree_sequence, create_using=None, seed=None):\n    if sum(in_degree_sequence) != sum(out_degree_sequence):\n        msg = 'Invalid degree sequences: sequences must have equal sums'\n        raise nx.NetworkXError(msg)\n    if create_using is None:\n        create_using = nx.MultiDiGraph\n    G = _configuration_model(out_degree_sequence, create_using, directed=True, in_deg_sequence=in_degree_sequence, seed=seed)\n    name = 'directed configuration_model {} nodes {} edges'\n    return G"
 },
 {
  "docstring": "Returns a random graph with given expected degrees.\n\nGiven a sequence of expected degrees $W=(w_0,w_1,\\ldots,w_{n-1})$\nof length $n$ this algorithm assigns an edge between node $u$ and\nnode $v$ with probability\n\n.. math::\n\n   p_{uv} = \\frac{w_u w_v}{\\sum_k w_k} .\n\nParameters\n----------\nw : list\n    The list of expected degrees.\nselfloops: bool (default=True)\n    Set to False to remove the possibility of self-loop edges.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nGraph\n\nExamples\n--------\n>>> z = [10 for i in range(100)]\n>>> G = nx.expected_degree_graph(z)\n\n",
  "code": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef expected_degree_graph(w, seed=None, selfloops=True):\n    n = len(w)\n    G = nx.empty_graph(n)\n    if n == 0 or max(w) == 0:\n        return G\n    rho = 1 / sum(w)\n    order = sorted(enumerate(w), key=itemgetter(1), reverse=True)\n    mapping = {c: u for c, (u, v) in enumerate(order)}\n    seq = [v for u, v in order]\n    last = n\n    if not selfloops:\n        last -= 1\n    for u in range(last):\n        v = u\n        if not selfloops:\n            v += 1\n        factor = seq[u] * rho\n        p = min(seq[v] * factor, 1)\n        while v < n and p > 0:\n            if p != 1:\n                r = seed.random()\n                v += math.floor(math.log(r, 1 - p))\n            if v < n:\n                q = min(seq[v] * factor, 1)\n                if seed.random() < q / p:\n                    G.add_edge(mapping[u], mapping[v])\n                v += 1\n                p = q\n    return G"
 },
 {
  "docstring": "Returns a simple graph with given degree sequence constructed\nusing the Havel-Hakimi algorithm.\n\nParameters\n----------\ndeg_sequence: list of integers\n    Each integer corresponds to the degree of a node (need not be sorted).\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n    Directed graphs are not allowed.\n\nRaises\n------\nNetworkXException\n    For a non-graphical degree sequence (i.e. one\n    not realizable by some simple graph).\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef havel_hakimi_graph(deg_sequence, create_using=None):\n    if not nx.is_graphical(deg_sequence):\n        raise nx.NetworkXError('Invalid degree sequence')\n    p = len(deg_sequence)\n    G = nx.empty_graph(p, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed graphs are not supported')\n    num_degs = [[] for i in range(p)]\n    dmax, dsum, n = (0, 0, 0)\n    for d in deg_sequence:\n        if d > 0:\n            num_degs[d].append(n)\n            dmax, dsum, n = (max(dmax, d), dsum + d, n + 1)\n    if n == 0:\n        return G\n    modstubs = [(0, 0)] * (dmax + 1)\n    while n > 0:\n        while len(num_degs[dmax]) == 0:\n            dmax -= 1\n        if dmax > n - 1:\n            raise nx.NetworkXError('Non-graphical integer sequence')\n        source = num_degs[dmax].pop()\n        n -= 1\n        mslen = 0\n        k = dmax\n        for i in range(dmax):\n            while len(num_degs[k]) == 0:\n                k -= 1\n            target = num_degs[k].pop()\n            G.add_edge(source, target)\n            n -= 1\n            if k > 1:\n                modstubs[mslen] = (k - 1, target)\n                mslen += 1\n        for i in range(mslen):\n            stubval, stubtarget = modstubs[i]\n            num_degs[stubval].append(stubtarget)\n            n += 1\n    return G"
 },
 {
  "docstring": "Returns a directed graph with the given degree sequences.\n\nParameters\n----------\nin_deg_sequence :  list of integers\n    Each list entry corresponds to the in-degree of a node.\nout_deg_sequence : list of integers\n    Each list entry corresponds to the out-degree of a node.\ncreate_using : NetworkX graph constructor, optional (default DiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : DiGraph\n    A graph with the specified degree sequences.\n    Nodes are labeled starting at 0 with an index\n    corresponding to the position in deg_sequence\n\nRaises\n------\nNetworkXError\n    If the degree sequences are not digraphical.\n\nSee Also\n--------\nconfiguration_model\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef directed_havel_hakimi_graph(in_deg_sequence, out_deg_sequence, create_using=None):\n    in_deg_sequence = nx.utils.make_list_of_ints(in_deg_sequence)\n    out_deg_sequence = nx.utils.make_list_of_ints(out_deg_sequence)\n    sumin, sumout = (0, 0)\n    nin, nout = (len(in_deg_sequence), len(out_deg_sequence))\n    maxn = max(nin, nout)\n    G = nx.empty_graph(maxn, create_using, default=nx.DiGraph)\n    if maxn == 0:\n        return G\n    maxin = 0\n    stubheap, zeroheap = ([], [])\n    for n in range(maxn):\n        in_deg, out_deg = (0, 0)\n        if n < nout:\n            out_deg = out_deg_sequence[n]\n        if n < nin:\n            in_deg = in_deg_sequence[n]\n        if in_deg < 0 or out_deg < 0:\n            raise nx.NetworkXError('Invalid degree sequences. Sequence values must be positive.')\n        sumin, sumout, maxin = (sumin + in_deg, sumout + out_deg, max(maxin, in_deg))\n        if in_deg > 0:\n            stubheap.append((-1 * out_deg, -1 * in_deg, n))\n        elif out_deg > 0:\n            zeroheap.append((-1 * out_deg, n))\n    if sumin != sumout:\n        raise nx.NetworkXError('Invalid degree sequences. Sequences must have equal sums.')\n    heapq.heapify(stubheap)\n    heapq.heapify(zeroheap)\n    modstubs = [(0, 0, 0)] * (maxin + 1)\n    while stubheap:\n        freeout, freein, target = heapq.heappop(stubheap)\n        freein *= -1\n        if freein > len(stubheap) + len(zeroheap):\n            raise nx.NetworkXError('Non-digraphical integer sequence')\n        mslen = 0\n        for i in range(freein):\n            if zeroheap and (not stubheap or stubheap[0][0] > zeroheap[0][0]):\n                stubout, stubsource = heapq.heappop(zeroheap)\n                stubin = 0\n            else:\n                stubout, stubin, stubsource = heapq.heappop(stubheap)\n            if stubout == 0:\n                raise nx.NetworkXError('Non-digraphical integer sequence')\n            G.add_edge(stubsource, target)\n            if stubout + 1 < 0 or stubin < 0:\n                modstubs[mslen] = (stubout + 1, stubin, stubsource)\n                mslen += 1\n        for i in range(mslen):\n            stub = modstubs[i]\n            if stub[1] < 0:\n                heapq.heappush(stubheap, stub)\n            else:\n                heapq.heappush(zeroheap, (stub[0], stub[2]))\n        if freeout < 0:\n            heapq.heappush(zeroheap, (freeout, target))\n    return G"
 },
 {
  "docstring": "Make a tree for the given degree sequence.\n\nA tree has #nodes-#edges=1 so\nthe degree sequence must have\nlen(deg_sequence)-sum(deg_sequence)/2=1",
  "code": "@nx._dispatch(graphs=None)\ndef degree_sequence_tree(deg_sequence, create_using=None):\n    degree_sum = sum(deg_sequence)\n    if degree_sum % 2 != 0:\n        msg = 'Invalid degree sequence: sum of degrees must be even, not odd'\n        raise nx.NetworkXError(msg)\n    if len(deg_sequence) - degree_sum // 2 != 1:\n        msg = 'Invalid degree sequence: tree must have number of nodes equal to one less than the number of edges'\n        raise nx.NetworkXError(msg)\n    G = nx.empty_graph(0, create_using)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed Graph not supported')\n    deg = sorted((s for s in deg_sequence if s > 1), reverse=True)\n    n = len(deg) + 2\n    nx.add_path(G, range(n))\n    last = n\n    for source in range(1, n - 1):\n        nedges = deg.pop() - 2\n        for target in range(last, last + nedges):\n            G.add_edge(source, target)\n        last += nedges\n    if len(G) > len(deg_sequence):\n        G.remove_node(0)\n    return G"
 },
 {
  "docstring": "Returns a simple random graph with the given degree sequence.\n\nIf the maximum degree $d_m$ in the sequence is $O(m^{1/4})$ then the\nalgorithm produces almost uniform random graphs in $O(m d_m)$ time\nwhere $m$ is the number of edges.\n\nParameters\n----------\nsequence :  list of integers\n    Sequence of degrees\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ntries : int, optional\n    Maximum number of tries to create a graph\n\nReturns\n-------\nG : Graph\n    A graph with the specified degree sequence.\n    Nodes are labeled starting at 0 with an index\n    corresponding to the position in the sequence.\n\nRaises\n------\nNetworkXUnfeasible\n    If the degree sequence is not graphical.\nNetworkXError\n    If a graph is not produced in specified number of tries\n\nSee Also\n--------\nis_graphical, configuration_model\n\n",
  "code": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_degree_sequence_graph(sequence, seed=None, tries=10):\n    DSRG = DegreeSequenceRandomGraph(sequence, seed)\n    for try_n in range(tries):\n        try:\n            return DSRG.generate()\n        except nx.NetworkXUnfeasible:\n            pass\n    raise nx.NetworkXError(f'failed to generate graph in {tries} tries')"
 },
 {
  "docstring": "Returns True if and only if an arbitrary remaining node can\npotentially be joined with some other remaining node.",
  "code": "def suitable_edge(self):\n    nodes = iter(self.remaining_degree)\n    u = next(nodes)\n    return any((v not in self.graph[u] for v in nodes))"
 },
 {
  "docstring": "Returns the growing network (GN) digraph with `n` nodes.\n\nThe GN graph is built by adding nodes one at a time with a link to one\npreviously added node.  The target node for the link is chosen with\nprobability based on degree.  The default attachment kernel is a linear\nfunction of the degree of a node.\n\nThe graph is always a (directed) tree.\n\nParameters\n----------\nn : int\n    The number of nodes for the generated graph.\nkernel : function\n    The attachment kernel.\ncreate_using : NetworkX graph constructor, optional (default DiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nExamples\n--------\nTo create the undirected GN graph, use the :meth:`~DiGraph.to_directed`\nmethod::\n\n>>> D = nx.gn_graph(10)  # the GN graph\n>>> G = D.to_undirected()  # the undirected version\n\nTo specify an attachment kernel, use the `kernel` keyword argument::\n\n>>> D = nx.gn_graph(10, kernel=lambda x: x ** 1.5)  # A_k = k^1.5\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef gn_graph(n, kernel=None, create_using=None, seed=None):\n    G = empty_graph(1, create_using, default=nx.DiGraph)\n    if not G.is_directed():\n        raise nx.NetworkXError('create_using must indicate a Directed Graph')\n    if kernel is None:\n\n        def kernel(x):\n            return x\n    if n == 1:\n        return G\n    G.add_edge(1, 0)\n    ds = [1, 1]\n    for source in range(2, n):\n        dist = [kernel(d) for d in ds]\n        target = discrete_sequence(1, distribution=dist, seed=seed)[0]\n        G.add_edge(source, target)\n        ds.append(1)\n        ds[target] += 1\n    return G"
 },
 {
  "docstring": "Returns the growing network with redirection (GNR) digraph with `n`\nnodes and redirection probability `p`.\n\nThe GNR graph is built by adding nodes one at a time with a link to one\npreviously added node.  The previous target node is chosen uniformly at\nrandom.  With probability `p` the link is instead \"redirected\" to the\nsuccessor node of the target.\n\nThe graph is always a (directed) tree.\n\nParameters\n----------\nn : int\n    The number of nodes for the generated graph.\np : float\n    The redirection probability.\ncreate_using : NetworkX graph constructor, optional (default DiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nExamples\n--------\nTo create the undirected GNR graph, use the :meth:`~DiGraph.to_directed`\nmethod::\n\n>>> D = nx.gnr_graph(10, 0.5)  # the GNR graph\n>>> G = D.to_undirected()  # the undirected version\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef gnr_graph(n, p, create_using=None, seed=None):\n    G = empty_graph(1, create_using, default=nx.DiGraph)\n    if not G.is_directed():\n        raise nx.NetworkXError('create_using must indicate a Directed Graph')\n    if n == 1:\n        return G\n    for source in range(1, n):\n        target = seed.randrange(0, source)\n        if seed.random() < p and target != 0:\n            target = next(G.successors(target))\n        G.add_edge(source, target)\n    return G"
 },
 {
  "docstring": "Returns the growing network with copying (GNC) digraph with `n` nodes.\n\nThe GNC graph is built by adding nodes one at a time with a link to one\npreviously added node (chosen uniformly at random) and to all of that\nnode's successors.\n\nParameters\n----------\nn : int\n    The number of nodes for the generated graph.\ncreate_using : NetworkX graph constructor, optional (default DiGraph)\n    Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnc_graph(n, create_using=None, seed=None):\n    G = empty_graph(1, create_using, default=nx.DiGraph)\n    if not G.is_directed():\n        raise nx.NetworkXError('create_using must indicate a Directed Graph')\n    if n == 1:\n        return G\n    for source in range(1, n):\n        target = seed.randrange(0, source)\n        for succ in G.successors(target):\n            G.add_edge(source, succ)\n        G.add_edge(source, target)\n    return G"
 },
 {
  "docstring": "Returns a scale-free directed graph.\n\nParameters\n----------\nn : integer\n    Number of nodes in graph\nalpha : float\n    Probability for adding a new node connected to an existing node\n    chosen randomly according to the in-degree distribution.\nbeta : float\n    Probability for adding an edge between two existing nodes.\n    One existing node is chosen randomly according the in-degree\n    distribution and the other chosen randomly according to the out-degree\n    distribution.\ngamma : float\n    Probability for adding a new node connected to an existing node\n    chosen randomly according to the out-degree distribution.\ndelta_in : float\n    Bias for choosing nodes from in-degree distribution.\ndelta_out : float\n    Bias for choosing nodes from out-degree distribution.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ninitial_graph : MultiDiGraph instance, optional\n    Build the scale-free graph starting from this initial MultiDiGraph,\n    if provided.\n\nReturns\n-------\nMultiDiGraph\n\nExamples\n--------\nCreate a scale-free graph on one hundred nodes::\n\n>>> G = nx.scale_free_graph(100)\n\n",
  "code": "@py_random_state(6)\n@nx._dispatch(graphs=None)\ndef scale_free_graph(n, alpha=0.41, beta=0.54, gamma=0.05, delta_in=0.2, delta_out=0, seed=None, initial_graph=None):\n\n    def _choose_node(candidates, node_list, delta):\n        if delta > 0:\n            bias_sum = len(node_list) * delta\n            p_delta = bias_sum / (bias_sum + len(candidates))\n            if seed.random() < p_delta:\n                return seed.choice(node_list)\n        return seed.choice(candidates)\n    if initial_graph is not None and hasattr(initial_graph, '_adj'):\n        if not isinstance(initial_graph, nx.MultiDiGraph):\n            raise nx.NetworkXError('initial_graph must be a MultiDiGraph.')\n        G = initial_graph\n    else:\n        G = nx.MultiDiGraph([(0, 1), (1, 2), (2, 0)])\n    if alpha <= 0:\n        raise ValueError('alpha must be > 0.')\n    if beta <= 0:\n        raise ValueError('beta must be > 0.')\n    if gamma <= 0:\n        raise ValueError('gamma must be > 0.')\n    if abs(alpha + beta + gamma - 1.0) >= 1e-09:\n        raise ValueError('alpha+beta+gamma must equal 1.')\n    if delta_in < 0:\n        raise ValueError('delta_in must be >= 0.')\n    if delta_out < 0:\n        raise ValueError('delta_out must be >= 0.')\n    vs = sum((count * [idx] for idx, count in G.out_degree()), [])\n    ws = sum((count * [idx] for idx, count in G.in_degree()), [])\n    node_list = list(G.nodes())\n    numeric_nodes = [n for n in node_list if isinstance(n, numbers.Number)]\n    if len(numeric_nodes) > 0:\n        cursor = max((int(n.real) for n in numeric_nodes)) + 1\n    else:\n        cursor = 0\n    while len(G) < n:\n        r = seed.random()\n        if r < alpha:\n            v = cursor\n            cursor += 1\n            node_list.append(v)\n            w = _choose_node(ws, node_list, delta_in)\n        elif r < alpha + beta:\n            v = _choose_node(vs, node_list, delta_out)\n            w = _choose_node(ws, node_list, delta_in)\n        else:\n            v = _choose_node(vs, node_list, delta_out)\n            w = cursor\n            cursor += 1\n            node_list.append(w)\n        G.add_edge(v, w)\n        vs.append(v)\n        ws.append(w)\n    return G"
 },
 {
  "docstring": "Returns a random `k`-out graph with uniform attachment.\n\nA random `k`-out graph with uniform attachment is a multidigraph\ngenerated by the following algorithm. For each node *u*, choose\n`k` nodes *v* uniformly at random (with replacement). Add a\ndirected edge joining *u* to *v*.\n\nParameters\n----------\nn : int\n    The number of nodes in the returned graph.\n\nk : int\n    The out-degree of each node in the returned graph.\n\nself_loops : bool\n    If True, self-loops are allowed when generating the graph.\n\nwith_replacement : bool\n    If True, neighbors are chosen with replacement and the\n    returned graph will be a directed multigraph. Otherwise,\n    neighbors are chosen without replacement and the returned graph\n    will be a directed graph.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nNetworkX graph\n    A `k`-out-regular directed graph generated according to the\n    above algorithm. It will be a multigraph if and only if\n    `with_replacement` is True.\n\nRaises\n------\nValueError\n    If `with_replacement` is False and `k` is greater than\n    `n`.\n\n",
  "code": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef random_uniform_k_out_graph(n, k, self_loops=True, with_replacement=True, seed=None):\n    if with_replacement:\n        create_using = nx.MultiDiGraph()\n\n        def sample(v, nodes):\n            if not self_loops:\n                nodes = nodes - {v}\n            return (seed.choice(list(nodes)) for i in range(k))\n    else:\n        create_using = nx.DiGraph()\n\n        def sample(v, nodes):\n            if not self_loops:\n                nodes = nodes - {v}\n            return seed.sample(list(nodes), k)\n    G = nx.empty_graph(n, create_using)\n    nodes = set(G)\n    for u in G:\n        G.add_edges_from(((u, v) for v in sample(u, nodes)))\n    return G"
 },
 {
  "docstring": "Returns a random `k`-out graph with preferential attachment.\n\nA random `k`-out graph with preferential attachment is a\nmultidigraph generated by the following algorithm.\n\n1. Begin with an empty digraph, and initially set each node to have\n   weight `alpha`.\n2. Choose a node `u` with out-degree less than `k` uniformly at\n   random.\n3. Choose a node `v` from with probability proportional to its\n   weight.\n4. Add a directed edge from `u` to `v`, and increase the weight\n   of `v` by one.\n5. If each node has out-degree `k`, halt, otherwise repeat from\n   step 2.\n\nFor more information on this model of random graph, see [1].\n\nParameters\n----------\nn : int\n    The number of nodes in the returned graph.\n\nk : int\n    The out-degree of each node in the returned graph.\n\nalpha : float\n    A positive :class:`float` representing the initial weight of\n    each vertex. A higher number means that in step 3 above, nodes\n    will be chosen more like a true uniformly random sample, and a\n    lower number means that nodes are more likely to be chosen as\n    their in-degree increases. If this parameter is not positive, a\n    :exc:`ValueError` is raised.\n\nself_loops : bool\n    If True, self-loops are allowed when generating the graph.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`~networkx.classes.MultiDiGraph`\n    A `k`-out-regular multidigraph generated according to the above\n    algorithm.\n\nRaises\n------\nValueError\n    If `alpha` is not positive.\n\n",
  "code": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef random_k_out_graph(n, k, alpha, self_loops=True, seed=None):\n    if alpha < 0:\n        raise ValueError('alpha must be positive')\n    G = nx.empty_graph(n, create_using=nx.MultiDiGraph)\n    weights = Counter({v: alpha for v in G})\n    for i in range(k * n):\n        u = seed.choice([v for v, d in G.out_degree() if d < k])\n        if not self_loops:\n            adjustment = Counter({u: weights[u]})\n        else:\n            adjustment = Counter()\n        v = weighted_choice(weights - adjustment, seed=seed)\n        G.add_edge(u, v)\n        weights[v] += 1\n    return G"
 },
 {
  "docstring": "Returns a random graph using the partial duplication model.\n\nParameters\n----------\nN : int\n    The total number of nodes in the final graph.\n\nn : int\n    The number of nodes in the initial clique.\n\np : float\n    The probability of joining each neighbor of a node to the\n    duplicate node. Must be a number in the between zero and one,\n    inclusive.\n\nq : float\n    The probability of joining the source node to the duplicate\n    node. Must be a number in the between zero and one, inclusive.\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\n",
  "code": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef partial_duplication_graph(N, n, p, q, seed=None):\n    if p < 0 or p > 1 or q < 0 or (q > 1):\n        msg = 'partial duplication graph must have 0 <= p, q <= 1.'\n        raise NetworkXError(msg)\n    if n > N:\n        raise NetworkXError('partial duplication graph must have n <= N.')\n    G = nx.complete_graph(n)\n    for new_node in range(n, N):\n        src_node = seed.randint(0, new_node - 1)\n        G.add_node(new_node)\n        for neighbor_node in list(nx.all_neighbors(G, src_node)):\n            if seed.random() < p:\n                G.add_edge(new_node, neighbor_node)\n        if seed.random() < q:\n            G.add_edge(new_node, src_node)\n    return G"
 },
 {
  "docstring": "Returns an undirected graph using the duplication-divergence model.\n\nA graph of `n` nodes is created by duplicating the initial nodes\nand retaining edges incident to the original nodes with a retention\nprobability `p`.\n\nParameters\n----------\nn : int\n    The desired number of nodes in the graph.\np : float\n    The probability for retaining the edge of the replicated node.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If `p` is not a valid probability.\n    If `n` is less than 2.\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef duplication_divergence_graph(n, p, seed=None):\n    if p > 1 or p < 0:\n        msg = f'NetworkXError p={p} is not in [0,1].'\n        raise nx.NetworkXError(msg)\n    if n < 2:\n        msg = 'n must be greater than or equal to 2'\n        raise nx.NetworkXError(msg)\n    G = nx.Graph()\n    G.add_edge(0, 1)\n    i = 2\n    while i < n:\n        random_node = seed.choice(list(G))\n        G.add_node(i)\n        flag = False\n        for nbr in G.neighbors(random_node):\n            if seed.random() < p:\n                G.add_edge(i, nbr)\n                flag = True\n        if not flag:\n            G.remove_node(i)\n        else:\n            i += 1\n    return G"
 },
 {
  "docstring": "Returns induced subgraph of neighbors centered at node n within\na given radius.\n\nParameters\n----------\nG : graph\n  A NetworkX Graph or DiGraph\n\nn : node\n  A single node\n\nradius : number, optional\n  Include all neighbors of distance<=radius from n.\n\ncenter : bool, optional\n  If False, do not include center node in graph\n\nundirected : bool, optional\n  If True use both in- and out-neighbors of directed graphs.\n\ndistance : key, optional\n  Use specified edge data key as distance.  For example, setting\n  distance='weight' will use the edge weight to measure the\n  distance from the node n.\n\n",
  "code": "@nx._dispatch(preserve_all_attrs=True)\ndef ego_graph(G, n, radius=1, center=True, undirected=False, distance=None):\n    if undirected:\n        if distance is not None:\n            sp, _ = nx.single_source_dijkstra(G.to_undirected(), n, cutoff=radius, weight=distance)\n        else:\n            sp = dict(nx.single_source_shortest_path_length(G.to_undirected(), n, cutoff=radius))\n    elif distance is not None:\n        sp, _ = nx.single_source_dijkstra(G, n, cutoff=radius, weight=distance)\n    else:\n        sp = dict(nx.single_source_shortest_path_length(G, n, cutoff=radius))\n    H = G.subgraph(sp).copy()\n    if not center:\n        H.remove_node(n)\n    return H"
 },
 {
  "docstring": "Returns the Margulis-Gabber-Galil undirected MultiGraph on `n^2` nodes.\n\nThe undirected MultiGraph is regular with degree `8`. Nodes are integer\npairs. The second-largest eigenvalue of the adjacency matrix of the graph\nis at most `5 \\sqrt{2}`, regardless of `n`.\n\nParameters\n----------\nn : int\n    Determines the number of nodes in the graph: `n^2`.\ncreate_using : NetworkX graph constructor, optional (default MultiGraph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : graph\n    The constructed undirected multigraph.\n\nRaises\n------\nNetworkXError\n    If the graph is directed or not a multigraph.",
  "code": "@nx._dispatch(graphs=None)\ndef margulis_gabber_galil_graph(n, create_using=None):\n    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)\n    if G.is_directed() or not G.is_multigraph():\n        msg = '`create_using` must be an undirected multigraph.'\n        raise nx.NetworkXError(msg)\n    for x, y in itertools.product(range(n), repeat=2):\n        for u, v in (((x + 2 * y) % n, y), ((x + (2 * y + 1)) % n, y), (x, (y + 2 * x) % n), (x, (y + (2 * x + 1)) % n)):\n            G.add_edge((x, y), (u, v))\n    G.graph['name'] = f'margulis_gabber_galil_graph({n})'\n    return G"
 },
 {
  "docstring": "Returns the chordal cycle graph on `p` nodes.\n\nThe returned graph is a cycle graph on `p` nodes with chords joining each\nvertex `x` to its inverse modulo `p`. This graph is a (mildly explicit)\n3-regular expander [1]_.\n\n`p` *must* be a prime number.\n\nParameters\n----------\np : a prime number\n\n    The number of vertices in the graph. This also indicates where the\n    chordal edges in the cycle will be created.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : graph\n    The constructed undirected multigraph.\n\nRaises\n------\nNetworkXError\n\n    If `create_using` indicates directed or not a multigraph.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef chordal_cycle_graph(p, create_using=None):\n    G = nx.empty_graph(0, create_using, default=nx.MultiGraph)\n    if G.is_directed() or not G.is_multigraph():\n        msg = '`create_using` must be an undirected multigraph.'\n        raise nx.NetworkXError(msg)\n    for x in range(p):\n        left = (x - 1) % p\n        right = (x + 1) % p\n        chord = pow(x, p - 2, p) if x > 0 else 0\n        for y in (left, right, chord):\n            G.add_edge(x, y)\n    G.graph['name'] = f'chordal_cycle_graph({p})'\n    return G"
 },
 {
  "docstring": "Returns the Paley $\\frac{(p-1)}{2}$ -regular graph on $p$ nodes.\n\nThe returned graph is a graph on $\\mathbb{Z}/p\\mathbb{Z}$ with edges between $x$ and $y$\nif and only if $x-y$ is a nonzero square in $\\mathbb{Z}/p\\mathbb{Z}$.\n\nIf $p \\equiv 1  \\pmod 4$, $-1$ is a square in $\\mathbb{Z}/p\\mathbb{Z}$ and therefore $x-y$ is a square if and\nonly if $y-x$ is also a square, i.e the edges in the Paley graph are symmetric.\n\nIf $p \\equiv 3 \\pmod 4$, $-1$ is not a square in $\\mathbb{Z}/p\\mathbb{Z}$ and therefore either $x-y$ or $y-x$\nis a square in $\\mathbb{Z}/p\\mathbb{Z}$ but not both.\n\nNote that a more general definition of Paley graphs extends this construction\nto graphs over $q=p^n$ vertices, by using the finite field $F_q$ instead of $\\mathbb{Z}/p\\mathbb{Z}$.\nThis construction requires to compute squares in general finite fields and is\nnot what is implemented here (i.e `paley_graph(25)` does not return the true\nPaley graph associated with $5^2$).\n\nParameters\n----------\np : int, an odd prime number.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : graph\n    The constructed directed graph.\n\nRaises\n------\nNetworkXError\n    If the graph is a multigraph.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef paley_graph(p, create_using=None):\n    G = nx.empty_graph(0, create_using, default=nx.DiGraph)\n    if G.is_multigraph():\n        msg = '`create_using` cannot be a multigraph.'\n        raise nx.NetworkXError(msg)\n    square_set = {x ** 2 % p for x in range(1, p) if x ** 2 % p != 0}\n    for x in range(p):\n        for x2 in square_set:\n            G.add_edge(x, (x + x2) % p)\n    G.graph['name'] = f'paley({p})'\n    return G"
 },
 {
  "docstring": "Utility for creating a random regular expander.\n\nReturns a random $d$-regular graph on $n$ nodes which is an expander\ngraph with very good probability.\n\nParameters\n----------\nn : int\n  The number of nodes.\nd : int\n  The degree of each node.\ncreate_using : Graph Instance or Constructor\n  Indicator of type of graph to return.\n  If a Graph-type instance, then clear and use it.\n  If a constructor, call it to create an empty graph.\n  Use the Graph constructor by default.\nmax_tries : int. (default: 100)\n  The number of allowed loops when generating each independent cycle\nseed : (default: None)\n  Seed used to set random number generation state. See :ref`Randomness<randomness>`.\n\n",
  "code": "@nx.utils.decorators.np_random_state('seed')\ndef maybe_regular_expander(n, d, *, create_using=None, max_tries=100, seed=None):\n    import numpy as np\n    if n < 1:\n        raise nx.NetworkXError('n must be a positive integer')\n    if not d >= 2:\n        raise nx.NetworkXError('d must be greater than or equal to 2')\n    if not d % 2 == 0:\n        raise nx.NetworkXError('d must be even')\n    if not n - 1 >= d:\n        raise nx.NetworkXError(f'Need n-1>= d to have room for {d // 2} independent cycles with {n} nodes')\n    G = nx.empty_graph(n, create_using)\n    if n < 2:\n        return G\n    cycles = []\n    edges = set()\n    for i in range(d // 2):\n        iterations = max_tries\n        while len(edges) != (i + 1) * n:\n            iterations -= 1\n            cycle = np.concatenate((seed.permutation(n - 1), [n - 1]))\n            new_edges = {(u, v) for u, v in nx.utils.pairwise(cycle, cyclic=True) if (u, v) not in edges and (v, u) not in edges}\n            if len(new_edges) == n:\n                cycles.append(cycle)\n                edges.update(new_edges)\n            if iterations == 0:\n                raise nx.NetworkXError('Too many iterations in maybe_regular_expander')\n    G.add_edges_from(edges)\n    return G"
 },
 {
  "docstring": "Determines whether the graph G is a regular expander. [1]_\n\nAn expander graph is a sparse graph with strong connectivity properties.\n\nMore precisely, this helper checks whether the graph is a\nregular $(n, d, \\lambda)$-expander with $\\lambda$ close to\nthe Alon-Boppana bound and given by\n$\\lambda = 2 \\sqrt{d - 1} + \\epsilon$. [2]_\n\nIn the case where $\\epsilon = 0 $ then if the graph successfully passes the test\nit is a Ramanujan graph. [3]_\n\nA Ramanujan graph has spectral gap almost as large as possible, which makes them\nexcellent expanders.\n\nParameters\n----------\nG : NetworkX graph\nepsilon : int, float, default=0\n\nReturns\n-------\nbool\n    Whether the given graph is a regular $(n, d, \\lambda)$-expander\n    where $\\lambda = 2 \\sqrt{d - 1} + \\epsilon$.\n\nExamples\n--------\n>>> G = nx.random_regular_expander_graph(20, 4)\n>>> nx.is_regular_expander(G)\nTrue\n\nSee Also\n--------\nmaybe_regular_expander\nrandom_regular_expander_graph\n\n",
  "code": "@nx.utils.not_implemented_for('directed')\n@nx.utils.not_implemented_for('multigraph')\ndef is_regular_expander(G, *, epsilon=0):\n    import numpy as np\n    from scipy.sparse.linalg import eigsh\n    if epsilon < 0:\n        raise nx.NetworkXError('epsilon must be non negative')\n    if not nx.is_regular(G):\n        return False\n    _, d = nx.utils.arbitrary_element(G.degree)\n    A = nx.adjacency_matrix(G)\n    lams = eigsh(A.asfptype(), which='LM', k=2, return_eigenvectors=False)\n    lambda2 = min(lams)\n    return abs(lambda2) < 2 ** np.sqrt(d - 1) + epsilon"
 },
 {
  "docstring": "Returns a random regular expander graph on $n$ nodes with degree $d$.\n\nAn expander graph is a sparse graph with strong connectivity properties. [1]_\n\nMore precisely the returned graph is a $(n, d, \\lambda)$-expander with\n$\\lambda = 2 \\sqrt{d - 1} + \\epsilon$, close to the Alon-Boppana bound. [2]_\n\nIn the case where $\\epsilon = 0 $ it returns a Ramanujan graph.\nA Ramanujan graph has spectral gap almost as large as possible,\nwhich makes them excellent expanders. [3]_\n\nParameters\n----------\nn : int\n  The number of nodes.\nd : int\n  The degree of each node.\nepsilon : int, float, default=0\nmax_tries : int, (default: 100)\n  The number of allowed loops, also used in the maybe_regular_expander utility\n\nRaises\n------\nNetworkXError\n    If max_tries is reached\n\nExamples\n--------\n>>> G = nx.random_regular_expander_graph(20, 4)\n>>> nx.is_regular_expander(G)\nTrue\n\n",
  "code": "def random_regular_expander_graph(n, d, *, epsilon=0, create_using=None, max_tries=100):\n    G = maybe_regular_expander(n, d, create_using=create_using, max_tries=max_tries)\n    iterations = max_tries\n    while not is_regular_expander(G, epsilon=epsilon):\n        iterations -= 1\n        G = maybe_regular_expander(n=n, d=d, create_using=create_using, max_tries=max_tries)\n        if iterations == 0:\n            raise nx.NetworkXError('Too many iterations in random_regular_expander_graph')\n    return G"
 },
 {
  "docstring": "Returns edge list of node pairs within `radius` of each other.\n\nParameters\n----------\nG : networkx graph\n    The graph from which to generate the edge list. The nodes in `G` should\n    have an attribute ``pos`` corresponding to the node position, which is\n    used to compute the distance to other nodes.\nradius : scalar\n    The distance threshold. Edges are included in the edge list if the\n    distance between the two nodes is less than `radius`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position of each\n    node in 2D coordinates. Every node in the Graph must have this attribute.\np : scalar, default=2\n    The `Minkowski distance metric\n    <https://en.wikipedia.org/wiki/Minkowski_distance>`_ used to compute\n    distances. The default value is 2, i.e. Euclidean distance.\n\nReturns\n-------\nedges : list\n    List of edges whose distances are less than `radius`\n\n",
  "code": "@nx._dispatch(node_attrs='pos_name')\ndef geometric_edges(G, radius, p=2, *, pos_name='pos'):\n    for n, pos in G.nodes(data=pos_name):\n        if pos is None:\n            raise nx.NetworkXError(f\"Node {n} (and all nodes) must have a '{pos_name}' attribute.\")\n    return _geometric_edges(G, radius, p, pos_name)"
 },
 {
  "docstring": "Implements `geometric_edges` without input validation. See `geometric_edges`\nfor complete docstring.",
  "code": "def _geometric_edges(G, radius, p, pos_name):\n    nodes_pos = G.nodes(data=pos_name)\n    try:\n        import scipy as sp\n    except ImportError:\n        radius_p = radius ** p\n        edges = [(u, v) for (u, pu), (v, pv) in combinations(nodes_pos, 2) if sum((abs(a - b) ** p for a, b in zip(pu, pv))) <= radius_p]\n        return edges\n    nodes, coords = list(zip(*nodes_pos))\n    kdtree = sp.spatial.cKDTree(coords)\n    edge_indexes = kdtree.query_pairs(radius, p)\n    edges = [(nodes[u], nodes[v]) for u, v in sorted(edge_indexes)]\n    return edges"
 },
 {
  "docstring": "Returns a random geometric graph in the unit cube of dimensions `dim`.\n\nThe random geometric graph model places `n` nodes uniformly at\nrandom in the unit cube. Two nodes are joined by an edge if the\ndistance between the nodes is at most `radius`.\n\nEdges are determined using a KDTree when SciPy is available.\nThis reduces the time complexity from $O(n^2)$ to $O(n)$.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\nradius: float\n    Distance threshold value\ndim : int, optional\n    Dimension of graph\npos : dict, optional\n    A dictionary keyed by node with node positions as values.\np : float, optional\n    Which Minkowski distance metric to use.  `p` has to meet the condition\n    ``1 <= p <= infinity``.\n\n    If this argument is not specified, the :math:`L^2` metric\n    (the Euclidean distance metric), p = 2 is used.\n    This should not be confused with the `p` of an Erd\u0151s-R\u00e9nyi random\n    graph, which represents probability.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A random geometric graph, undirected and without self-loops.\n    Each node has a node attribute ``'pos'`` that stores the\n    position of that node in Euclidean space as provided by the\n    ``pos`` keyword argument or, if ``pos`` was not provided, as\n    generated by this function.\n\nExamples\n--------\nCreate a random geometric graph on twenty nodes where nodes are joined by\nan edge if their distance is at most 0.1::\n\n>>> G = nx.random_geometric_graph(20, 0.1)\n\n",
  "code": "@py_random_state(5)\n@nx._dispatch(graphs=None)\ndef random_geometric_graph(n, radius, dim=2, pos=None, p=2, seed=None, *, pos_name='pos'):\n    G = nx.empty_graph(n)\n    if pos is None:\n        pos = {v: [seed.random() for i in range(dim)] for v in G}\n    nx.set_node_attributes(G, pos, pos_name)\n    G.add_edges_from(_geometric_edges(G, radius, p, pos_name))\n    return G"
 },
 {
  "docstring": "Returns a soft random geometric graph in the unit cube.\n\nThe soft random geometric graph [1] model places `n` nodes uniformly at\nrandom in the unit cube in dimension `dim`. Two nodes of distance, `dist`,\ncomputed by the `p`-Minkowski distance metric are joined by an edge with\nprobability `p_dist` if the computed distance metric value of the nodes\nis at most `radius`, otherwise they are not joined.\n\nEdges within `radius` of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from :math:`O(n^2)`\nto :math:`O(n)`.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\nradius: float\n    Distance threshold value\ndim : int, optional\n    Dimension of graph\npos : dict, optional\n    A dictionary keyed by node with node positions as values.\np : float, optional\n    Which Minkowski distance metric to use.\n    `p` has to meet the condition ``1 <= p <= infinity``.\n\n    If this argument is not specified, the :math:`L^2` metric\n    (the Euclidean distance metric), p = 2 is used.\n\n    This should not be confused with the `p` of an Erd\u0151s-R\u00e9nyi random\n    graph, which represents probability.\np_dist : function, optional\n    A probability density function computing the probability of\n    connecting two nodes that are of distance, dist, computed by the\n    Minkowski distance metric. The probability density function, `p_dist`,\n    must be any function that takes the metric value as input\n    and outputs a single probability value between 0-1. The scipy.stats\n    package has many probability distribution functions implemented and\n    tools for custom probability distribution definitions [2], and passing\n    the .pdf method of scipy.stats distributions can be used here.  If the\n    probability function, `p_dist`, is not supplied, the default function\n    is an exponential distribution with rate parameter :math:`\\lambda=1`.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A soft random geometric graph, undirected and without self-loops.\n    Each node has a node attribute ``'pos'`` that stores the\n    position of that node in Euclidean space as provided by the\n    ``pos`` keyword argument or, if ``pos`` was not provided, as\n    generated by this function.\n\nExamples\n--------\nDefault Graph:\n\nG = nx.soft_random_geometric_graph(50, 0.2)\n\nCustom Graph:\n\nCreate a soft random geometric graph on 100 uniformly distributed nodes\nwhere nodes are joined by an edge with probability computed from an\nexponential distribution with rate parameter :math:`\\lambda=1` if their\nEuclidean distance is at most 0.2.\n\n",
  "code": "@py_random_state(6)\n@nx._dispatch(graphs=None)\ndef soft_random_geometric_graph(n, radius, dim=2, pos=None, p=2, p_dist=None, seed=None, *, pos_name='pos'):\n    G = nx.empty_graph(n)\n    G.name = f'soft_random_geometric_graph({n}, {radius}, {dim})'\n    if pos is None:\n        pos = {v: [seed.random() for i in range(dim)] for v in G}\n    nx.set_node_attributes(G, pos, pos_name)\n    if p_dist is None:\n\n        def p_dist(dist):\n            return math.exp(-dist)\n\n    def should_join(edge):\n        u, v = edge\n        dist = sum((abs(a - b) ** p for a, b in zip(pos[u], pos[v]))) ** (1 / p)\n        return seed.random() < p_dist(dist)\n    G.add_edges_from(filter(should_join, _geometric_edges(G, radius, p, pos_name)))\n    return G"
 },
 {
  "docstring": "Returns a geographical threshold graph.\n\nThe geographical threshold graph model places $n$ nodes uniformly at\nrandom in a rectangular domain.  Each node $u$ is assigned a weight\n$w_u$. Two nodes $u$ and $v$ are joined by an edge if\n\n.. math::\n\n   (w_u + w_v)p_{dist}(r) \\ge \\theta\n\nwhere `r` is the distance between `u` and `v`, `p_dist` is any function of\n`r`, and :math:`\\theta` as the threshold parameter. `p_dist` is used to\ngive weight to the distance between nodes when deciding whether or not\nthey should be connected. The larger `p_dist` is, the more prone nodes\nseparated by `r` are to be connected, and vice versa.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\ntheta: float\n    Threshold value\ndim : int, optional\n    Dimension of graph\npos : dict\n    Node positions as a dictionary of tuples keyed by node.\nweight : dict\n    Node weights as a dictionary of numbers keyed by node.\nmetric : function\n    A metric on vectors of numbers (represented as lists or\n    tuples). This must be a function that accepts two lists (or\n    tuples) as input and yields a number as output. The function\n    must also satisfy the four requirements of a `metric`_.\n    Specifically, if $d$ is the function and $x$, $y$,\n    and $z$ are vectors in the graph, then $d$ must satisfy\n\n    1. $d(x, y) \\ge 0$,\n    2. $d(x, y) = 0$ if and only if $x = y$,\n    3. $d(x, y) = d(y, x)$,\n    4. $d(x, z) \\le d(x, y) + d(y, z)$.\n\n    If this argument is not specified, the Euclidean distance metric is\n    used.\n\n    .. _metric: https://en.wikipedia.org/wiki/Metric_%28mathematics%29\np_dist : function, optional\n    Any function used to give weight to the distance between nodes when\n    deciding whether or not they should be connected. `p_dist` was\n    originally conceived as a probability density function giving the\n    probability of connecting two nodes that are of metric distance `r`\n    apart. The implementation here allows for more arbitrary definitions\n    of `p_dist` that do not need to correspond to valid probability\n    density functions. The :mod:`scipy.stats` package has many\n    probability density functions implemented and tools for custom\n    probability density definitions, and passing the ``.pdf`` method of\n    scipy.stats distributions can be used here. If ``p_dist=None``\n    (the default), the exponential function :math:`r^{-2}` is used.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\nweight_name : string, default=\"weight\"\n    The name of the node attribute which represents the weight\n    of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A random geographic threshold graph, undirected and without\n    self-loops.\n\n    Each node has a node attribute ``pos`` that stores the\n    position of that node in Euclidean space as provided by the\n    ``pos`` keyword argument or, if ``pos`` was not provided, as\n    generated by this function. Similarly, each node has a node\n    attribute ``weight`` that stores the weight of that node as\n    provided or as generated.\n\nExamples\n--------\nSpecify an alternate distance metric using the ``metric`` keyword\nargument. For example, to use the `taxicab metric`_ instead of the\ndefault `Euclidean metric`_::\n\n    >>> dist = lambda x, y: sum(abs(a - b) for a, b in zip(x, y))\n    >>> G = nx.geographical_threshold_graph(10, 0.1, metric=dist)\n\n.. _taxicab metric: https://en.wikipedia.org/wiki/Taxicab_geometry\n.. _Euclidean metric: https://en.wikipedia.org/wiki/Euclidean_distance\n\n",
  "code": "@py_random_state(7)\n@nx._dispatch(graphs=None)\ndef geographical_threshold_graph(n, theta, dim=2, pos=None, weight=None, metric=None, p_dist=None, seed=None, *, pos_name='pos', weight_name='weight'):\n    G = nx.empty_graph(n)\n    if weight is None:\n        weight = {v: seed.expovariate(1) for v in G}\n    if pos is None:\n        pos = {v: [seed.random() for i in range(dim)] for v in G}\n    if metric is None:\n        metric = math.dist\n    nx.set_node_attributes(G, weight, weight_name)\n    nx.set_node_attributes(G, pos, pos_name)\n    if p_dist is None:\n\n        def p_dist(r):\n            return r ** (-2)\n\n    def should_join(pair):\n        u, v = pair\n        u_pos, v_pos = (pos[u], pos[v])\n        u_weight, v_weight = (weight[u], weight[v])\n        return (u_weight + v_weight) * p_dist(metric(u_pos, v_pos)) >= theta\n    G.add_edges_from(filter(should_join, combinations(G, 2)))\n    return G"
 },
 {
  "docstring": "Returns a Waxman random graph.\n\nThe Waxman random graph model places `n` nodes uniformly at random\nin a rectangular domain. Each pair of nodes at distance `d` is\njoined by an edge with probability\n\n.. math::\n        p = \\beta \\exp(-d / \\alpha L).\n\nThis function implements both Waxman models, using the `L` keyword\nargument.\n\n* Waxman-1: if `L` is not specified, it is set to be the maximum distance\n  between any pair of nodes.\n* Waxman-2: if `L` is specified, the distance between a pair of nodes is\n  chosen uniformly at random from the interval `[0, L]`.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\nbeta: float\n    Model parameter\nalpha: float\n    Model parameter\nL : float, optional\n    Maximum distance between nodes.  If not specified, the actual distance\n    is calculated.\ndomain : four-tuple of numbers, optional\n    Domain size, given as a tuple of the form `(x_min, y_min, x_max,\n    y_max)`.\nmetric : function\n    A metric on vectors of numbers (represented as lists or\n    tuples). This must be a function that accepts two lists (or\n    tuples) as input and yields a number as output. The function\n    must also satisfy the four requirements of a `metric`_.\n    Specifically, if $d$ is the function and $x$, $y$,\n    and $z$ are vectors in the graph, then $d$ must satisfy\n\n    1. $d(x, y) \\ge 0$,\n    2. $d(x, y) = 0$ if and only if $x = y$,\n    3. $d(x, y) = d(y, x)$,\n    4. $d(x, z) \\le d(x, y) + d(y, z)$.\n\n    If this argument is not specified, the Euclidean distance metric is\n    used.\n\n    .. _metric: https://en.wikipedia.org/wiki/Metric_%28mathematics%29\n\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A random Waxman graph, undirected and without self-loops. Each\n    node has a node attribute ``'pos'`` that stores the position of\n    that node in Euclidean space as generated by this function.\n\nExamples\n--------\nSpecify an alternate distance metric using the ``metric`` keyword\nargument. For example, to use the \"`taxicab metric`_\" instead of the\ndefault `Euclidean metric`_::\n\n    >>> dist = lambda x, y: sum(abs(a - b) for a, b in zip(x, y))\n    >>> G = nx.waxman_graph(10, 0.5, 0.1, metric=dist)\n\n.. _taxicab metric: https://en.wikipedia.org/wiki/Taxicab_geometry\n.. _Euclidean metric: https://en.wikipedia.org/wiki/Euclidean_distance\n\n",
  "code": "@py_random_state(6)\n@nx._dispatch(graphs=None)\ndef waxman_graph(n, beta=0.4, alpha=0.1, L=None, domain=(0, 0, 1, 1), metric=None, seed=None, *, pos_name='pos'):\n    G = nx.empty_graph(n)\n    xmin, ymin, xmax, ymax = domain\n    pos = {v: (seed.uniform(xmin, xmax), seed.uniform(ymin, ymax)) for v in G}\n    nx.set_node_attributes(G, pos, pos_name)\n    if metric is None:\n        metric = math.dist\n    if L is None:\n        L = max((metric(x, y) for x, y in combinations(pos.values(), 2)))\n\n        def dist(u, v):\n            return metric(pos[u], pos[v])\n    else:\n\n        def dist(u, v):\n            return seed.random() * L\n\n    def should_join(pair):\n        return seed.random() < beta * math.exp(-dist(*pair) / (alpha * L))\n    G.add_edges_from(filter(should_join, combinations(G, 2)))\n    return G"
 },
 {
  "docstring": "Returns a navigable small-world graph.\n\nA navigable small-world graph is a directed grid with additional long-range\nconnections that are chosen randomly.\n\n  [...] we begin with a set of nodes [...] that are identified with the set\n  of lattice points in an $n \\times n$ square,\n  $\\{(i, j): i \\in \\{1, 2, \\ldots, n\\}, j \\in \\{1, 2, \\ldots, n\\}\\}$,\n  and we define the *lattice distance* between two nodes $(i, j)$ and\n  $(k, l)$ to be the number of \"lattice steps\" separating them:\n  $d((i, j), (k, l)) = |k - i| + |l - j|$.\n\n  For a universal constant $p >= 1$, the node $u$ has a directed edge to\n  every other node within lattice distance $p$---these are its *local\n  contacts*. For universal constants $q >= 0$ and $r >= 0$ we also\n  construct directed edges from $u$ to $q$ other nodes (the *long-range\n  contacts*) using independent random trials; the $i$th directed edge from\n  $u$ has endpoint $v$ with probability proportional to $[d(u,v)]^{-r}$.\n\n  -- [1]_\n\nParameters\n----------\nn : int\n    The length of one side of the lattice; the number of nodes in\n    the graph is therefore $n^2$.\np : int\n    The diameter of short range connections. Each node is joined with every\n    other node within this lattice distance.\nq : int\n    The number of long-range connections for each node.\nr : float\n    Exponent for decaying probability of connections.  The probability of\n    connecting to a node at lattice distance $d$ is $1/d^r$.\ndim : int\n    Dimension of grid\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\n",
  "code": "@py_random_state(5)\n@nx._dispatch(graphs=None)\ndef navigable_small_world_graph(n, p=1, q=1, r=2, dim=2, seed=None):\n    if p < 1:\n        raise nx.NetworkXException('p must be >= 1')\n    if q < 0:\n        raise nx.NetworkXException('q must be >= 0')\n    if r < 0:\n        raise nx.NetworkXException('r must be >= 0')\n    G = nx.DiGraph()\n    nodes = list(product(range(n), repeat=dim))\n    for p1 in nodes:\n        probs = [0]\n        for p2 in nodes:\n            if p1 == p2:\n                continue\n            d = sum((abs(b - a) for a, b in zip(p1, p2)))\n            if d <= p:\n                G.add_edge(p1, p2)\n            probs.append(d ** (-r))\n        cdf = list(accumulate(probs))\n        for _ in range(q):\n            target = nodes[bisect_left(cdf, seed.uniform(0, cdf[-1]))]\n            G.add_edge(p1, target)\n    return G"
 },
 {
  "docstring": "Returns a thresholded random geometric graph in the unit cube.\n\nThe thresholded random geometric graph [1] model places `n` nodes\nuniformly at random in the unit cube of dimensions `dim`. Each node\n`u` is assigned a weight :math:`w_u`. Two nodes `u` and `v` are\njoined by an edge if they are within the maximum connection distance,\n`radius` computed by the `p`-Minkowski distance and the summation of\nweights :math:`w_u` + :math:`w_v` is greater than or equal\nto the threshold parameter `theta`.\n\nEdges within `radius` of each other are determined using a KDTree when\nSciPy is available. This reduces the time complexity from :math:`O(n^2)`\nto :math:`O(n)`.\n\nParameters\n----------\nn : int or iterable\n    Number of nodes or iterable of nodes\nradius: float\n    Distance threshold value\ntheta: float\n    Threshold value\ndim : int, optional\n    Dimension of graph\npos : dict, optional\n    A dictionary keyed by node with node positions as values.\nweight : dict, optional\n    Node weights as a dictionary of numbers keyed by node.\np : float, optional (default 2)\n    Which Minkowski distance metric to use.  `p` has to meet the condition\n    ``1 <= p <= infinity``.\n\n    If this argument is not specified, the :math:`L^2` metric\n    (the Euclidean distance metric), p = 2 is used.\n\n    This should not be confused with the `p` of an Erd\u0151s-R\u00e9nyi random\n    graph, which represents probability.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\npos_name : string, default=\"pos\"\n    The name of the node attribute which represents the position\n    in 2D coordinates of the node in the returned graph.\nweight_name : string, default=\"weight\"\n    The name of the node attribute which represents the weight\n    of the node in the returned graph.\n\nReturns\n-------\nGraph\n    A thresholded random geographic graph, undirected and without\n    self-loops.\n\n    Each node has a node attribute ``'pos'`` that stores the\n    position of that node in Euclidean space as provided by the\n    ``pos`` keyword argument or, if ``pos`` was not provided, as\n    generated by this function. Similarly, each node has a nodethre\n    attribute ``'weight'`` that stores the weight of that node as\n    provided or as generated.\n\nExamples\n--------\nDefault Graph:\n\nG = nx.thresholded_random_geometric_graph(50, 0.2, 0.1)\n\nCustom Graph:\n\nCreate a thresholded random geometric graph on 50 uniformly distributed\nnodes where nodes are joined by an edge if their sum weights drawn from\na exponential distribution with rate = 5 are >= theta = 0.1 and their\nEuclidean distance is at most 0.2.\n\n",
  "code": "@py_random_state(7)\n@nx._dispatch(graphs=None)\ndef thresholded_random_geometric_graph(n, radius, theta, dim=2, pos=None, weight=None, p=2, seed=None, *, pos_name='pos', weight_name='weight'):\n    G = nx.empty_graph(n)\n    G.name = f'thresholded_random_geometric_graph({n}, {radius}, {theta}, {dim})'\n    if weight is None:\n        weight = {v: seed.expovariate(1) for v in G}\n    if pos is None:\n        pos = {v: [seed.random() for i in range(dim)] for v in G}\n    nx.set_node_attributes(G, weight, weight_name)\n    nx.set_node_attributes(G, pos, pos_name)\n    edges = ((u, v) for u, v in _geometric_edges(G, radius, p, pos_name) if weight[u] + weight[v] >= theta)\n    G.add_edges_from(edges)\n    return G"
 },
 {
  "docstring": "Returns a random graph from the geometric soft configuration model.\n\nThe $\\mathbb{S}^1$ model [1]_ is the geometric soft configuration model\nwhich is able to explain many fundamental features of real networks such as\nsmall-world property, heteregenous degree distributions, high level of\nclustering, and self-similarity.\n\nIn the geometric soft configuration model, a node $i$ is assigned two hidden\nvariables: a hidden degree $\\kappa_i$, quantifying its popularity, influence,\nor importance, and an angular position $\\theta_i$ in a circle abstracting the\nsimilarity space, where angular distances between nodes are a proxy for their\nsimilarity. Focusing on the angular position, this model is often called\nthe $\\mathbb{S}^1$ model (a one-dimensional sphere). The circle's radius is\nadjusted to $R = N/2\\pi$, where $N$ is the number of nodes, so that the density\nis set to 1 without loss of generality.\n\nThe connection probability between any pair of nodes increases with\nthe product of their hidden degrees (i.e., their combined popularities),\nand decreases with the angular distance between the two nodes.\nSpecifically, nodes $i$ and $j$ are connected with the probability\n\n$p_{ij} = \\frac{1}{1 + \\frac{d_{ij}^\\beta}{\\left(\\mu \\kappa_i \\kappa_j\\right)^{\\max(1, \\beta)}}}$\n\nwhere $d_{ij} = R\\Delta\\theta_{ij}$ is the arc length of the circle between\nnodes $i$ and $j$ separated by an angular distance $\\Delta\\theta_{ij}$.\nParameters $\\mu$ and $\\beta$ (also called inverse temperature) control the\naverage degree and the clustering coefficient, respectively.\n\nIt can be shown [2]_ that the model undergoes a structural phase transition\nat $\\beta=1$ so that for $\\beta<1$ networks are unclustered in the thermodynamic\nlimit (when $N\\to \\infty$) whereas for $\\beta>1$ the ensemble generates\nnetworks with finite clustering coefficient.\n\nThe $\\mathbb{S}^1$ model can be expressed as a purely geometric model\n$\\mathbb{H}^2$ in the hyperbolic plane [3]_ by mapping the hidden degree of\neach node into a radial coordinate as\n\n$r_i = \\hat{R} - \\frac{2 \\max(1, \\beta)}{\\beta \\zeta} \\ln \\left(\\frac{\\kappa_i}{\\kappa_0}\\right)$\n\nwhere $\\hat{R}$ is the radius of the hyperbolic disk and $\\zeta$ is the curvature,\n\n$\\hat{R} = \\frac{2}{\\zeta} \\ln \\left(\\frac{N}{\\pi}\\right)\n- \\frac{2\\max(1, \\beta)}{\\beta \\zeta} \\ln (\\mu \\kappa_0^2)$\n\nThe connection probability then reads\n\n$p_{ij} = \\frac{1}{1 + \\exp\\left({\\frac{\\beta\\zeta}{2} (x_{ij} - \\hat{R})}\\right)}$\n\nwhere\n\n$x_{ij} = r_i + r_j + \\frac{2}{\\zeta} \\ln \\frac{\\Delta\\theta_{ij}}{2}$\n\nis a good approximation of the hyperbolic distance between two nodes separated\nby an angular distance $\\Delta\\theta_{ij}$ with radial coordinates $r_i$ and $r_j$.\nFor $\\beta > 1$, the curvature $\\zeta = 1$, for $\\beta < 1$, $\\zeta = \\beta^{-1}$.\n\n\nParameters\n----------\nEither `n`, `gamma`, `mean_degree` are provided or `kappas`. The values of\n`n`, `gamma`, `mean_degree` (if provided) are used to construct a random\nkappa-dict keyed by node with values sampled from a power-law distribution.\n\nbeta : positive number\n    Inverse temperature, controlling the clustering coefficient.\nn : int (default: None)\n    Size of the network (number of nodes).\n    If not provided, `kappas` must be provided and holds the nodes.\ngamma : float (default: None)\n    Exponent of the power-law distribution for hidden degrees `kappas`.\n    If not provided, `kappas` must be provided directly.\nmean_degree : float (default: None)\n    The mean degree in the network.\n    If not provided, `kappas` must be provided directly.\nkappas : dict (default: None)\n    A dict keyed by node to its hidden degree value.\n    If not provided, random values are computed based on a power-law\n    distribution using `n`, `gamma` and `mean_degree`.\nseed : int, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nGraph\n    A random geometric soft configuration graph (undirected with no self-loops).\n    Each node has three node-attributes:\n\n    - ``kappa`` that represents the hidden degree.\n\n    - ``theta`` the position in the similarity space ($\\mathbb{S}^1$) which is\n      also the angular position in the hyperbolic plane.\n\n    - ``radius`` the radial position in the hyperbolic plane\n      (based on the hidden degree).\n\n\nExamples\n--------\nGenerate a network with specified parameters:\n\n>>> G = nx.geometric_soft_configuration_graph(beta=1.5, n=100, gamma=2.7, mean_degree=5)\n\nCreate a geometric soft configuration graph with 100 nodes. The $\\beta$ parameter\nis set to 1.5 and the exponent of the powerlaw distribution of the hidden\ndegrees is 2.7 with mean value of 5.\n\nGenerate a network with predefined hidden degrees:\n\n>>> kappas = {i: 10 for i in range(100)}\n>>> G = nx.geometric_soft_configuration_graph(beta=2.5, kappas=kappas)\n\nCreate a geometric soft configuration graph with 100 nodes. The $\\beta$ parameter\nis set to 2.5 and all nodes with hidden degree $\\kappa=10$.\n\n\n",
  "code": "@py_random_state(5)\n@nx._dispatch(graphs=None)\ndef geometric_soft_configuration_graph(*, beta, n=None, gamma=None, mean_degree=None, kappas=None, seed=None):\n    if beta <= 0:\n        raise nx.NetworkXError('The parameter beta cannot be smaller or equal to 0.')\n    if kappas is not None:\n        if not all((n is None, gamma is None, mean_degree is None)):\n            raise nx.NetworkXError('When kappas is input, n, gamma and mean_degree must not be.')\n        n = len(kappas)\n        mean_degree = sum(kappas) / len(kappas)\n    else:\n        if any((n is None, gamma is None, mean_degree is None)):\n            raise nx.NetworkXError('Please provide either kappas, or all 3 of: n, gamma and mean_degree.')\n        gam_ratio = (gamma - 2) / (gamma - 1)\n        kappa_0 = mean_degree * gam_ratio * (1 - 1 / n) / (1 - 1 / n ** gam_ratio)\n        base = 1 - 1 / n\n        power = 1 / (1 - gamma)\n        kappas = {i: kappa_0 * (1 - seed.random() * base) ** power for i in range(n)}\n    G = nx.Graph()\n    R = n / (2 * math.pi)\n    if beta > 1:\n        mu = beta * math.sin(math.pi / beta) / (2 * math.pi * mean_degree)\n    elif beta == 1:\n        mu = 1 / (2 * mean_degree * math.log(n))\n    else:\n        mu = (1 - beta) / (2 ** beta * mean_degree * n ** (1 - beta))\n    thetas = {k: seed.uniform(0, 2 * math.pi) for k in kappas}\n    for u in kappas:\n        for v in list(G):\n            angle = math.pi - math.fabs(math.pi - math.fabs(thetas[u] - thetas[v]))\n            dij = math.pow(R * angle, beta)\n            mu_kappas = math.pow(mu * kappas[u] * kappas[v], max(1, beta))\n            p_ij = 1 / (1 + dij / mu_kappas)\n            if seed.random() < p_ij:\n                G.add_edge(u, v)\n        G.add_node(u)\n    nx.set_node_attributes(G, thetas, 'theta')\n    nx.set_node_attributes(G, kappas, 'kappa')\n    zeta = 1 if beta > 1 else 1 / beta\n    kappa_min = min(kappas.values())\n    R_c = 2 * max(1, beta) / (beta * zeta)\n    R_hat = 2 / zeta * math.log(n / math.pi) - R_c * math.log(mu * kappa_min)\n    radii = {node: R_hat - R_c * math.log(kappa) for node, kappa in kappas.items()}\n    nx.set_node_attributes(G, radii, 'radius')\n    return G"
 },
 {
  "docstring": "Returns the Harary graph with given numbers of nodes and edges.\n\nThe Harary graph $H_{n,m}$ is the graph that maximizes node connectivity\nwith $n$ nodes and $m$ edges.\n\nThis maximum node connectivity is known to be floor($2m/n$). [1]_\n\nParameters\n----------\nn: integer\n   The number of nodes the generated graph is to contain\n\nm: integer\n   The number of edges the generated graph is to contain\n\ncreate_using : NetworkX graph constructor, optional Graph type\n to create (default=nx.Graph). If graph instance, then cleared\n before populated.\n\nReturns\n-------\nNetworkX graph\n    The Harary graph $H_{n,m}$.\n\nSee Also\n--------\nhkn_harary_graph\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef hnm_harary_graph(n, m, create_using=None):\n    if n < 1:\n        raise NetworkXError('The number of nodes must be >= 1!')\n    if m < n - 1:\n        raise NetworkXError('The number of edges must be >= n - 1 !')\n    if m > n * (n - 1) // 2:\n        raise NetworkXError('The number of edges must be <= n(n-1)/2')\n    H = nx.empty_graph(n, create_using)\n    d = 2 * m // n\n    if n % 2 == 0 or d % 2 == 0:\n        offset = d // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if d & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n        r = 2 * m % n\n        if r > 0:\n            for i in range(r // 2):\n                H.add_edge(i, i + offset + 1)\n    else:\n        offset = (d - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(m - n * offset):\n            H.add_edge(i, (i + half) % n)\n    return H"
 },
 {
  "docstring": "Returns the Harary graph with given node connectivity and node number.\n\nThe Harary graph $H_{k,n}$ is the graph that minimizes the number of\nedges needed with given node connectivity $k$ and node number $n$.\n\nThis smallest number of edges is known to be ceil($kn/2$) [1]_.\n\nParameters\n----------\nk: integer\n   The node connectivity of the generated graph\n\nn: integer\n   The number of nodes the generated graph is to contain\n\ncreate_using : NetworkX graph constructor, optional Graph type\n to create (default=nx.Graph). If graph instance, then cleared\n before populated.\n\nReturns\n-------\nNetworkX graph\n    The Harary graph $H_{k,n}$.\n\nSee Also\n--------\nhnm_harary_graph\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef hkn_harary_graph(k, n, create_using=None):\n    if k < 1:\n        raise NetworkXError('The node connectivity must be >= 1!')\n    if n < k + 1:\n        raise NetworkXError('The number of nodes must be >= k+1 !')\n    if k == 1:\n        H = nx.path_graph(n, create_using)\n        return H\n    H = nx.empty_graph(n, create_using)\n    if k % 2 == 0 or n % 2 == 0:\n        offset = k // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        if k & 1:\n            half = n // 2\n            for i in range(half):\n                H.add_edge(i, i + half)\n    else:\n        offset = (k - 1) // 2\n        for i in range(n):\n            for j in range(1, offset + 1):\n                H.add_edge(i, (i - j) % n)\n                H.add_edge(i, (i + j) % n)\n        half = n // 2\n        for i in range(half + 1):\n            H.add_edge(i, (i + half) % n)\n    return H"
 },
 {
  "docstring": "Pick a random integer with uniform probability.\n\nReturns a random integer uniformly taken from a distribution with\nminimum value 'a' and average value 'm', X~U(a,b), E[X]=m, X in N where\nb = 2*m - a.\n\n",
  "code": "def uniform_int_from_avg(a, m, seed):\n    from math import floor\n    assert m >= a\n    b = 2 * m - a\n    p = (b - floor(b)) / 2\n    X1 = round(seed.random() * (floor(b) - a) + a)\n    if seed.random() < p:\n        X2 = 1\n    else:\n        X2 = 0\n    return X1 + X2"
 },
 {
  "docstring": "Pick a random value, with a probability given by its weight.\n\nReturns a random choice among degs keys, each of which has a\nprobability proportional to the corresponding dictionary value.\n\nParameters\n----------\ndegs: dictionary\n    It contains the possible values (keys) and the corresponding\n    probabilities (values)\nseed: random state\n\nReturns\n-------\nv: object\n    A key of degs or None if degs is empty",
  "code": "def choose_pref_attach(degs, seed):\n    if len(degs) == 0:\n        return None\n    s = sum(degs.values())\n    if s == 0:\n        return seed.choice(list(degs.keys()))\n    v = seed.random() * s\n    nodes = list(degs.keys())\n    i = 0\n    acc = degs[nodes[i]]\n    while v > acc:\n        i += 1\n        acc += degs[nodes[i]]\n    return nodes[i]"
 },
 {
  "docstring": "Generates a random undirected graph resembling the Internet AS network\n\nParameters\n----------\nn: integer in [1000, 10000]\n    Number of graph nodes\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG: Networkx Graph object\n    A randomly generated undirected graph\n\n",
  "code": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_internet_as_graph(n, seed=None):\n    GG = AS_graph_generator(n, seed)\n    G = GG.generate()\n    return G"
 },
 {
  "docstring": "Initializes variables. Immediate numbers are taken from [1].\n\nParameters\n----------\nn: integer\n    Number of graph nodes\nseed: random state\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nGG: AS_graph_generator object\n\n",
  "code": "def __init__(self, n, seed):\n    self.seed = seed\n    self.n_t = min(n, round(self.seed.random() * 2 + 4))\n    self.n_m = round(0.15 * n)\n    self.n_cp = round(0.05 * n)\n    self.n_c = max(0, n - self.n_t - self.n_m - self.n_cp)\n    self.d_m = 2 + 2.5 * n / 10000\n    self.d_cp = 2 + 1.5 * n / 10000\n    self.d_c = 1 + 5 * n / 100000\n    self.p_m_m = 1 + 2 * n / 10000\n    self.p_cp_m = 0.2 + 2 * n / 10000\n    self.p_cp_cp = 0.05 + 2 * n / 100000\n    self.t_m = 0.375\n    self.t_cp = 0.375\n    self.t_c = 0.125"
 },
 {
  "docstring": "Generates the core mesh network of tier one nodes of a AS graph.\n\nReturns\n-------\nG: Networkx Graph\n    Core network",
  "code": "def t_graph(self):\n    self.G = nx.Graph()\n    for i in range(self.n_t):\n        self.G.add_node(i, type='T')\n        for r in self.regions:\n            self.regions[r].add(i)\n        for j in self.G.nodes():\n            if i != j:\n                self.add_edge(i, j, 'peer')\n        self.customers[i] = set()\n        self.providers[i] = set()\n    return self.G"
 },
 {
  "docstring": "Pick a node with a probability weighted by its peer degree.\n\nPick a node from node_list with preferential attachment\ncomputed only on their peer degree",
  "code": "def choose_peer_pref_attach(self, node_list):\n    d = {}\n    for n in node_list:\n        d[n] = self.G.nodes[n]['peers']\n    return choose_pref_attach(d, self.seed)"
 },
 {
  "docstring": "Pick a node with a probability weighted by its degree.\n\nPick a node from node_list with preferential attachment\ncomputed on their degree",
  "code": "def choose_node_pref_attach(self, node_list):\n    degs = dict(self.G.degree(node_list))\n    return choose_pref_attach(degs, self.seed)"
 },
 {
  "docstring": "Keep the dictionaries 'customers' and 'providers' consistent.",
  "code": "def add_customer(self, i, j):\n    self.customers[j].add(i)\n    self.providers[i].add(j)\n    for z in self.providers[j]:\n        self.customers[z].add(i)\n        self.providers[i].add(z)"
 },
 {
  "docstring": "Add a node and its customer transit edges to the graph.\n\nParameters\n----------\ni: object\n    Identifier of the new node\nkind: string\n    Type of the new node. Options are: 'M' for middle node, 'CP' for\n    content provider and 'C' for customer.\nreg2prob: float\n    Probability the new node can be in two different regions.\navg_deg: float\n    Average number of transit nodes of which node i is customer.\nt_edge_prob: float\n    Probability node i establish a customer transit edge with a tier\n    one (T) node\n\nReturns\n-------\ni: object\n    Identifier of the new node",
  "code": "def add_node(self, i, kind, reg2prob, avg_deg, t_edge_prob):\n    regs = 1\n    if self.seed.random() < reg2prob:\n        regs = 2\n    node_options = set()\n    self.G.add_node(i, type=kind, peers=0)\n    self.customers[i] = set()\n    self.providers[i] = set()\n    self.nodes[kind].add(i)\n    for r in self.seed.sample(list(self.regions), regs):\n        node_options = node_options.union(self.regions[r])\n        self.regions[r].add(i)\n    edge_num = uniform_int_from_avg(1, avg_deg, self.seed)\n    t_options = node_options.intersection(self.nodes['T'])\n    m_options = node_options.intersection(self.nodes['M'])\n    if i in m_options:\n        m_options.remove(i)\n    d = 0\n    while d < edge_num and (len(t_options) > 0 or len(m_options) > 0):\n        if len(m_options) == 0 or (len(t_options) > 0 and self.seed.random() < t_edge_prob):\n            j = self.choose_node_pref_attach(t_options)\n            t_options.remove(j)\n        else:\n            j = self.choose_node_pref_attach(m_options)\n            m_options.remove(j)\n        self.add_edge(i, j, 'transit')\n        self.add_customer(i, j)\n        d += 1\n    return i"
 },
 {
  "docstring": "Add a peering link between two middle tier (M) nodes.\n\nTarget node j is drawn considering a preferential attachment based on\nother M node peering degree.\n\nParameters\n----------\nm: object\n    Node identifier\nto_kind: string\n    type for target node j (must be always M)\n\nReturns\n-------\nsuccess: boolean",
  "code": "def add_m_peering_link(self, m, to_kind):\n    node_options = self.nodes['M'].difference(self.customers[m])\n    node_options = node_options.difference(self.providers[m])\n    if m in node_options:\n        node_options.remove(m)\n    for j in self.G.neighbors(m):\n        if j in node_options:\n            node_options.remove(j)\n    if len(node_options) > 0:\n        j = self.choose_peer_pref_attach(node_options)\n        self.add_edge(m, j, 'peer')\n        self.G.nodes[m]['peers'] += 1\n        self.G.nodes[j]['peers'] += 1\n        return True\n    else:\n        return False"
 },
 {
  "docstring": "Add a peering link to a content provider (CP) node.\n\nTarget node j can be CP or M and it is drawn uniformly among the nodes\nbelonging to the same region as cp.\n\nParameters\n----------\ncp: object\n    Node identifier\nto_kind: string\n    type for target node j (must be M or CP)\n\nReturns\n-------\nsuccess: boolean",
  "code": "def add_cp_peering_link(self, cp, to_kind):\n    node_options = set()\n    for r in self.regions:\n        if cp in self.regions[r]:\n            node_options = node_options.union(self.regions[r])\n    node_options = self.nodes[to_kind].intersection(node_options)\n    if cp in node_options:\n        node_options.remove(cp)\n    node_options = node_options.difference(self.providers[cp])\n    for j in self.G.neighbors(cp):\n        if j in node_options:\n            node_options.remove(j)\n    if len(node_options) > 0:\n        j = self.seed.sample(list(node_options), 1)[0]\n        self.add_edge(cp, j, 'peer')\n        self.G.nodes[cp]['peers'] += 1\n        self.G.nodes[j]['peers'] += 1\n        return True\n    else:\n        return False"
 },
 {
  "docstring": "Initializes AS network regions.\n\nParameters\n----------\nrn: integer\n    Number of regions",
  "code": "def graph_regions(self, rn):\n    self.regions = {}\n    for i in range(rn):\n        self.regions['REG' + str(i)] = set()"
 },
 {
  "docstring": "Utility function to add peering links among node groups.",
  "code": "def add_peering_links(self, from_kind, to_kind):\n    peer_link_method = None\n    if from_kind == 'M':\n        peer_link_method = self.add_m_peering_link\n        m = self.p_m_m\n    if from_kind == 'CP':\n        peer_link_method = self.add_cp_peering_link\n        if to_kind == 'M':\n            m = self.p_cp_m\n        else:\n            m = self.p_cp_cp\n    for i in self.nodes[from_kind]:\n        num = uniform_int_from_avg(0, m, self.seed)\n        for _ in range(num):\n            peer_link_method(i, to_kind)"
 },
 {
  "docstring": "Generates a random AS network graph as described in [1].\n\nReturns\n-------\nG: Graph object\n\n",
  "code": "def generate(self):\n    self.graph_regions(5)\n    self.customers = {}\n    self.providers = {}\n    self.nodes = {'T': set(), 'M': set(), 'CP': set(), 'C': set()}\n    self.t_graph()\n    self.nodes['T'] = set(self.G.nodes())\n    i = len(self.nodes['T'])\n    for _ in range(self.n_m):\n        self.nodes['M'].add(self.add_node(i, 'M', 0.2, self.d_m, self.t_m))\n        i += 1\n    for _ in range(self.n_cp):\n        self.nodes['CP'].add(self.add_node(i, 'CP', 0.05, self.d_cp, self.t_cp))\n        i += 1\n    for _ in range(self.n_c):\n        self.nodes['C'].add(self.add_node(i, 'C', 0, self.d_c, self.t_c))\n        i += 1\n    self.add_peering_links('M', 'M')\n    self.add_peering_links('CP', 'M')\n    self.add_peering_links('CP', 'CP')\n    return self.G"
 },
 {
  "docstring": "Returns a uniform random intersection graph.\n\nParameters\n----------\nn : int\n    The number of nodes in the first bipartite set (nodes)\nm : int\n    The number of nodes in the second bipartite set (attributes)\np : float\n    Probability of connecting nodes between bipartite sets\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\ngnp_random_graph\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef uniform_random_intersection_graph(n, m, p, seed=None):\n    from networkx.algorithms import bipartite\n    G = bipartite.random_graph(n, m, p, seed)\n    return nx.projected_graph(G, range(n))"
 },
 {
  "docstring": "Returns a intersection graph with randomly chosen attribute sets for\neach node that are of equal size (k).\n\nParameters\n----------\nn : int\n    The number of nodes in the first bipartite set (nodes)\nm : int\n    The number of nodes in the second bipartite set (attributes)\nk : float\n    Size of attribute set to assign to each node.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\ngnp_random_graph, uniform_random_intersection_graph\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef k_random_intersection_graph(n, m, k, seed=None):\n    G = nx.empty_graph(n + m)\n    mset = range(n, n + m)\n    for v in range(n):\n        targets = seed.sample(mset, k)\n        G.add_edges_from(zip([v] * len(targets), targets))\n    return nx.projected_graph(G, range(n))"
 },
 {
  "docstring": "Returns a random intersection graph with independent probabilities\nfor connections between node and attribute sets.\n\nParameters\n----------\nn : int\n    The number of nodes in the first bipartite set (nodes)\nm : int\n    The number of nodes in the second bipartite set (attributes)\np : list of floats of length m\n    Probabilities for connecting nodes to each attribute\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\ngnp_random_graph, uniform_random_intersection_graph\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef general_random_intersection_graph(n, m, p, seed=None):\n    if len(p) != m:\n        raise ValueError('Probability list p must have m elements.')\n    G = nx.empty_graph(n + m)\n    mset = range(n, n + m)\n    for u in range(n):\n        for v, q in zip(mset, p):\n            if seed.random() < q:\n                G.add_edge(u, v)\n    return nx.projected_graph(G, range(n))"
 },
 {
  "docstring": "Generates an interval graph for a list of intervals given.\n\nIn graph theory, an interval graph is an undirected graph formed from a set\nof closed intervals on the real line, with a vertex for each interval\nand an edge between vertices whose intervals intersect.\nIt is the intersection graph of the intervals.\n\nMore information can be found at:\nhttps://en.wikipedia.org/wiki/Interval_graph\n\nParameters\n----------\nintervals : a sequence of intervals, say (l, r) where l is the left end,\nand r is the right end of the closed interval.\n\nReturns\n-------\nG : networkx graph\n\nExamples\n--------\n>>> intervals = [(-2, 3), [1, 4], (2, 3), (4, 6)]\n>>> G = nx.interval_graph(intervals)\n>>> sorted(G.edges)\n[((-2, 3), (1, 4)), ((-2, 3), (2, 3)), ((1, 4), (2, 3)), ((1, 4), (4, 6))]\n\nRaises\n------\n:exc:`TypeError`\n    if `intervals` contains None or an element which is not\n    collections.abc.Sequence or not a length of 2.\n:exc:`ValueError`\n    if `intervals` contains an interval such that min1 > max1\n    where min1,max1 = interval",
  "code": "@nx._dispatch(graphs=None)\ndef interval_graph(intervals):\n    intervals = list(intervals)\n    for interval in intervals:\n        if not (isinstance(interval, Sequence) and len(interval) == 2):\n            raise TypeError('Each interval must have length 2, and be a collections.abc.Sequence such as tuple or list.')\n        if interval[0] > interval[1]:\n            raise ValueError(f'Interval must have lower value first. Got {interval}')\n    graph = nx.Graph()\n    tupled_intervals = [tuple(interval) for interval in intervals]\n    graph.add_nodes_from(tupled_intervals)\n    while tupled_intervals:\n        min1, max1 = interval1 = tupled_intervals.pop()\n        for interval2 in tupled_intervals:\n            min2, max2 = interval2\n            if max1 >= min2 and max2 >= min1:\n                graph.add_edge(interval1, interval2)\n    return graph"
 },
 {
  "docstring": "Checks whether the given joint degree dictionary is realizable.\n\nA *joint degree dictionary* is a dictionary of dictionaries, in\nwhich entry ``joint_degrees[k][l]`` is an integer representing the\nnumber of edges joining nodes of degree *k* with nodes of degree\n*l*. Such a dictionary is realizable as a simple graph if and only\nif the following conditions are satisfied.\n\n- each entry must be an integer,\n- the total number of nodes of degree *k*, computed by\n  ``sum(joint_degrees[k].values()) / k``, must be an integer,\n- the total number of edges joining nodes of degree *k* with\n  nodes of degree *l* cannot exceed the total number of possible edges,\n- each diagonal entry ``joint_degrees[k][k]`` must be even (this is\n  a convention assumed by the :func:`joint_degree_graph` function).\n\n\nParameters\n----------\njoint_degrees :  dictionary of dictionary of integers\n    A joint degree dictionary in which entry ``joint_degrees[k][l]``\n    is the number of edges joining nodes of degree *k* with nodes of\n    degree *l*.\n\nReturns\n-------\nbool\n    Whether the given joint degree dictionary is realizable as a\n    simple graph.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef is_valid_joint_degree(joint_degrees):\n    degree_count = {}\n    for k in joint_degrees:\n        if k > 0:\n            k_size = sum(joint_degrees[k].values()) / k\n            if not k_size.is_integer():\n                return False\n            degree_count[k] = k_size\n    for k in joint_degrees:\n        for l in joint_degrees[k]:\n            if not float(joint_degrees[k][l]).is_integer():\n                return False\n            if k != l and joint_degrees[k][l] > degree_count[k] * degree_count[l]:\n                return False\n            elif k == l:\n                if joint_degrees[k][k] > degree_count[k] * (degree_count[k] - 1):\n                    return False\n                if joint_degrees[k][k] % 2 != 0:\n                    return False\n    return True"
 },
 {
  "docstring": "Releases one free stub for ``w``, while preserving joint degree in G.\n\nParameters\n----------\nG : NetworkX graph\n    Graph in which the neighbor switch will take place.\nw : integer\n    Node id for which we will execute this neighbor switch.\nunsat : set of integers\n    Set of unsaturated node ids that have the same degree as w.\nh_node_residual: dictionary of integers\n    Keeps track of the remaining stubs  for a given node.\navoid_node_id: integer\n    Node id to avoid when selecting w_prime.\n\n",
  "code": "def _neighbor_switch(G, w, unsat, h_node_residual, avoid_node_id=None):\n    if avoid_node_id is None or h_node_residual[avoid_node_id] > 1:\n        w_prime = next(iter(unsat))\n    else:\n        iter_var = iter(unsat)\n        while True:\n            w_prime = next(iter_var)\n            if w_prime != avoid_node_id:\n                break\n    w_prime_neighbs = G[w_prime]\n    for v in G[w]:\n        if v not in w_prime_neighbs and v != w_prime:\n            switch_node = v\n            break\n    G.remove_edge(w, switch_node)\n    G.add_edge(w_prime, switch_node)\n    h_node_residual[w] += 1\n    h_node_residual[w_prime] -= 1\n    if h_node_residual[w_prime] == 0:\n        unsat.remove(w_prime)"
 },
 {
  "docstring": "Generates a random simple graph with the given joint degree dictionary.\n\nParameters\n----------\njoint_degrees :  dictionary of dictionary of integers\n    A joint degree dictionary in which entry ``joint_degrees[k][l]`` is the\n    number of edges joining nodes of degree *k* with nodes of degree *l*.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : Graph\n    A graph with the specified joint degree dictionary.\n\nRaises\n------\nNetworkXError\n    If *joint_degrees* dictionary is not realizable.\n\n",
  "code": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef joint_degree_graph(joint_degrees, seed=None):\n    if not is_valid_joint_degree(joint_degrees):\n        msg = 'Input joint degree dict not realizable as a simple graph'\n        raise nx.NetworkXError(msg)\n    degree_count = {k: sum(l.values()) // k for k, l in joint_degrees.items() if k > 0}\n    N = sum(degree_count.values())\n    G = nx.empty_graph(N)\n    h_degree_nodelist = {}\n    h_node_residual = {}\n    nodeid = 0\n    for degree, num_nodes in degree_count.items():\n        h_degree_nodelist[degree] = range(nodeid, nodeid + num_nodes)\n        for v in h_degree_nodelist[degree]:\n            h_node_residual[v] = degree\n        nodeid += int(num_nodes)\n    for k in joint_degrees:\n        for l in joint_degrees[k]:\n            n_edges_add = joint_degrees[k][l]\n            if n_edges_add > 0 and k >= l:\n                k_size = degree_count[k]\n                l_size = degree_count[l]\n                k_nodes = h_degree_nodelist[k]\n                l_nodes = h_degree_nodelist[l]\n                k_unsat = {v for v in k_nodes if h_node_residual[v] > 0}\n                if k != l:\n                    l_unsat = {w for w in l_nodes if h_node_residual[w] > 0}\n                else:\n                    l_unsat = k_unsat\n                    n_edges_add = joint_degrees[k][l] // 2\n                while n_edges_add > 0:\n                    v = k_nodes[seed.randrange(k_size)]\n                    w = l_nodes[seed.randrange(l_size)]\n                    if not G.has_edge(v, w) and v != w:\n                        if h_node_residual[v] == 0:\n                            _neighbor_switch(G, v, k_unsat, h_node_residual)\n                        if h_node_residual[w] == 0:\n                            if k != l:\n                                _neighbor_switch(G, w, l_unsat, h_node_residual)\n                            else:\n                                _neighbor_switch(G, w, l_unsat, h_node_residual, avoid_node_id=v)\n                        G.add_edge(v, w)\n                        h_node_residual[v] -= 1\n                        h_node_residual[w] -= 1\n                        n_edges_add -= 1\n                        if h_node_residual[v] == 0:\n                            k_unsat.discard(v)\n                        if h_node_residual[w] == 0:\n                            l_unsat.discard(w)\n    return G"
 },
 {
  "docstring": "Checks whether the given directed joint degree input is realizable\n\nParameters\n----------\nin_degrees :  list of integers\n    in degree sequence contains the in degrees of nodes.\nout_degrees : list of integers\n    out degree sequence contains the out degrees of nodes.\nnkk  :  dictionary of dictionary of integers\n    directed joint degree dictionary. for nodes of out degree k (first\n    level of dict) and nodes of in degree l (second level of dict)\n    describes the number of edges.\n\nReturns\n-------\nboolean\n    returns true if given input is realizable, else returns false.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef is_valid_directed_joint_degree(in_degrees, out_degrees, nkk):\n    V = {}\n    forbidden = {}\n    if len(in_degrees) != len(out_degrees):\n        return False\n    for idx in range(len(in_degrees)):\n        i = in_degrees[idx]\n        o = out_degrees[idx]\n        V[i, 0] = V.get((i, 0), 0) + 1\n        V[o, 1] = V.get((o, 1), 0) + 1\n        forbidden[o, i] = forbidden.get((o, i), 0) + 1\n    S = {}\n    for k in nkk:\n        for l in nkk[k]:\n            val = nkk[k][l]\n            if not float(val).is_integer():\n                return False\n            if val > 0:\n                S[k, 1] = S.get((k, 1), 0) + val\n                S[l, 0] = S.get((l, 0), 0) + val\n                if val + forbidden.get((k, l), 0) > V[k, 1] * V[l, 0]:\n                    return False\n    return all((S[s] / s[0] == V[s] for s in S))"
 },
 {
  "docstring": "Releases one free stub for node w, while preserving joint degree in G.\n\nParameters\n----------\nG : networkx directed graph\n    graph within which the edge swap will take place.\nw : integer\n    node id for which we need to perform a neighbor switch.\nunsat: set of integers\n    set of node ids that have the same degree as w and are unsaturated.\nh_node_residual_out: dict of integers\n    for a given node, keeps track of the remaining stubs to be added.\nchords: set of tuples\n    keeps track of available positions to add edges.\nh_partition_in: dict of integers\n    for a given node, keeps track of its partition id (in degree).\npartition: integer\n    partition id to check if chords have to be updated.\n\n",
  "code": "def _directed_neighbor_switch(G, w, unsat, h_node_residual_out, chords, h_partition_in, partition):\n    w_prime = unsat.pop()\n    unsat.add(w_prime)\n    w_neighbs = list(G.successors(w))\n    w_prime_neighbs = list(G.successors(w_prime))\n    for v in w_neighbs:\n        if v not in w_prime_neighbs and w_prime != v:\n            G.remove_edge(w, v)\n            G.add_edge(w_prime, v)\n            if h_partition_in[v] == partition:\n                chords.add((w, v))\n                chords.discard((w_prime, v))\n            h_node_residual_out[w] += 1\n            h_node_residual_out[w_prime] -= 1\n            if h_node_residual_out[w_prime] == 0:\n                unsat.remove(w_prime)\n            return None\n    return w_prime"
 },
 {
  "docstring": "The reverse of directed_neighbor_switch.\n\nParameters\n----------\nG : networkx directed graph\n    graph within which the edge swap will take place.\nw : integer\n    node id for which we need to perform a neighbor switch.\nunsat: set of integers\n    set of node ids that have the same degree as w and are unsaturated.\nh_node_residual_in: dict of integers\n    for a given node, keeps track of the remaining stubs to be added.\nchords: set of tuples\n    keeps track of available positions to add edges.\nh_partition_out: dict of integers\n    for a given node, keeps track of its partition id (out degree).\npartition: integer\n    partition id to check if chords have to be updated.\n\n",
  "code": "def _directed_neighbor_switch_rev(G, w, unsat, h_node_residual_in, chords, h_partition_out, partition):\n    w_prime = unsat.pop()\n    unsat.add(w_prime)\n    w_neighbs = list(G.predecessors(w))\n    w_prime_neighbs = list(G.predecessors(w_prime))\n    for v in w_neighbs:\n        if v not in w_prime_neighbs and w_prime != v:\n            G.remove_edge(v, w)\n            G.add_edge(v, w_prime)\n            if h_partition_out[v] == partition:\n                chords.add((v, w))\n                chords.discard((v, w_prime))\n            h_node_residual_in[w] += 1\n            h_node_residual_in[w_prime] -= 1\n            if h_node_residual_in[w_prime] == 0:\n                unsat.remove(w_prime)\n            return None\n    return w_prime"
 },
 {
  "docstring": "Generates a random simple directed graph with the joint degree.\n\nParameters\n----------\ndegree_seq :  list of tuples (of size 3)\n    degree sequence contains tuples of nodes with node id, in degree and\n    out degree.\nnkk  :  dictionary of dictionary of integers\n    directed joint degree dictionary, for nodes of out degree k (first\n    level of dict) and nodes of in degree l (second level of dict)\n    describes the number of edges.\nseed : hashable object, optional\n    Seed for random number generator.\n\nReturns\n-------\nG : Graph\n    A directed graph with the specified inputs.\n\nRaises\n------\nNetworkXError\n    If degree_seq and nkk are not realizable as a simple directed graph.\n\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef directed_joint_degree_graph(in_degrees, out_degrees, nkk, seed=None):\n    if not is_valid_directed_joint_degree(in_degrees, out_degrees, nkk):\n        msg = 'Input is not realizable as a simple graph'\n        raise nx.NetworkXError(msg)\n    G = nx.DiGraph()\n    h_degree_nodelist_in = {}\n    h_degree_nodelist_out = {}\n    h_degree_nodelist_in_unsat = {}\n    h_degree_nodelist_out_unsat = {}\n    h_node_residual_out = {}\n    h_node_residual_in = {}\n    h_partition_out = {}\n    h_partition_in = {}\n    non_chords = {}\n    for idx, i in enumerate(in_degrees):\n        idx = int(idx)\n        if i > 0:\n            h_degree_nodelist_in.setdefault(i, [])\n            h_degree_nodelist_in_unsat.setdefault(i, set())\n            h_degree_nodelist_in[i].append(idx)\n            h_degree_nodelist_in_unsat[i].add(idx)\n            h_node_residual_in[idx] = i\n            h_partition_in[idx] = i\n    for idx, o in enumerate(out_degrees):\n        o = out_degrees[idx]\n        non_chords[o, in_degrees[idx]] = non_chords.get((o, in_degrees[idx]), 0) + 1\n        idx = int(idx)\n        if o > 0:\n            h_degree_nodelist_out.setdefault(o, [])\n            h_degree_nodelist_out_unsat.setdefault(o, set())\n            h_degree_nodelist_out[o].append(idx)\n            h_degree_nodelist_out_unsat[o].add(idx)\n            h_node_residual_out[idx] = o\n            h_partition_out[idx] = o\n        G.add_node(idx)\n    nk_in = {}\n    nk_out = {}\n    for p in h_degree_nodelist_in:\n        nk_in[p] = len(h_degree_nodelist_in[p])\n    for p in h_degree_nodelist_out:\n        nk_out[p] = len(h_degree_nodelist_out[p])\n    for k in nkk:\n        for l in nkk[k]:\n            n_edges_add = nkk[k][l]\n            if n_edges_add > 0:\n                chords = set()\n                k_len = nk_out[k]\n                l_len = nk_in[l]\n                chords_sample = seed.sample(range(k_len * l_len), n_edges_add + non_chords.get((k, l), 0))\n                num = 0\n                while len(chords) < n_edges_add:\n                    i = h_degree_nodelist_out[k][chords_sample[num] % k_len]\n                    j = h_degree_nodelist_in[l][chords_sample[num] // k_len]\n                    num += 1\n                    if i != j:\n                        chords.add((i, j))\n                k_unsat = h_degree_nodelist_out_unsat[k]\n                l_unsat = h_degree_nodelist_in_unsat[l]\n                while n_edges_add > 0:\n                    v, w = chords.pop()\n                    chords.add((v, w))\n                    if h_node_residual_out[v] == 0:\n                        _v = _directed_neighbor_switch(G, v, k_unsat, h_node_residual_out, chords, h_partition_in, l)\n                        if _v is not None:\n                            v = _v\n                    if h_node_residual_in[w] == 0:\n                        _w = _directed_neighbor_switch_rev(G, w, l_unsat, h_node_residual_in, chords, h_partition_out, k)\n                        if _w is not None:\n                            w = _w\n                    G.add_edge(v, w)\n                    h_node_residual_out[v] -= 1\n                    h_node_residual_in[w] -= 1\n                    n_edges_add -= 1\n                    chords.discard((v, w))\n                    if h_node_residual_out[v] == 0:\n                        k_unsat.discard(v)\n                    if h_node_residual_in[w] == 0:\n                        l_unsat.discard(w)\n    return G"
 },
 {
  "docstring": "Returns the two-dimensional grid graph.\n\nThe grid graph has each node connected to its four nearest neighbors.\n\nParameters\n----------\nm, n : int or iterable container of nodes\n    If an integer, nodes are from `range(n)`.\n    If a container, elements become the coordinate of the nodes.\n\nperiodic : bool or iterable\n    If `periodic` is True, both dimensions are periodic. If False, none\n    are periodic.  If `periodic` is iterable, it should yield 2 bool\n    values indicating whether the 1st and 2nd axes, respectively, are\n    periodic.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX graph\n    The (possibly periodic) grid graph of the specified dimensions.",
  "code": "@nx._dispatch(graphs=None)\n@nodes_or_number([0, 1])\ndef grid_2d_graph(m, n, periodic=False, create_using=None):\n    G = empty_graph(0, create_using)\n    row_name, rows = m\n    col_name, cols = n\n    G.add_nodes_from(((i, j) for i in rows for j in cols))\n    G.add_edges_from((((i, j), (pi, j)) for pi, i in pairwise(rows) for j in cols))\n    G.add_edges_from((((i, j), (i, pj)) for i in rows for pj, j in pairwise(cols)))\n    try:\n        periodic_r, periodic_c = periodic\n    except TypeError:\n        periodic_r = periodic_c = periodic\n    if periodic_r and len(rows) > 2:\n        first = rows[0]\n        last = rows[-1]\n        G.add_edges_from((((first, j), (last, j)) for j in cols))\n    if periodic_c and len(cols) > 2:\n        first = cols[0]\n        last = cols[-1]\n        G.add_edges_from((((i, first), (i, last)) for i in rows))\n    if G.is_directed():\n        G.add_edges_from(((v, u) for u, v in G.edges()))\n    return G"
 },
 {
  "docstring": "Returns the *n*-dimensional grid graph.\n\nThe dimension *n* is the length of the list `dim` and the size in\neach dimension is the value of the corresponding list element.\n\nParameters\n----------\ndim : list or tuple of numbers or iterables of nodes\n    'dim' is a tuple or list with, for each dimension, either a number\n    that is the size of that dimension or an iterable of nodes for\n    that dimension. The dimension of the grid_graph is the length\n    of `dim`.\n\nperiodic : bool or iterable\n    If `periodic` is True, all dimensions are periodic. If False all\n    dimensions are not periodic. If `periodic` is iterable, it should\n    yield `dim` bool values each of which indicates whether the\n    corresponding axis is periodic.\n\nReturns\n-------\nNetworkX graph\n    The (possibly periodic) grid graph of the specified dimensions.\n\nExamples\n--------\nTo produce a 2 by 3 by 4 grid graph, a graph on 24 nodes:\n\n>>> from networkx import grid_graph\n>>> G = grid_graph(dim=(2, 3, 4))\n>>> len(G)\n24\n>>> G = grid_graph(dim=(range(7, 9), range(3, 6)))\n>>> len(G)\n6",
  "code": "@nx._dispatch(graphs=None)\ndef grid_graph(dim, periodic=False):\n    from networkx.algorithms.operators.product import cartesian_product\n    if not dim:\n        return empty_graph(0)\n    try:\n        func = (cycle_graph if p else path_graph for p in periodic)\n    except TypeError:\n        func = repeat(cycle_graph if periodic else path_graph)\n    G = next(func)(dim[0])\n    for current_dim in dim[1:]:\n        Gnew = next(func)(current_dim)\n        G = cartesian_product(Gnew, G)\n    H = relabel_nodes(G, flatten)\n    return H"
 },
 {
  "docstring": "Returns the *n*-dimensional hypercube graph.\n\nThe nodes are the integers between 0 and ``2 ** n - 1``, inclusive.\n\nFor more information on the hypercube graph, see the Wikipedia\narticle `Hypercube graph`_.\n\n.. _Hypercube graph: https://en.wikipedia.org/wiki/Hypercube_graph\n\nParameters\n----------\nn : int\n    The dimension of the hypercube.\n    The number of nodes in the graph will be ``2 ** n``.\n\nReturns\n-------\nNetworkX graph\n    The hypercube graph of dimension *n*.",
  "code": "@nx._dispatch(graphs=None)\ndef hypercube_graph(n):\n    dim = n * [2]\n    G = grid_graph(dim)\n    return G"
 },
 {
  "docstring": "Returns the $m$ by $n$ triangular lattice graph.\n\nThe `triangular lattice graph`_ is a two-dimensional `grid graph`_ in\nwhich each square unit has a diagonal edge (each grid unit has a chord).\n\nThe returned graph has $m$ rows and $n$ columns of triangles. Rows and\ncolumns include both triangles pointing up and down. Rows form a strip\nof constant height. Columns form a series of diamond shapes, staggered\nwith the columns on either side. Another way to state the size is that\nthe nodes form a grid of `m+1` rows and `(n + 1) // 2` columns.\nThe odd row nodes are shifted horizontally relative to the even rows.\n\nDirected graph types have edges pointed up or right.\n\nPositions of nodes are computed by default or `with_positions is True`.\nThe position of each node (embedded in a euclidean plane) is stored in\nthe graph using equilateral triangles with sidelength 1.\nThe height between rows of nodes is thus $\\sqrt(3)/2$.\nNodes lie in the first quadrant with the node $(0, 0)$ at the origin.\n\n.. _triangular lattice graph: http://mathworld.wolfram.com/TriangularGrid.html\n.. _grid graph: http://www-cs-students.stanford.edu/~amitp/game-programming/grids/\n.. _Triangular Tiling: https://en.wikipedia.org/wiki/Triangular_tiling\n\nParameters\n----------\nm : int\n    The number of rows in the lattice.\n\nn : int\n    The number of columns in the lattice.\n\nperiodic : bool (default: False)\n    If True, join the boundary vertices of the grid using periodic\n    boundary conditions. The join between boundaries is the final row\n    and column of triangles. This means there is one row and one column\n    fewer nodes for the periodic lattice. Periodic lattices require\n    `m >= 3`, `n >= 5` and are allowed but misaligned if `m` or `n` are odd\n\nwith_positions : bool (default: True)\n    Store the coordinates of each node in the graph node attribute 'pos'.\n    The coordinates provide a lattice with equilateral triangles.\n    Periodic positions shift the nodes vertically in a nonlinear way so\n    the edges don't overlap so much.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX graph\n    The *m* by *n* triangular lattice graph.",
  "code": "@nx._dispatch(graphs=None)\ndef triangular_lattice_graph(m, n, periodic=False, with_positions=True, create_using=None):\n    H = empty_graph(0, create_using)\n    if n == 0 or m == 0:\n        return H\n    if periodic:\n        if n < 5 or m < 3:\n            msg = f'm > 2 and n > 4 required for periodic. m={m}, n={n}'\n            raise NetworkXError(msg)\n    N = (n + 1) // 2\n    rows = range(m + 1)\n    cols = range(N + 1)\n    H.add_edges_from((((i, j), (i + 1, j)) for j in rows for i in cols[:N]))\n    H.add_edges_from((((i, j), (i, j + 1)) for j in rows[:m] for i in cols))\n    H.add_edges_from((((i, j), (i + 1, j + 1)) for j in rows[1:m:2] for i in cols[:N]))\n    H.add_edges_from((((i + 1, j), (i, j + 1)) for j in rows[:m:2] for i in cols[:N]))\n    from networkx.algorithms.minors import contracted_nodes\n    if periodic is True:\n        for i in cols:\n            H = contracted_nodes(H, (i, 0), (i, m))\n        for j in rows[:m]:\n            H = contracted_nodes(H, (0, j), (N, j))\n    elif n % 2:\n        H.remove_nodes_from(((N, j) for j in rows[1::2]))\n    if with_positions:\n        ii = (i for i in cols for j in rows)\n        jj = (j for i in cols for j in rows)\n        xx = (0.5 * (j % 2) + i for i in cols for j in rows)\n        h = sqrt(3) / 2\n        if periodic:\n            yy = (h * j + 0.01 * i * i for i in cols for j in rows)\n        else:\n            yy = (h * j for i in cols for j in rows)\n        pos = {(i, j): (x, y) for i, j, x, y in zip(ii, jj, xx, yy) if (i, j) in H}\n        set_node_attributes(H, pos, 'pos')\n    return H"
 },
 {
  "docstring": "Returns an `m` by `n` hexagonal lattice graph.\n\nThe *hexagonal lattice graph* is a graph whose nodes and edges are\nthe `hexagonal tiling`_ of the plane.\n\nThe returned graph will have `m` rows and `n` columns of hexagons.\n`Odd numbered columns`_ are shifted up relative to even numbered columns.\n\nPositions of nodes are computed by default or `with_positions is True`.\nNode positions creating the standard embedding in the plane\nwith sidelength 1 and are stored in the node attribute 'pos'.\n`pos = nx.get_node_attributes(G, 'pos')` creates a dict ready for drawing.\n\n.. _hexagonal tiling: https://en.wikipedia.org/wiki/Hexagonal_tiling\n.. _Odd numbered columns: http://www-cs-students.stanford.edu/~amitp/game-programming/grids/\n\nParameters\n----------\nm : int\n    The number of rows of hexagons in the lattice.\n\nn : int\n    The number of columns of hexagons in the lattice.\n\nperiodic : bool\n    Whether to make a periodic grid by joining the boundary vertices.\n    For this to work `n` must be even and both `n > 1` and `m > 1`.\n    The periodic connections create another row and column of hexagons\n    so these graphs have fewer nodes as boundary nodes are identified.\n\nwith_positions : bool (default: True)\n    Store the coordinates of each node in the graph node attribute 'pos'.\n    The coordinates provide a lattice with vertical columns of hexagons\n    offset to interleave and cover the plane.\n    Periodic positions shift the nodes vertically in a nonlinear way so\n    the edges don't overlap so much.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n    If graph is directed, edges will point up or right.\n\nReturns\n-------\nNetworkX graph\n    The *m* by *n* hexagonal lattice graph.",
  "code": "@nx._dispatch(graphs=None)\ndef hexagonal_lattice_graph(m, n, periodic=False, with_positions=True, create_using=None):\n    G = empty_graph(0, create_using)\n    if m == 0 or n == 0:\n        return G\n    if periodic and (n % 2 == 1 or m < 2 or n < 2):\n        msg = 'periodic hexagonal lattice needs m > 1, n > 1 and even n'\n        raise NetworkXError(msg)\n    M = 2 * m\n    rows = range(M + 2)\n    cols = range(n + 1)\n    col_edges = (((i, j), (i, j + 1)) for i in cols for j in rows[:M + 1])\n    row_edges = (((i, j), (i + 1, j)) for i in cols[:n] for j in rows if i % 2 == j % 2)\n    G.add_edges_from(col_edges)\n    G.add_edges_from(row_edges)\n    G.remove_node((0, M + 1))\n    G.remove_node((n, (M + 1) * (n % 2)))\n    from networkx.algorithms.minors import contracted_nodes\n    if periodic:\n        for i in cols[:n]:\n            G = contracted_nodes(G, (i, 0), (i, M))\n        for i in cols[1:]:\n            G = contracted_nodes(G, (i, 1), (i, M + 1))\n        for j in rows[1:M]:\n            G = contracted_nodes(G, (0, j), (n, j))\n        G.remove_node((n, M))\n    ii = (i for i in cols for j in rows)\n    jj = (j for i in cols for j in rows)\n    xx = (0.5 + i + i // 2 + j % 2 * (i % 2 - 0.5) for i in cols for j in rows)\n    h = sqrt(3) / 2\n    if periodic:\n        yy = (h * j + 0.01 * i * i for i in cols for j in rows)\n    else:\n        yy = (h * j for i in cols for j in rows)\n    pos = {(i, j): (x, y) for i, j, x, y in zip(ii, jj, xx, yy) if (i, j) in G}\n    set_node_attributes(G, pos, 'pos')\n    return G"
 },
 {
  "docstring": "Returns the line graph of the graph or digraph `G`.\n\nThe line graph of a graph `G` has a node for each edge in `G` and an\nedge joining those nodes if the two edges in `G` share a common node. For\ndirected graphs, nodes are adjacent exactly when the edges they represent\nform a directed path of length two.\n\nThe nodes of the line graph are 2-tuples of nodes in the original graph (or\n3-tuples for multigraphs, with the key of the edge as the third element).\n\nFor information about self-loops and more discussion, see the **Notes**\nsection below.\n\nParameters\n----------\nG : graph\n    A NetworkX Graph, DiGraph, MultiGraph, or MultiDigraph.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nL : graph\n    The line graph of G.\n\nExamples\n--------\n>>> G = nx.star_graph(3)\n>>> L = nx.line_graph(G)\n>>> print(sorted(map(sorted, L.edges())))  # makes a 3-clique, K3\n[[(0, 1), (0, 2)], [(0, 1), (0, 3)], [(0, 2), (0, 3)]]\n\nEdge attributes from `G` are not copied over as node attributes in `L`, but\nattributes can be copied manually:\n\n>>> G = nx.path_graph(4)\n>>> G.add_edges_from((u, v, {\"tot\": u+v}) for u, v in G.edges)\n>>> G.edges(data=True)\nEdgeDataView([(0, 1, {'tot': 1}), (1, 2, {'tot': 3}), (2, 3, {'tot': 5})])\n>>> H = nx.line_graph(G)\n>>> H.add_nodes_from((node, G.edges[node]) for node in H)\n>>> H.nodes(data=True)\nNodeDataView({(0, 1): {'tot': 1}, (2, 3): {'tot': 5}, (1, 2): {'tot': 3}})\n\n",
  "code": "@nx._dispatch\ndef line_graph(G, create_using=None):\n    if G.is_directed():\n        L = _lg_directed(G, create_using=create_using)\n    else:\n        L = _lg_undirected(G, selfloops=False, create_using=create_using)\n    return L"
 },
 {
  "docstring": "Returns the line graph L of the (multi)digraph G.\n\nEdges in G appear as nodes in L, represented as tuples of the form (u,v)\nor (u,v,key) if G is a multidigraph. A node in L corresponding to the edge\n(u,v) is connected to every node corresponding to an edge (v,w).\n\nParameters\n----------\nG : digraph\n    A directed graph or directed multigraph.\ncreate_using : NetworkX graph constructor, optional\n   Graph type to create. If graph instance, then cleared before populated.\n   Default is to use the same graph class as `G`.",
  "code": "def _lg_directed(G, create_using=None):\n    L = nx.empty_graph(0, create_using, default=G.__class__)\n    get_edges = partial(G.edges, keys=True) if G.is_multigraph() else G.edges\n    for from_node in get_edges():\n        L.add_node(from_node)\n        for to_node in get_edges(from_node[1]):\n            L.add_edge(from_node, to_node)\n    return L"
 },
 {
  "docstring": "Returns the line graph L of the (multi)graph G.\n\nEdges in G appear as nodes in L, represented as sorted tuples of the form\n(u,v), or (u,v,key) if G is a multigraph. A node in L corresponding to\nthe edge {u,v} is connected to every node corresponding to an edge that\ninvolves u or v.\n\nParameters\n----------\nG : graph\n    An undirected graph or multigraph.\nselfloops : bool\n    If `True`, then self-loops are included in the line graph. If `False`,\n    they are excluded.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\n",
  "code": "def _lg_undirected(G, selfloops=False, create_using=None):\n    L = nx.empty_graph(0, create_using, default=G.__class__)\n    get_edges = partial(G.edges, keys=True) if G.is_multigraph() else G.edges\n    shift = 0 if selfloops else 1\n    node_index = {n: i for i, n in enumerate(G)}\n    edge_key_function = lambda edge: (node_index[edge[0]], node_index[edge[1]])\n    edges = set()\n    for u in G:\n        nodes = [tuple(sorted(x[:2], key=node_index.get)) + x[2:] for x in get_edges(u)]\n        if len(nodes) == 1:\n            L.add_node(nodes[0])\n        for i, a in enumerate(nodes):\n            edges.update([tuple(sorted((a, b), key=edge_key_function)) for b in nodes[i + shift:]])\n    L.add_edges_from(edges)\n    return L"
 },
 {
  "docstring": "Returns the inverse line graph of graph G.\n\nIf H is a graph, and G is the line graph of H, such that G = L(H).\nThen H is the inverse line graph of G.\n\nNot all graphs are line graphs and these do not have an inverse line graph.\nIn these cases this function raises a NetworkXError.\n\nParameters\n----------\nG : graph\n    A NetworkX Graph\n\nReturns\n-------\nH : graph\n    The inverse line graph of G.\n\nRaises\n------\nNetworkXNotImplemented\n    If G is directed or a multigraph\n\nNetworkXError\n    If G is not a line graph\n\n",
  "code": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef inverse_line_graph(G):\n    if G.number_of_nodes() == 0:\n        return nx.empty_graph(1)\n    elif G.number_of_nodes() == 1:\n        v = arbitrary_element(G)\n        a = (v, 0)\n        b = (v, 1)\n        H = nx.Graph([(a, b)])\n        return H\n    elif G.number_of_nodes() > 1 and G.number_of_edges() == 0:\n        msg = \"inverse_line_graph() doesn't work on an edgeless graph. Please use this function on each component separately.\"\n        raise nx.NetworkXError(msg)\n    if nx.number_of_selfloops(G) != 0:\n        msg = 'A line graph as generated by NetworkX has no selfloops, so G has no inverse line graph. Please remove the selfloops from G and try again.'\n        raise nx.NetworkXError(msg)\n    starting_cell = _select_starting_cell(G)\n    P = _find_partition(G, starting_cell)\n    P_count = {u: 0 for u in G.nodes}\n    for p in P:\n        for u in p:\n            P_count[u] += 1\n    if max(P_count.values()) > 2:\n        msg = 'G is not a line graph (vertex found in more than two partition cells)'\n        raise nx.NetworkXError(msg)\n    W = tuple(((u,) for u in P_count if P_count[u] == 1))\n    H = nx.Graph()\n    H.add_nodes_from(P)\n    H.add_nodes_from(W)\n    for a, b in combinations(H.nodes, 2):\n        if any((a_bit in b for a_bit in a)):\n            H.add_edge(a, b)\n    return H"
 },
 {
  "docstring": "Return list of all triangles containing edge e",
  "code": "def _triangles(G, e):\n    u, v = e\n    if u not in G:\n        raise nx.NetworkXError(f'Vertex {u} not in graph')\n    if v not in G[u]:\n        raise nx.NetworkXError(f'Edge ({u}, {v}) not in graph')\n    triangle_list = []\n    for x in G[u]:\n        if x in G[v]:\n            triangle_list.append((u, v, x))\n    return triangle_list"
 },
 {
  "docstring": "Test whether T is an odd triangle in G\n\nParameters\n----------\nG : NetworkX Graph\nT : 3-tuple of vertices forming triangle in G\n\nReturns\n-------\nTrue is T is an odd triangle\nFalse otherwise\n\nRaises\n------\nNetworkXError\n    T is not a triangle in G\n\n",
  "code": "def _odd_triangle(G, T):\n    for u in T:\n        if u not in G.nodes():\n            raise nx.NetworkXError(f'Vertex {u} not in graph')\n    for e in list(combinations(T, 2)):\n        if e[0] not in G[e[1]]:\n            raise nx.NetworkXError(f'Edge ({e[0]}, {e[1]}) not in graph')\n    T_neighbors = defaultdict(int)\n    for t in T:\n        for v in G[t]:\n            if v not in T:\n                T_neighbors[v] += 1\n    return any((T_neighbors[v] in [1, 3] for v in T_neighbors))"
 },
 {
  "docstring": "Find a partition of the vertices of G into cells of complete graphs\n\nParameters\n----------\nG : NetworkX Graph\nstarting_cell : tuple of vertices in G which form a cell\n\nReturns\n-------\nList of tuples of vertices of G\n\nRaises\n------\nNetworkXError\n    If a cell is not a complete subgraph then G is not a line graph",
  "code": "def _find_partition(G, starting_cell):\n    G_partition = G.copy()\n    P = [starting_cell]\n    G_partition.remove_edges_from(list(combinations(starting_cell, 2)))\n    partitioned_vertices = list(starting_cell)\n    while G_partition.number_of_edges() > 0:\n        u = partitioned_vertices.pop()\n        deg_u = len(G_partition[u])\n        if deg_u != 0:\n            new_cell = [u] + list(G_partition[u])\n            for u in new_cell:\n                for v in new_cell:\n                    if u != v and v not in G_partition[u]:\n                        msg = 'G is not a line graph (partition cell not a complete subgraph)'\n                        raise nx.NetworkXError(msg)\n            P.append(tuple(new_cell))\n            G_partition.remove_edges_from(list(combinations(new_cell, 2)))\n            partitioned_vertices += new_cell\n    return P"
 },
 {
  "docstring": "Select a cell to initiate _find_partition\n\nParameters\n----------\nG : NetworkX Graph\nstarting_edge: an edge to build the starting cell from\n\nReturns\n-------\nTuple of vertices in G\n\nRaises\n------\nNetworkXError\n    If it is determined that G is not a line graph\n\n",
  "code": "def _select_starting_cell(G, starting_edge=None):\n    if starting_edge is None:\n        e = arbitrary_element(G.edges())\n    else:\n        e = starting_edge\n        if e[0] not in G.nodes():\n            raise nx.NetworkXError(f'Vertex {e[0]} not in graph')\n        if e[1] not in G[e[0]]:\n            msg = f'starting_edge ({e[0]}, {e[1]}) is not in the Graph'\n            raise nx.NetworkXError(msg)\n    e_triangles = _triangles(G, e)\n    r = len(e_triangles)\n    if r == 0:\n        starting_cell = e\n    elif r == 1:\n        T = e_triangles[0]\n        a, b, c = T\n        ac_edges = len(_triangles(G, (a, c)))\n        bc_edges = len(_triangles(G, (b, c)))\n        if ac_edges == 1:\n            if bc_edges == 1:\n                starting_cell = T\n            else:\n                return _select_starting_cell(G, starting_edge=(b, c))\n        else:\n            return _select_starting_cell(G, starting_edge=(a, c))\n    else:\n        s = 0\n        odd_triangles = []\n        for T in e_triangles:\n            if _odd_triangle(G, T):\n                s += 1\n                odd_triangles.append(T)\n        if r == 2 and s == 0:\n            starting_cell = T\n        elif r - 1 <= s <= r:\n            triangle_nodes = set()\n            for T in odd_triangles:\n                for x in T:\n                    triangle_nodes.add(x)\n            for u in triangle_nodes:\n                for v in triangle_nodes:\n                    if u != v and v not in G[u]:\n                        msg = 'G is not a line graph (odd triangles do not form complete subgraph)'\n                        raise nx.NetworkXError(msg)\n            starting_cell = tuple(triangle_nodes)\n        else:\n            msg = 'G is not a line graph (incorrect number of odd triangles around starting edge)'\n            raise nx.NetworkXError(msg)\n    return starting_cell"
 },
 {
  "docstring": "Returns the Mycielskian of a simple, undirected graph G\n\nThe Mycielskian of graph preserves a graph's triangle free\nproperty while increasing the chromatic number by 1.\n\nThe Mycielski Operation on a graph, :math:`G=(V, E)`, constructs a new\ngraph with :math:`2|V| + 1` nodes and :math:`3|E| + |V|` edges.\n\nThe construction is as follows:\n\nLet :math:`V = {0, ..., n-1}`. Construct another vertex set\n:math:`U = {n, ..., 2n}` and a vertex, `w`.\nConstruct a new graph, `M`, with vertices :math:`U \\bigcup V \\bigcup w`.\nFor edges, :math:`(u, v) \\in E` add edges :math:`(u, v), (u, v + n)`, and\n:math:`(u + n, v)` to M. Finally, for all vertices :math:`u \\in U`, add\nedge :math:`(u, w)` to M.\n\nThe Mycielski Operation can be done multiple times by repeating the above\nprocess iteratively.\n\nMore information can be found at https://en.wikipedia.org/wiki/Mycielskian\n\nParameters\n----------\nG : graph\n    A simple, undirected NetworkX graph\niterations : int\n    The number of iterations of the Mycielski operation to\n    perform on G. Defaults to 1. Must be a non-negative integer.\n\nReturns\n-------\nM : graph\n    The Mycielskian of G after the specified number of iterations.\n\n",
  "code": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@nx._dispatch\ndef mycielskian(G, iterations=1):\n    M = nx.convert_node_labels_to_integers(G)\n    for i in range(iterations):\n        n = M.number_of_nodes()\n        M.add_nodes_from(range(n, 2 * n))\n        old_edges = list(M.edges())\n        M.add_edges_from(((u, v + n) for u, v in old_edges))\n        M.add_edges_from(((u + n, v) for u, v in old_edges))\n        M.add_node(2 * n)\n        M.add_edges_from(((u + n, 2 * n) for u in range(n)))\n    return M"
 },
 {
  "docstring": "Generator for the n_th Mycielski Graph.\n\nThe Mycielski family of graphs is an infinite set of graphs.\n:math:`M_1` is the singleton graph, :math:`M_2` is two vertices with an\nedge, and, for :math:`i > 2`, :math:`M_i` is the Mycielskian of\n:math:`M_{i-1}`.\n\nMore information can be found at\nhttp://mathworld.wolfram.com/MycielskiGraph.html\n\nParameters\n----------\nn : int\n    The desired Mycielski Graph.\n\nReturns\n-------\nM : graph\n    The n_th Mycielski Graph\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef mycielski_graph(n):\n    if n < 1:\n        raise nx.NetworkXError('must satisfy n >= 1')\n    if n == 1:\n        return nx.empty_graph(1)\n    else:\n        return mycielskian(nx.path_graph(2), n - 2)"
 },
 {
  "docstring": "Returns a list of nonisomorphic trees\n\nParameters\n----------\norder : int\n  order of the desired tree(s)\n\ncreate : graph or matrix (default=\"Graph)\n  If graph is selected a list of trees will be returned,\n  if matrix is selected a list of adjacency matrix will\n  be returned\n\nReturns\n-------\nG : List of NetworkX Graphs\n\nM : List of Adjacency matrices\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef nonisomorphic_trees(order, create='graph'):\n    if order < 2:\n        raise ValueError\n    layout = list(range(order // 2 + 1)) + list(range(1, (order + 1) // 2))\n    while layout is not None:\n        layout = _next_tree(layout)\n        if layout is not None:\n            if create == 'graph':\n                yield _layout_to_graph(layout)\n            elif create == 'matrix':\n                yield _layout_to_matrix(layout)\n            layout = _next_rooted_tree(layout)"
 },
 {
  "docstring": "Returns the number of nonisomorphic trees\n\nParameters\n----------\norder : int\n  order of the desired tree(s)\n\nReturns\n-------\nlength : Number of nonisomorphic graphs for the given order\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef number_of_nonisomorphic_trees(order):\n    return sum((1 for _ in nonisomorphic_trees(order)))"
 },
 {
  "docstring": "One iteration of the Beyer-Hedetniemi algorithm.",
  "code": "def _next_rooted_tree(predecessor, p=None):\n    if p is None:\n        p = len(predecessor) - 1\n        while predecessor[p] == 1:\n            p -= 1\n    if p == 0:\n        return None\n    q = p - 1\n    while predecessor[q] != predecessor[p] - 1:\n        q -= 1\n    result = list(predecessor)\n    for i in range(p, len(result)):\n        result[i] = result[i - p + q]\n    return result"
 },
 {
  "docstring": "One iteration of the Wright, Richmond, Odlyzko and McKay\nalgorithm.",
  "code": "def _next_tree(candidate):\n    left, rest = _split_tree(candidate)\n    left_height = max(left)\n    rest_height = max(rest)\n    valid = rest_height >= left_height\n    if valid and rest_height == left_height:\n        if len(left) > len(rest):\n            valid = False\n        elif len(left) == len(rest) and left > rest:\n            valid = False\n    if valid:\n        return candidate\n    else:\n        p = len(left)\n        new_candidate = _next_rooted_tree(candidate, p)\n        if candidate[p] > 2:\n            new_left, new_rest = _split_tree(new_candidate)\n            new_left_height = max(new_left)\n            suffix = range(1, new_left_height + 2)\n            new_candidate[-len(suffix):] = suffix\n        return new_candidate"
 },
 {
  "docstring": "Returns a tuple of two layouts, one containing the left\nsubtree of the root vertex, and one containing the original tree\nwith the left subtree removed.",
  "code": "def _split_tree(layout):\n    one_found = False\n    m = None\n    for i in range(len(layout)):\n        if layout[i] == 1:\n            if one_found:\n                m = i\n                break\n            else:\n                one_found = True\n    if m is None:\n        m = len(layout)\n    left = [layout[i] - 1 for i in range(1, m)]\n    rest = [0] + [layout[i] for i in range(m, len(layout))]\n    return (left, rest)"
 },
 {
  "docstring": "Create the adjacency matrix for the tree specified by the\ngiven layout (level sequence).",
  "code": "def _layout_to_matrix(layout):\n    result = [[0] * len(layout) for i in range(len(layout))]\n    stack = []\n    for i in range(len(layout)):\n        i_level = layout[i]\n        if stack:\n            j = stack[-1]\n            j_level = layout[j]\n            while j_level >= i_level:\n                stack.pop()\n                j = stack[-1]\n                j_level = layout[j]\n            result[i][j] = result[j][i] = 1\n        stack.append(i)\n    return result"
 },
 {
  "docstring": "Create a NetworkX Graph for the tree specified by the\ngiven layout(level sequence)",
  "code": "def _layout_to_graph(layout):\n    G = nx.Graph()\n    stack = []\n    for i in range(len(layout)):\n        i_level = layout[i]\n        if stack:\n            j = stack[-1]\n            j_level = layout[j]\n            while j_level >= i_level:\n                stack.pop()\n                j = stack[-1]\n                j_level = layout[j]\n            G.add_edge(i, j)\n        stack.append(i)\n    return G"
 },
 {
  "docstring": "Generate a random graph with the given joint independent edge degree and\ntriangle degree sequence.\n\nThis uses a configuration model-like approach to generate a random graph\n(with parallel edges and self-loops) by randomly assigning edges to match\nthe given joint degree sequence.\n\nThe joint degree sequence is a list of pairs of integers of the form\n$[(d_{1,i}, d_{1,t}), \\dotsc, (d_{n,i}, d_{n,t})]$. According to this list,\nvertex $u$ is a member of $d_{u,t}$ triangles and has $d_{u, i}$ other\nedges. The number $d_{u,t}$ is the *triangle degree* of $u$ and the number\n$d_{u,i}$ is the *independent edge degree*.\n\nParameters\n----------\njoint_degree_sequence : list of integer pairs\n    Each list entry corresponds to the independent edge degree and\n    triangle degree of a node.\ncreate_using : NetworkX graph constructor, optional (default MultiGraph)\n   Graph type to create. If graph instance, then cleared before populated.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : MultiGraph\n    A graph with the specified degree sequence. Nodes are labeled\n    starting at 0 with an index corresponding to the position in\n    deg_sequence.\n\nRaises\n------\nNetworkXError\n    If the independent edge degree sequence sum is not even\n    or the triangle degree sequence sum is not divisible by 3.\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_clustered_graph(joint_degree_sequence, create_using=None, seed=None):\n    joint_degree_sequence = list(joint_degree_sequence)\n    N = len(joint_degree_sequence)\n    G = nx.empty_graph(N, create_using, default=nx.MultiGraph)\n    if G.is_directed():\n        raise nx.NetworkXError('Directed Graph not supported')\n    ilist = []\n    tlist = []\n    for n in G:\n        degrees = joint_degree_sequence[n]\n        for icount in range(degrees[0]):\n            ilist.append(n)\n        for tcount in range(degrees[1]):\n            tlist.append(n)\n    if len(ilist) % 2 != 0 or len(tlist) % 3 != 0:\n        raise nx.NetworkXError('Invalid degree sequence')\n    seed.shuffle(ilist)\n    seed.shuffle(tlist)\n    while ilist:\n        G.add_edge(ilist.pop(), ilist.pop())\n    while tlist:\n        n1 = tlist.pop()\n        n2 = tlist.pop()\n        n3 = tlist.pop()\n        G.add_edges_from([(n1, n2), (n1, n3), (n2, n3)])\n    return G"
 },
 {
  "docstring": "Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph or\na binomial graph.\n\nParameters\n----------\nn : int\n    The number of nodes.\np : float\n    Probability for edge creation.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool, optional (default=False)\n    If True, this function returns a directed graph.\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef fast_gnp_random_graph(n, p, seed=None, directed=False):\n    G = empty_graph(n)\n    if p <= 0 or p >= 1:\n        return nx.gnp_random_graph(n, p, seed=seed, directed=directed)\n    lp = math.log(1.0 - p)\n    if directed:\n        G = nx.DiGraph(G)\n        v = 1\n        w = -1\n        while v < n:\n            lr = math.log(1.0 - seed.random())\n            w = w + 1 + int(lr / lp)\n            while w >= v and v < n:\n                w = w - v\n                v = v + 1\n            if v < n:\n                G.add_edge(w, v)\n    v = 1\n    w = -1\n    while v < n:\n        lr = math.log(1.0 - seed.random())\n        w = w + 1 + int(lr / lp)\n        while w >= v and v < n:\n            w = w - v\n            v = v + 1\n        if v < n:\n            G.add_edge(v, w)\n    return G"
 },
 {
  "docstring": "Returns a $G_{n,p}$ random graph, also known as an Erd\u0151s-R\u00e9nyi graph\nor a binomial graph.\n\nThe $G_{n,p}$ model chooses each of the possible edges with probability $p$.\n\nParameters\n----------\nn : int\n    The number of nodes.\np : float\n    Probability for edge creation.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool, optional (default=False)\n    If True, this function returns a directed graph.\n\nSee Also\n--------\nfast_gnp_random_graph\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnp_random_graph(n, p, seed=None, directed=False):\n    if directed:\n        edges = itertools.permutations(range(n), 2)\n        G = nx.DiGraph()\n    else:\n        edges = itertools.combinations(range(n), 2)\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if p <= 0:\n        return G\n    if p >= 1:\n        return complete_graph(n, create_using=G)\n    for e in edges:\n        if seed.random() < p:\n            G.add_edge(*e)\n    return G"
 },
 {
  "docstring": "Returns a $G_{n,m}$ random graph.\n\nIn the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\nof all graphs with $n$ nodes and $m$ edges.\n\nThis algorithm should be faster than :func:`gnm_random_graph` for dense\ngraphs.\n\nParameters\n----------\nn : int\n    The number of nodes.\nm : int\n    The number of edges.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\ngnm_random_graph\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef dense_gnm_random_graph(n, m, seed=None):\n    mmax = n * (n - 1) // 2\n    if m >= mmax:\n        G = complete_graph(n)\n    else:\n        G = empty_graph(n)\n    if n == 1 or m >= mmax:\n        return G\n    u = 0\n    v = 1\n    t = 0\n    k = 0\n    while True:\n        if seed.randrange(mmax - t) < m - k:\n            G.add_edge(u, v)\n            k += 1\n            if k == m:\n                return G\n        t += 1\n        v += 1\n        if v == n:\n            u += 1\n            v = u + 1"
 },
 {
  "docstring": "Returns a $G_{n,m}$ random graph.\n\nIn the $G_{n,m}$ model, a graph is chosen uniformly at random from the set\nof all graphs with $n$ nodes and $m$ edges.\n\nThis algorithm should be faster than :func:`dense_gnm_random_graph` for\nsparse graphs.\n\nParameters\n----------\nn : int\n    The number of nodes.\nm : int\n    The number of edges.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ndirected : bool, optional (default=False)\n    If True return a directed graph\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef gnm_random_graph(n, m, seed=None, directed=False):\n    if directed:\n        G = nx.DiGraph()\n    else:\n        G = nx.Graph()\n    G.add_nodes_from(range(n))\n    if n == 1:\n        return G\n    max_edges = n * (n - 1)\n    if not directed:\n        max_edges /= 2.0\n    if m >= max_edges:\n        return complete_graph(n, create_using=G)\n    nlist = list(G)\n    edge_count = 0\n    while edge_count < m:\n        u = seed.choice(nlist)\n        v = seed.choice(nlist)\n        if u == v or G.has_edge(u, v):\n            continue\n        else:\n            G.add_edge(u, v)\n            edge_count = edge_count + 1\n    return G"
 },
 {
  "docstring": "Returns a Newman\u2013Watts\u2013Strogatz small-world graph.\n\nParameters\n----------\nn : int\n    The number of nodes.\nk : int\n    Each node is joined with its `k` nearest neighbors in a ring\n    topology.\np : float\n    The probability of adding a new edge for each edge.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef newman_watts_strogatz_graph(n, k, p, seed=None):\n    if k > n:\n        raise nx.NetworkXError('k>=n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = empty_graph(n)\n    nlist = list(G.nodes())\n    fromv = nlist\n    for j in range(1, k // 2 + 1):\n        tov = fromv[j:] + fromv[0:j]\n        for i in range(len(fromv)):\n            G.add_edge(fromv[i], tov[i])\n    e = list(G.edges())\n    for u, v in e:\n        if seed.random() < p:\n            w = seed.choice(nlist)\n            while w == u or G.has_edge(u, w):\n                w = seed.choice(nlist)\n                if G.degree(u) >= n - 1:\n                    break\n            else:\n                G.add_edge(u, w)\n    return G"
 },
 {
  "docstring": "Returns a Watts\u2013Strogatz small-world graph.\n\nParameters\n----------\nn : int\n    The number of nodes\nk : int\n    Each node is joined with its `k` nearest neighbors in a ring\n    topology.\np : float\n    The probability of rewiring each edge\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nSee Also\n--------\nnewman_watts_strogatz_graph\nconnected_watts_strogatz_graph\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef watts_strogatz_graph(n, k, p, seed=None):\n    if k > n:\n        raise nx.NetworkXError('k>n, choose smaller k or larger n')\n    if k == n:\n        return nx.complete_graph(n)\n    G = nx.Graph()\n    nodes = list(range(n))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        G.add_edges_from(zip(nodes, targets))\n    for j in range(1, k // 2 + 1):\n        targets = nodes[j:] + nodes[0:j]\n        for u, v in zip(nodes, targets):\n            if seed.random() < p:\n                w = seed.choice(nodes)\n                while w == u or G.has_edge(u, w):\n                    w = seed.choice(nodes)\n                    if G.degree(u) >= n - 1:\n                        break\n                else:\n                    G.remove_edge(u, v)\n                    G.add_edge(u, w)\n    return G"
 },
 {
  "docstring": "Returns a connected Watts\u2013Strogatz small-world graph.\n\nAttempts to generate a connected graph by repeated generation of\nWatts\u2013Strogatz small-world graphs.  An exception is raised if the maximum\nnumber of tries is exceeded.\n\nParameters\n----------\nn : int\n    The number of nodes\nk : int\n    Each node is joined with its `k` nearest neighbors in a ring\n    topology.\np : float\n    The probability of rewiring each edge\ntries : int\n    Number of attempts to generate a connected graph.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\n",
  "code": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef connected_watts_strogatz_graph(n, k, p, tries=100, seed=None):\n    for i in range(tries):\n        G = watts_strogatz_graph(n, k, p, seed)\n        if nx.is_connected(G):\n            return G\n    raise nx.NetworkXError('Maximum number of tries exceeded')"
 },
 {
  "docstring": "Returns a random $d$-regular graph on $n$ nodes.\n\nA regular graph is a graph where each node has the same number of neighbors.\n\nThe resulting graph has no self-loops or parallel edges.\n\nParameters\n----------\nd : int\n  The degree of each node.\nn : integer\n  The number of nodes. The value of $n \\times d$ must be even.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_regular_graph(d, n, seed=None):\n    if n * d % 2 != 0:\n        raise nx.NetworkXError('n * d must be even')\n    if not 0 <= d < n:\n        raise nx.NetworkXError('the 0 <= d < n inequality must be satisfied')\n    if d == 0:\n        return empty_graph(n)\n\n    def _suitable(edges, potential_edges):\n        if not potential_edges:\n            return True\n        for s1 in potential_edges:\n            for s2 in potential_edges:\n                if s1 == s2:\n                    break\n                if s1 > s2:\n                    s1, s2 = (s2, s1)\n                if (s1, s2) not in edges:\n                    return True\n        return False\n\n    def _try_creation():\n        edges = set()\n        stubs = list(range(n)) * d\n        while stubs:\n            potential_edges = defaultdict(lambda: 0)\n            seed.shuffle(stubs)\n            stubiter = iter(stubs)\n            for s1, s2 in zip(stubiter, stubiter):\n                if s1 > s2:\n                    s1, s2 = (s2, s1)\n                if s1 != s2 and (s1, s2) not in edges:\n                    edges.add((s1, s2))\n                else:\n                    potential_edges[s1] += 1\n                    potential_edges[s2] += 1\n            if not _suitable(edges, potential_edges):\n                return None\n            stubs = [node for node, potential in potential_edges.items() for _ in range(potential)]\n        return edges\n    edges = _try_creation()\n    while edges is None:\n        edges = _try_creation()\n    G = nx.Graph()\n    G.add_edges_from(edges)\n    return G"
 },
 {
  "docstring": "Return m unique elements from seq.\n\nThis differs from random.sample which can return repeated\nelements if seq holds repeated elements.\n\nNote: rng is a random.Random or numpy.random.RandomState instance.",
  "code": "def _random_subset(seq, m, rng):\n    targets = set()\n    while len(targets) < m:\n        x = rng.choice(seq)\n        targets.add(x)\n    return targets"
 },
 {
  "docstring": "Returns a random graph using Barab\u00e1si\u2013Albert preferential attachment\n\nA graph of $n$ nodes is grown by attaching new nodes each with $m$\nedges that are preferentially attached to existing nodes with high degree.\n\nParameters\n----------\nn : int\n    Number of nodes\nm : int\n    Number of edges to attach from a new node to existing nodes\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ninitial_graph : Graph or None (default)\n    Initial network for Barab\u00e1si\u2013Albert algorithm.\n    It should be a connected graph for most use cases.\n    A copy of `initial_graph` is used.\n    If None, starts from a star graph on (m+1) nodes.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If `m` does not satisfy ``1 <= m < n``, or\n    the initial graph number of nodes m0 does not satisfy ``m <= m0 <= n``.\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef barabasi_albert_graph(n, m, seed=None, initial_graph=None):\n    if m < 1 or m >= n:\n        raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert network must have m >= 1 and m < n, m = {m}, n = {n}')\n    if initial_graph is None:\n        G = star_graph(m)\n    else:\n        if len(initial_graph) < m or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph needs between m={m} and n={n} nodes')\n        G = initial_graph.copy()\n    repeated_nodes = [n for n, d in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G"
 },
 {
  "docstring": "Returns a random graph using dual Barab\u00e1si\u2013Albert preferential attachment\n\nA graph of $n$ nodes is grown by attaching new nodes each with either $m_1$\nedges (with probability $p$) or $m_2$ edges (with probability $1-p$) that\nare preferentially attached to existing nodes with high degree.\n\nParameters\n----------\nn : int\n    Number of nodes\nm1 : int\n    Number of edges to link each new node to existing nodes with probability $p$\nm2 : int\n    Number of edges to link each new node to existing nodes with probability $1-p$\np : float\n    The probability of attaching $m_1$ edges (as opposed to $m_2$ edges)\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ninitial_graph : Graph or None (default)\n    Initial network for Barab\u00e1si\u2013Albert algorithm.\n    A copy of `initial_graph` is used.\n    It should be connected for most use cases.\n    If None, starts from an star graph on max(m1, m2) + 1 nodes.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If `m1` and `m2` do not satisfy ``1 <= m1,m2 < n``, or\n    `p` does not satisfy ``0 <= p <= 1``, or\n    the initial graph number of nodes m0 does not satisfy m1, m2 <= m0 <= n.\n\n",
  "code": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef dual_barabasi_albert_graph(n, m1, m2, p, seed=None, initial_graph=None):\n    if m1 < 1 or m1 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m1 >= 1 and m1 < n, m1 = {m1}, n = {n}')\n    if m2 < 1 or m2 >= n:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert must have m2 >= 1 and m2 < n, m2 = {m2}, n = {n}')\n    if p < 0 or p > 1:\n        raise nx.NetworkXError(f'Dual Barab\u00e1si\u2013Albert network must have 0 <= p <= 1, p = {p}')\n    if p == 1:\n        return barabasi_albert_graph(n, m1, seed)\n    elif p == 0:\n        return barabasi_albert_graph(n, m2, seed)\n    if initial_graph is None:\n        G = star_graph(max(m1, m2))\n    else:\n        if len(initial_graph) < max(m1, m2) or len(initial_graph) > n:\n            raise nx.NetworkXError(f'Barab\u00e1si\u2013Albert initial graph must have between max(m1, m2) = {max(m1, m2)} and n = {n} nodes')\n        G = initial_graph.copy()\n    targets = list(G)\n    repeated_nodes = [n for n, d in G.degree() for _ in range(d)]\n    source = len(G)\n    while source < n:\n        if seed.random() < p:\n            m = m1\n        else:\n            m = m2\n        targets = _random_subset(repeated_nodes, m, seed)\n        G.add_edges_from(zip([source] * m, targets))\n        repeated_nodes.extend(targets)\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G"
 },
 {
  "docstring": "Returns an extended Barab\u00e1si\u2013Albert model graph.\n\nAn extended Barab\u00e1si\u2013Albert model graph is a random graph constructed\nusing preferential attachment. The extended model allows new edges,\nrewired edges or new nodes. Based on the probabilities $p$ and $q$\nwith $p + q < 1$, the growing behavior of the graph is determined as:\n\n1) With $p$ probability, $m$ new edges are added to the graph,\nstarting from randomly chosen existing nodes and attached preferentially at the other end.\n\n2) With $q$ probability, $m$ existing edges are rewired\nby randomly choosing an edge and rewiring one end to a preferentially chosen node.\n\n3) With $(1 - p - q)$ probability, $m$ new nodes are added to the graph\nwith edges attached preferentially.\n\nWhen $p = q = 0$, the model behaves just like the Barab\u00e1si\u2013Alber model.\n\nParameters\n----------\nn : int\n    Number of nodes\nm : int\n    Number of edges with which a new node attaches to existing nodes\np : float\n    Probability value for adding an edge between existing nodes. p + q < 1\nq : float\n    Probability value of rewiring of existing edges. p + q < 1\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If `m` does not satisfy ``1 <= m < n`` or ``1 >= p + q``\n\n",
  "code": "@py_random_state(4)\n@nx._dispatch(graphs=None)\ndef extended_barabasi_albert_graph(n, m, p, q, seed=None):\n    if m < 1 or m >= n:\n        msg = f'Extended Barabasi-Albert network needs m>=1 and m<n, m={m}, n={n}'\n        raise nx.NetworkXError(msg)\n    if p + q >= 1:\n        msg = f'Extended Barabasi-Albert network needs p + q <= 1, p={p}, q={q}'\n        raise nx.NetworkXError(msg)\n    G = empty_graph(m)\n    attachment_preference = []\n    attachment_preference.extend(range(m))\n    new_node = m\n    while new_node < n:\n        a_probability = seed.random()\n        clique_degree = len(G) - 1\n        clique_size = len(G) * clique_degree / 2\n        if a_probability < p and G.size() <= clique_size - m:\n            eligible_nodes = [nd for nd, deg in G.degree() if deg < clique_degree]\n            for i in range(m):\n                src_node = seed.choice(eligible_nodes)\n                prohibited_nodes = list(G[src_node])\n                prohibited_nodes.append(src_node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in prohibited_nodes])\n                G.add_edge(src_node, dest_node)\n                attachment_preference.append(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == clique_degree:\n                    eligible_nodes.remove(src_node)\n                if G.degree(dest_node) == clique_degree and dest_node in eligible_nodes:\n                    eligible_nodes.remove(dest_node)\n        elif p <= a_probability < p + q and m <= G.size() < clique_size:\n            eligible_nodes = [nd for nd, deg in G.degree() if 0 < deg < clique_degree]\n            for i in range(m):\n                node = seed.choice(eligible_nodes)\n                neighbor_nodes = list(G[node])\n                src_node = seed.choice(neighbor_nodes)\n                neighbor_nodes.append(node)\n                dest_node = seed.choice([nd for nd in attachment_preference if nd not in neighbor_nodes])\n                G.remove_edge(node, src_node)\n                G.add_edge(node, dest_node)\n                attachment_preference.remove(src_node)\n                attachment_preference.append(dest_node)\n                if G.degree(src_node) == 0 and src_node in eligible_nodes:\n                    eligible_nodes.remove(src_node)\n                if dest_node in eligible_nodes:\n                    if G.degree(dest_node) == clique_degree:\n                        eligible_nodes.remove(dest_node)\n                elif G.degree(dest_node) == 1:\n                    eligible_nodes.append(dest_node)\n        else:\n            targets = _random_subset(attachment_preference, m, seed)\n            G.add_edges_from(zip([new_node] * m, targets))\n            attachment_preference.extend(targets)\n            attachment_preference.extend([new_node] * (m + 1))\n            new_node += 1\n    return G"
 },
 {
  "docstring": "Holme and Kim algorithm for growing graphs with powerlaw\ndegree distribution and approximate average clustering.\n\nParameters\n----------\nn : int\n    the number of nodes\nm : int\n    the number of random edges to add for each new node\np : float,\n    Probability of adding a triangle after adding a random edge\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef powerlaw_cluster_graph(n, m, p, seed=None):\n    if m < 1 or n < m:\n        raise nx.NetworkXError(f'NetworkXError must have m>1 and m<n, m={m},n={n}')\n    if p > 1 or p < 0:\n        raise nx.NetworkXError(f'NetworkXError p must be in [0,1], p={p}')\n    G = empty_graph(m)\n    repeated_nodes = list(G.nodes())\n    source = m\n    while source < n:\n        possible_targets = _random_subset(repeated_nodes, m, seed)\n        target = possible_targets.pop()\n        G.add_edge(source, target)\n        repeated_nodes.append(target)\n        count = 1\n        while count < m:\n            if seed.random() < p:\n                neighborhood = [nbr for nbr in G.neighbors(target) if not G.has_edge(source, nbr) and nbr != source]\n                if neighborhood:\n                    nbr = seed.choice(neighborhood)\n                    G.add_edge(source, nbr)\n                    repeated_nodes.append(nbr)\n                    count = count + 1\n                    continue\n            target = possible_targets.pop()\n            G.add_edge(source, target)\n            repeated_nodes.append(target)\n            count = count + 1\n        repeated_nodes.extend([source] * m)\n        source += 1\n    return G"
 },
 {
  "docstring": "Returns a random lobster graph.\n\nA lobster is a tree that reduces to a caterpillar when pruning all\nleaf nodes. A caterpillar is a tree that reduces to a path graph\nwhen pruning all leaf nodes; setting `p2` to zero produces a caterpillar.\n\nThis implementation iterates on the probabilities `p1` and `p2` to add\nedges at levels 1 and 2, respectively. Graphs are therefore constructed\niteratively with uniform randomness at each level rather than being selected\nuniformly at random from the set of all possible lobsters.\n\nParameters\n----------\nn : int\n    The expected number of nodes in the backbone\np1 : float\n    Probability of adding an edge to the backbone\np2 : float\n    Probability of adding an edge one level beyond backbone\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nRaises\n------\nNetworkXError\n    If `p1` or `p2` parameters are >= 1 because the while loops would never finish.",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_lobster(n, p1, p2, seed=None):\n    p1, p2 = (abs(p1), abs(p2))\n    if any((p >= 1 for p in [p1, p2])):\n        raise nx.NetworkXError('Probability values for `p1` and `p2` must both be < 1.')\n    llen = int(2 * seed.random() * n + 0.5)\n    L = path_graph(llen)\n    current_node = llen - 1\n    for n in range(llen):\n        while seed.random() < p1:\n            current_node += 1\n            L.add_edge(n, current_node)\n            cat_node = current_node\n            while seed.random() < p2:\n                current_node += 1\n                L.add_edge(cat_node, current_node)\n    return L"
 },
 {
  "docstring": "Returns a random shell graph for the constructor given.\n\nParameters\n----------\nconstructor : list of three-tuples\n    Represents the parameters for a shell, starting at the center\n    shell.  Each element of the list must be of the form `(n, m,\n    d)`, where `n` is the number of nodes in the shell, `m` is\n    the number of edges in the shell, and `d` is the ratio of\n    inter-shell (next) edges to intra-shell edges. If `d` is zero,\n    there will be no intra-shell edges, and if `d` is one there\n    will be all possible intra-shell edges.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nExamples\n--------\n>>> constructor = [(10, 20, 0.8), (20, 40, 0.8)]\n>>> G = nx.random_shell_graph(constructor)",
  "code": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_shell_graph(constructor, seed=None):\n    G = empty_graph(0)\n    glist = []\n    intra_edges = []\n    nnodes = 0\n    for n, m, d in constructor:\n        inter_edges = int(m * d)\n        intra_edges.append(m - inter_edges)\n        g = nx.convert_node_labels_to_integers(gnm_random_graph(n, inter_edges, seed=seed), first_label=nnodes)\n        glist.append(g)\n        nnodes += n\n        G = nx.operators.union(G, g)\n    for gi in range(len(glist) - 1):\n        nlist1 = list(glist[gi])\n        nlist2 = list(glist[gi + 1])\n        total_edges = intra_edges[gi]\n        edge_count = 0\n        while edge_count < total_edges:\n            u = seed.choice(nlist1)\n            v = seed.choice(nlist2)\n            if u == v or G.has_edge(u, v):\n                continue\n            else:\n                G.add_edge(u, v)\n                edge_count = edge_count + 1\n    return G"
 },
 {
  "docstring": "Returns a tree with a power law degree distribution.\n\nParameters\n----------\nn : int\n    The number of nodes.\ngamma : float\n    Exponent of the power law.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ntries : int\n    Number of attempts to adjust the sequence to make it a tree.\n\nRaises\n------\nNetworkXError\n    If no valid sequence is found within the maximum number of\n    attempts.\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree(n, gamma=3, seed=None, tries=100):\n    seq = random_powerlaw_tree_sequence(n, gamma=gamma, seed=seed, tries=tries)\n    G = degree_sequence_tree(seq)\n    return G"
 },
 {
  "docstring": "Returns a degree sequence for a tree with a power law distribution.\n\nParameters\n----------\nn : int,\n    The number of nodes.\ngamma : float\n    Exponent of the power law.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ntries : int\n    Number of attempts to adjust the sequence to make it a tree.\n\nRaises\n------\nNetworkXError\n    If no valid sequence is found within the maximum number of\n    attempts.\n\n",
  "code": "@py_random_state(2)\n@nx._dispatch(graphs=None)\ndef random_powerlaw_tree_sequence(n, gamma=3, seed=None, tries=100):\n    z = nx.utils.powerlaw_sequence(n, exponent=gamma, seed=seed)\n    zseq = [min(n, max(round(s), 0)) for s in z]\n    z = nx.utils.powerlaw_sequence(tries, exponent=gamma, seed=seed)\n    swap = [min(n, max(round(s), 0)) for s in z]\n    for deg in swap:\n        if 2 * n - sum(zseq) == 2:\n            return zseq\n        index = seed.randint(0, n - 1)\n        zseq[index] = swap.pop()\n    raise nx.NetworkXError(f'Exceeded max ({tries}) attempts for a valid tree sequence.')"
 },
 {
  "docstring": "Returns an random graph based on the specified kernel.\n\nThe algorithm chooses each of the $[n(n-1)]/2$ possible edges with\nprobability specified by a kernel $\\kappa(x,y)$ [1]_.  The kernel\n$\\kappa(x,y)$ must be a symmetric (in $x,y$), non-negative,\nbounded function.\n\nParameters\n----------\nn : int\n    The number of nodes\nkernel_integral : function\n    Function that returns the definite integral of the kernel $\\kappa(x,y)$,\n    $F(y,a,b) := \\int_a^b \\kappa(x,y)dx$\nkernel_root: function (optional)\n    Function that returns the root $b$ of the equation $F(y,a,b) = r$.\n    If None, the root is found using :func:`scipy.optimize.brentq`\n    (this requires SciPy).\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\n",
  "code": "@py_random_state(3)\n@nx._dispatch(graphs=None)\ndef random_kernel_graph(n, kernel_integral, kernel_root=None, seed=None):\n    if kernel_root is None:\n        import scipy as sp\n\n        def kernel_root(y, a, r):\n\n            def my_function(b):\n                return kernel_integral(y, a, b) - r\n            return sp.optimize.brentq(my_function, a, 1)\n    graph = nx.Graph()\n    graph.add_nodes_from(range(n))\n    i, j = (1, 1)\n    while i < n:\n        r = -math.log(1 - seed.random())\n        if kernel_integral(i / n, j / n, 1) <= r:\n            i, j = (i + 1, i + 1)\n        else:\n            j = math.ceil(n * kernel_root(i / n, j / n, r))\n            graph.add_edge(i - 1, j - 1)\n    return graph"
 },
 {
  "docstring": "A decorator which inspects the `create_using` argument and raises a\nNetworkX exception when `create_using` is a DiGraph (class or instance) for\ngraph generators that do not support directed outputs.",
  "code": "def _raise_on_directed(func):\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        if kwargs.get('create_using') is not None:\n            G = nx.empty_graph(create_using=kwargs['create_using'])\n            if G.is_directed():\n                raise NetworkXError('Directed Graph not supported')\n        return func(*args, **kwargs)\n    return wrapper"
 },
 {
  "docstring": "Return the cubic graph specified in LCF notation.\n\nLCF notation (LCF=Lederberg-Coxeter-Fruchte) is a compressed\nnotation used in the generation of various cubic Hamiltonian\ngraphs of high symmetry. See, for example, dodecahedral_graph,\ndesargues_graph, heawood_graph and pappus_graph below.\n\nn (number of nodes)\n  The starting graph is the n-cycle with nodes 0,...,n-1.\n  (The null graph is returned if n < 0.)\n\nshift_list = [s1,s2,..,sk], a list of integer shifts mod n,\n\nrepeats\n  integer specifying the number of times that shifts in shift_list\n  are successively applied to each v_current in the n-cycle\n  to generate an edge between v_current and v_current+shift mod n.\n\nFor v1 cycling through the n-cycle a total of k*repeats\nwith shift cycling through shiftlist repeats times connect\nv1 with v1+shift mod n\n\nThe utility graph $K_{3,3}$\n\n>>> G = nx.LCF_graph(6, [3, -3], 3)\n\nThe Heawood graph\n\n>>> G = nx.LCF_graph(14, [5, -5], 7)\n\nSee http://mathworld.wolfram.com/LCFNotation.html for a description\nand references.",
  "code": "@nx._dispatch(graphs=None)\ndef LCF_graph(n, shift_list, repeats, create_using=None):\n    if n <= 0:\n        return empty_graph(0, create_using)\n    G = cycle_graph(n, create_using)\n    if G.is_directed():\n        raise NetworkXError('Directed Graph not supported')\n    G.name = 'LCF_graph'\n    nodes = sorted(G)\n    n_extra_edges = repeats * len(shift_list)\n    if n_extra_edges < 1:\n        return G\n    for i in range(n_extra_edges):\n        shift = shift_list[i % len(shift_list)]\n        v1 = nodes[i % n]\n        v2 = nodes[(i + shift) % n]\n        G.add_edge(v1, v2)\n    return G"
 },
 {
  "docstring": "Returns the Bull Graph\n\nThe Bull Graph has 5 nodes and 5 edges. It is a planar undirected\ngraph in the form of a triangle with two disjoint pendant edges [1]_\nThe name comes from the triangle and pendant edges representing\nrespectively the body and legs of a bull.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    A bull graph with 5 nodes\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef bull_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 4], 3: [1], 4: [2]}, create_using=create_using)\n    G.name = 'Bull Graph'\n    return G"
 },
 {
  "docstring": "Returns the Chv\u00e1tal Graph\n\nThe Chv\u00e1tal Graph is an undirected graph with 12 nodes and 24 edges [1]_.\nIt has 370 distinct (directed) Hamiltonian cycles, giving a unique generalized\nLCF notation of order 4, two of order 6 , and 43 of order 1 [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    The Chv\u00e1tal graph with 12 nodes and 24 edges\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef chvatal_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 4, 6, 9], 1: [2, 5, 7], 2: [3, 6, 8], 3: [4, 7, 9], 4: [5, 8], 5: [10, 11], 6: [10, 11], 7: [8, 11], 8: [10], 9: [10, 11]}, create_using=create_using)\n    G.name = 'Chvatal Graph'\n    return G"
 },
 {
  "docstring": "Returns the 3-regular Platonic Cubical Graph\n\nThe skeleton of the cube (the nodes and edges) form a graph, with 8\nnodes, and 12 edges. It is a special case of the hypercube graph.\nIt is one of 5 Platonic graphs, each a skeleton of its\nPlatonic solid [1]_.\nSuch graphs arise in parallel processing in computers.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    A cubical graph with 8 nodes and 12 edges\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef cubical_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 3, 4], 1: [0, 2, 7], 2: [1, 3, 6], 3: [0, 2, 5], 4: [0, 5, 7], 5: [3, 4, 6], 6: [2, 5, 7], 7: [1, 4, 6]}, create_using=create_using)\n    G.name = 'Platonic Cubical Graph'\n    return G"
 },
 {
  "docstring": "Returns the Desargues Graph\n\nThe Desargues Graph is a non-planar, distance-transitive cubic graph\nwith 20 nodes and 30 edges [1]_.\nIt is a symmetric graph. It can be represented in LCF notation\nas [5,-5,9,-9]^5 [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Desargues Graph with 20 nodes and 30 edges\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef desargues_graph(create_using=None):\n    G = LCF_graph(20, [5, -5, 9, -9], 5, create_using)\n    G.name = 'Desargues Graph'\n    return G"
 },
 {
  "docstring": "Returns the Diamond graph\n\nThe Diamond Graph is  planar undirected graph with 4 nodes and 5 edges.\nIt is also sometimes known as the double triangle graph or kite graph [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Diamond Graph with 4 nodes and 5 edges\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef diamond_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 2], 1: [0, 2, 3], 2: [0, 1, 3], 3: [1, 2]}, create_using=create_using)\n    G.name = 'Diamond Graph'\n    return G"
 },
 {
  "docstring": "Returns the Platonic Dodecahedral graph.\n\nThe dodecahedral graph has 20 nodes and 30 edges. The skeleton of the\ndodecahedron forms a graph. It is one of 5 Platonic graphs [1]_.\nIt can be described in LCF notation as:\n``[10, 7, 4, -4, -7, 10, -4, 7, -7, 4]^2`` [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Dodecahedral Graph with 20 nodes and 30 edges\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef dodecahedral_graph(create_using=None):\n    G = LCF_graph(20, [10, 7, 4, -4, -7, 10, -4, 7, -7, 4], 2, create_using)\n    G.name = 'Dodecahedral Graph'\n    return G"
 },
 {
  "docstring": "Returns the Frucht Graph.\n\nThe Frucht Graph is the smallest cubical graph whose\nautomorphism group consists only of the identity element [1]_.\nIt has 12 nodes and 18 edges and no nontrivial symmetries.\nIt is planar and Hamiltonian [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Frucht Graph with 12 nodes and 18 edges\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef frucht_graph(create_using=None):\n    G = cycle_graph(7, create_using)\n    G.add_edges_from([[0, 7], [1, 7], [2, 8], [3, 9], [4, 9], [5, 10], [6, 10], [7, 11], [8, 11], [8, 9], [10, 11]])\n    G.name = 'Frucht Graph'\n    return G"
 },
 {
  "docstring": "Returns the Heawood Graph, a (3,6) cage.\n\nThe Heawood Graph is an undirected graph with 14 nodes and 21 edges,\nnamed after Percy John Heawood [1]_.\nIt is cubic symmetric, nonplanar, Hamiltonian, and can be represented\nin LCF notation as ``[5,-5]^7`` [2]_.\nIt is the unique (3,6)-cage: the regular cubic graph of girth 6 with\nminimal number of vertices [3]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Heawood Graph with 14 nodes and 21 edges\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef heawood_graph(create_using=None):\n    G = LCF_graph(14, [5, -5], 7, create_using)\n    G.name = 'Heawood Graph'\n    return G"
 },
 {
  "docstring": "Returns the Hoffman-Singleton Graph.\n\nThe Hoffman\u2013Singleton graph is a symmetrical undirected graph\nwith 50 nodes and 175 edges.\nAll indices lie in ``Z % 5``: that is, the integers mod 5 [1]_.\nIt is the only regular graph of vertex degree 7, diameter 2, and girth 5.\nIt is the unique (7,5)-cage graph and Moore graph, and contains many\ncopies of the Petersen graph [2]_.\n\nReturns\n-------\nG : networkx Graph\n    Hoffman\u2013Singleton Graph with 50 nodes and 175 edges\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef hoffman_singleton_graph():\n    G = nx.Graph()\n    for i in range(5):\n        for j in range(5):\n            G.add_edge(('pentagon', i, j), ('pentagon', i, (j - 1) % 5))\n            G.add_edge(('pentagon', i, j), ('pentagon', i, (j + 1) % 5))\n            G.add_edge(('pentagram', i, j), ('pentagram', i, (j - 2) % 5))\n            G.add_edge(('pentagram', i, j), ('pentagram', i, (j + 2) % 5))\n            for k in range(5):\n                G.add_edge(('pentagon', i, j), ('pentagram', k, (i * k + j) % 5))\n    G = nx.convert_node_labels_to_integers(G)\n    G.name = 'Hoffman-Singleton Graph'\n    return G"
 },
 {
  "docstring": "Returns the House graph (square with triangle on top)\n\nThe house graph is a simple undirected graph with\n5 nodes and 6 edges [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    House graph in the form of a square with a triangle on top\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef house_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 2], 1: [0, 3], 2: [0, 3, 4], 3: [1, 2, 4], 4: [2, 3]}, create_using=create_using)\n    G.name = 'House Graph'\n    return G"
 },
 {
  "docstring": "Returns the House graph with a cross inside the house square.\n\nThe House X-graph is the House graph plus the two edges connecting diagonally\nopposite vertices of the square base. It is also one of the two graphs\nobtained by removing two edges from the pentatope graph [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    House graph with diagonal vertices connected\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef house_x_graph(create_using=None):\n    G = house_graph(create_using)\n    G.add_edges_from([(0, 3), (1, 2)])\n    G.name = 'House-with-X-inside Graph'\n    return G"
 },
 {
  "docstring": "Returns the Platonic Icosahedral graph.\n\nThe icosahedral graph has 12 nodes and 30 edges. It is a Platonic graph\nwhose nodes have the connectivity of the icosahedron. It is undirected,\nregular and Hamiltonian [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Icosahedral graph with 12 nodes and 30 edges.\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef icosahedral_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 5, 7, 8, 11], 1: [2, 5, 6, 8], 2: [3, 6, 8, 9], 3: [4, 6, 9, 10], 4: [5, 6, 10, 11], 5: [6, 11], 7: [8, 9, 10, 11], 8: [9], 9: [10], 10: [11]}, create_using=create_using)\n    G.name = 'Platonic Icosahedral Graph'\n    return G"
 },
 {
  "docstring": "Returns the Krackhardt Kite Social Network.\n\nA 10 actor social network introduced by David Krackhardt\nto illustrate different centrality measures [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Krackhardt Kite graph with 10 nodes and 18 edges\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef krackhardt_kite_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 2, 3, 5], 1: [0, 3, 4, 6], 2: [0, 3, 5], 3: [0, 1, 2, 4, 5, 6], 4: [1, 3, 6], 5: [0, 2, 3, 6, 7], 6: [1, 3, 4, 5, 7], 7: [5, 6, 8], 8: [7, 9], 9: [8]}, create_using=create_using)\n    G.name = 'Krackhardt Kite Social Network'\n    return G"
 },
 {
  "docstring": "Returns the Moebius-Kantor graph.\n\nThe M\u00f6bius-Kantor graph is the cubic symmetric graph on 16 nodes.\nIts LCF notation is [5,-5]^8, and it is isomorphic to the generalized\nPetersen graph [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Moebius-Kantor graph\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef moebius_kantor_graph(create_using=None):\n    G = LCF_graph(16, [5, -5], 8, create_using)\n    G.name = 'Moebius-Kantor Graph'\n    return G"
 },
 {
  "docstring": "Returns the Platonic Octahedral graph.\n\nThe octahedral graph is the 6-node 12-edge Platonic graph having the\nconnectivity of the octahedron [1]_. If 6 couples go to a party,\nand each person shakes hands with every person except his or her partner,\nthen this graph describes the set of handshakes that take place;\nfor this reason it is also called the cocktail party graph [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Octahedral graph\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef octahedral_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 2, 3, 4], 1: [2, 3, 5], 2: [4, 5], 3: [4, 5], 4: [5]}, create_using=create_using)\n    G.name = 'Platonic Octahedral Graph'\n    return G"
 },
 {
  "docstring": "Returns the Pappus graph.\n\nThe Pappus graph is a cubic symmetric distance-regular graph with 18 nodes\nand 27 edges. It is Hamiltonian and can be represented in LCF notation as\n[5,7,-7,7,-7,-5]^3 [1]_.\n\nReturns\n-------\nG : networkx Graph\n    Pappus graph\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef pappus_graph():\n    G = LCF_graph(18, [5, 7, -7, 7, -7, -5], 3)\n    G.name = 'Pappus Graph'\n    return G"
 },
 {
  "docstring": "Returns the Petersen graph.\n\nThe Peterson graph is a cubic, undirected graph with 10 nodes and 15 edges [1]_.\nJulius Petersen constructed the graph as the smallest counterexample\nagainst the claim that a connected bridgeless cubic graph\nhas an edge colouring with three colours [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Petersen graph\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef petersen_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 4, 5], 1: [0, 2, 6], 2: [1, 3, 7], 3: [2, 4, 8], 4: [3, 0, 9], 5: [0, 7, 8], 6: [1, 8, 9], 7: [2, 5, 9], 8: [3, 5, 6], 9: [4, 6, 7]}, create_using=create_using)\n    G.name = 'Petersen Graph'\n    return G"
 },
 {
  "docstring": "Return a small maze with a cycle.\n\nThis is the maze used in Sedgewick, 3rd Edition, Part 5, Graph\nAlgorithms, Chapter 18, e.g. Figure 18.2 and following [1]_.\nNodes are numbered 0,..,7\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Small maze with a cycle\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef sedgewick_maze_graph(create_using=None):\n    G = empty_graph(0, create_using)\n    G.add_nodes_from(range(8))\n    G.add_edges_from([[0, 2], [0, 7], [0, 5]])\n    G.add_edges_from([[1, 7], [2, 6]])\n    G.add_edges_from([[3, 4], [3, 5]])\n    G.add_edges_from([[4, 5], [4, 7], [4, 6]])\n    G.name = 'Sedgewick Maze'\n    return G"
 },
 {
  "docstring": "Returns the 3-regular Platonic Tetrahedral graph.\n\nTetrahedral graph has 4 nodes and 6 edges. It is a\nspecial case of the complete graph, K4, and wheel graph, W4.\nIt is one of the 5 platonic graphs [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Tetrahedral Graph\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef tetrahedral_graph(create_using=None):\n    G = complete_graph(4, create_using)\n    G.name = 'Platonic Tetrahedral Graph'\n    return G"
 },
 {
  "docstring": "Returns the skeleton of the truncated cube.\n\nThe truncated cube is an Archimedean solid with 14 regular\nfaces (6 octagonal and 8 triangular), 36 edges and 24 nodes [1]_.\nThe truncated cube is created by truncating (cutting off) the tips\nof the cube one third of the way into each edge [2]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Skeleton of the truncated cube\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef truncated_cube_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 2, 4], 1: [11, 14], 2: [3, 4], 3: [6, 8], 4: [5], 5: [16, 18], 6: [7, 8], 7: [10, 12], 8: [9], 9: [17, 20], 10: [11, 12], 11: [14], 12: [13], 13: [21, 22], 14: [15], 15: [19, 23], 16: [17, 18], 17: [20], 18: [19], 19: [23], 20: [21], 21: [22], 22: [23]}, create_using=create_using)\n    G.name = 'Truncated Cube Graph'\n    return G"
 },
 {
  "docstring": "Returns the skeleton of the truncated Platonic tetrahedron.\n\nThe truncated tetrahedron is an Archimedean solid with 4 regular hexagonal faces,\n4 equilateral triangle faces, 12 nodes and 18 edges. It can be constructed by truncating\nall 4 vertices of a regular tetrahedron at one third of the original edge length [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Skeleton of the truncated tetrahedron\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef truncated_tetrahedron_graph(create_using=None):\n    G = path_graph(12, create_using)\n    G.add_edges_from([(0, 2), (0, 9), (1, 6), (3, 11), (4, 11), (5, 7), (8, 10)])\n    G.name = 'Truncated Tetrahedron Graph'\n    return G"
 },
 {
  "docstring": "Returns the Tutte graph.\n\nThe Tutte graph is a cubic polyhedral, non-Hamiltonian graph. It has\n46 nodes and 69 edges.\nIt is a counterexample to Tait's conjecture that every 3-regular polyhedron\nhas a Hamiltonian cycle.\nIt can be realized geometrically from a tetrahedron by multiply truncating\nthree of its vertices [1]_.\n\nParameters\n----------\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nG : networkx Graph\n    Tutte graph\n\n",
  "code": "@_raise_on_directed\n@nx._dispatch(graphs=None)\ndef tutte_graph(create_using=None):\n    G = nx.from_dict_of_lists({0: [1, 2, 3], 1: [4, 26], 2: [10, 11], 3: [18, 19], 4: [5, 33], 5: [6, 29], 6: [7, 27], 7: [8, 14], 8: [9, 38], 9: [10, 37], 10: [39], 11: [12, 39], 12: [13, 35], 13: [14, 15], 14: [34], 15: [16, 22], 16: [17, 44], 17: [18, 43], 18: [45], 19: [20, 45], 20: [21, 41], 21: [22, 23], 22: [40], 23: [24, 27], 24: [25, 32], 25: [26, 31], 26: [33], 27: [28], 28: [29, 32], 29: [30], 30: [31, 33], 31: [32], 34: [35, 38], 35: [36], 36: [37, 39], 37: [38], 40: [41, 44], 41: [42], 42: [43, 45], 43: [44]}, create_using=create_using)\n    G.name = \"Tutte's Graph\"\n    return G"
 },
 {
  "docstring": "Returns Zachary's Karate Club graph.\n\nEach node in the returned graph has a node attribute 'club' that\nindicates the name of the club to which the member represented by that node\nbelongs, either 'Mr. Hi' or 'Officer'. Each edge has a weight based on the\nnumber of contexts in which that edge's incident node members interacted.\n\nExamples\n--------\nTo get the name of the club to which a node belongs::\n\n    >>> G = nx.karate_club_graph()\n    >>> G.nodes[5][\"club\"]\n    'Mr. Hi'\n    >>> G.nodes[9][\"club\"]\n    'Officer'\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef karate_club_graph():\n    all_members = set(range(34))\n    club1 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 16, 17, 19, 21}\n    G = nx.Graph()\n    G.add_nodes_from(all_members)\n    G.name = \"Zachary's Karate Club\"\n    zacharydat = '0 4 5 3 3 3 3 2 2 0 2 3 2 3 0 0 0 2 0 2 0 2 0 0 0 0 0 0 0 0 0 2 0 0\\n4 0 6 3 0 0 0 4 0 0 0 0 0 5 0 0 0 1 0 2 0 2 0 0 0 0 0 0 0 0 2 0 0 0\\n5 6 0 3 0 0 0 4 5 1 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 2 2 0 0 0 3 0\\n3 3 3 0 0 0 0 3 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n3 0 0 0 0 0 2 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n3 0 0 0 0 0 5 0 0 0 3 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n3 0 0 0 2 5 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n2 4 4 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n2 0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 4 3\\n0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2\\n2 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n1 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n3 5 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 2\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 4\\n0 0 0 0 0 3 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2\\n2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 1\\n2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 0 4 0 2 0 0 5 4\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 3 0 0 0 2 0 0\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 5 2 0 0 0 0 0 0 7 0 0\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 2\\n0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 3 0 0 0 0 0 0 0 0 4\\n0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 2\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 4 0 0 0 0 0 3 2\\n0 2 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 3\\n2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 7 0 0 2 0 0 0 4 4\\n0 0 2 0 0 0 0 0 3 0 0 0 0 0 3 3 0 0 1 0 3 0 2 5 0 0 0 0 0 4 3 4 0 5\\n0 0 0 0 0 0 0 0 4 2 0 0 0 3 2 4 0 0 2 1 1 0 3 4 0 0 2 4 2 2 3 4 5 0'\n    for row, line in enumerate(zacharydat.split('\\n')):\n        thisrow = [int(b) for b in line.split()]\n        for col, entry in enumerate(thisrow):\n            if entry >= 1:\n                G.add_edge(row, col, weight=entry)\n    for v in G:\n        G.nodes[v]['club'] = 'Mr. Hi' if v in club1 else 'Officer'\n    return G"
 },
 {
  "docstring": "Returns Davis Southern women social network.\n\nThis is a bipartite graph.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef davis_southern_women_graph():\n    G = nx.Graph()\n    women = ['Evelyn Jefferson', 'Laura Mandeville', 'Theresa Anderson', 'Brenda Rogers', 'Charlotte McDowd', 'Frances Anderson', 'Eleanor Nye', 'Pearl Oglethorpe', 'Ruth DeSand', 'Verne Sanderson', 'Myra Liddel', 'Katherina Rogers', 'Sylvia Avondale', 'Nora Fayette', 'Helen Lloyd', 'Dorothy Murchison', 'Olivia Carleton', 'Flora Price']\n    G.add_nodes_from(women, bipartite=0)\n    events = ['E1', 'E2', 'E3', 'E4', 'E5', 'E6', 'E7', 'E8', 'E9', 'E10', 'E11', 'E12', 'E13', 'E14']\n    G.add_nodes_from(events, bipartite=1)\n    G.add_edges_from([('Evelyn Jefferson', 'E1'), ('Evelyn Jefferson', 'E2'), ('Evelyn Jefferson', 'E3'), ('Evelyn Jefferson', 'E4'), ('Evelyn Jefferson', 'E5'), ('Evelyn Jefferson', 'E6'), ('Evelyn Jefferson', 'E8'), ('Evelyn Jefferson', 'E9'), ('Laura Mandeville', 'E1'), ('Laura Mandeville', 'E2'), ('Laura Mandeville', 'E3'), ('Laura Mandeville', 'E5'), ('Laura Mandeville', 'E6'), ('Laura Mandeville', 'E7'), ('Laura Mandeville', 'E8'), ('Theresa Anderson', 'E2'), ('Theresa Anderson', 'E3'), ('Theresa Anderson', 'E4'), ('Theresa Anderson', 'E5'), ('Theresa Anderson', 'E6'), ('Theresa Anderson', 'E7'), ('Theresa Anderson', 'E8'), ('Theresa Anderson', 'E9'), ('Brenda Rogers', 'E1'), ('Brenda Rogers', 'E3'), ('Brenda Rogers', 'E4'), ('Brenda Rogers', 'E5'), ('Brenda Rogers', 'E6'), ('Brenda Rogers', 'E7'), ('Brenda Rogers', 'E8'), ('Charlotte McDowd', 'E3'), ('Charlotte McDowd', 'E4'), ('Charlotte McDowd', 'E5'), ('Charlotte McDowd', 'E7'), ('Frances Anderson', 'E3'), ('Frances Anderson', 'E5'), ('Frances Anderson', 'E6'), ('Frances Anderson', 'E8'), ('Eleanor Nye', 'E5'), ('Eleanor Nye', 'E6'), ('Eleanor Nye', 'E7'), ('Eleanor Nye', 'E8'), ('Pearl Oglethorpe', 'E6'), ('Pearl Oglethorpe', 'E8'), ('Pearl Oglethorpe', 'E9'), ('Ruth DeSand', 'E5'), ('Ruth DeSand', 'E7'), ('Ruth DeSand', 'E8'), ('Ruth DeSand', 'E9'), ('Verne Sanderson', 'E7'), ('Verne Sanderson', 'E8'), ('Verne Sanderson', 'E9'), ('Verne Sanderson', 'E12'), ('Myra Liddel', 'E8'), ('Myra Liddel', 'E9'), ('Myra Liddel', 'E10'), ('Myra Liddel', 'E12'), ('Katherina Rogers', 'E8'), ('Katherina Rogers', 'E9'), ('Katherina Rogers', 'E10'), ('Katherina Rogers', 'E12'), ('Katherina Rogers', 'E13'), ('Katherina Rogers', 'E14'), ('Sylvia Avondale', 'E7'), ('Sylvia Avondale', 'E8'), ('Sylvia Avondale', 'E9'), ('Sylvia Avondale', 'E10'), ('Sylvia Avondale', 'E12'), ('Sylvia Avondale', 'E13'), ('Sylvia Avondale', 'E14'), ('Nora Fayette', 'E6'), ('Nora Fayette', 'E7'), ('Nora Fayette', 'E9'), ('Nora Fayette', 'E10'), ('Nora Fayette', 'E11'), ('Nora Fayette', 'E12'), ('Nora Fayette', 'E13'), ('Nora Fayette', 'E14'), ('Helen Lloyd', 'E7'), ('Helen Lloyd', 'E8'), ('Helen Lloyd', 'E10'), ('Helen Lloyd', 'E11'), ('Helen Lloyd', 'E12'), ('Dorothy Murchison', 'E8'), ('Dorothy Murchison', 'E9'), ('Olivia Carleton', 'E9'), ('Olivia Carleton', 'E11'), ('Flora Price', 'E9'), ('Flora Price', 'E11')])\n    G.graph['top'] = women\n    G.graph['bottom'] = events\n    return G"
 },
 {
  "docstring": "Returns Florentine families graph.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef florentine_families_graph():\n    G = nx.Graph()\n    G.add_edge('Acciaiuoli', 'Medici')\n    G.add_edge('Castellani', 'Peruzzi')\n    G.add_edge('Castellani', 'Strozzi')\n    G.add_edge('Castellani', 'Barbadori')\n    G.add_edge('Medici', 'Barbadori')\n    G.add_edge('Medici', 'Ridolfi')\n    G.add_edge('Medici', 'Tornabuoni')\n    G.add_edge('Medici', 'Albizzi')\n    G.add_edge('Medici', 'Salviati')\n    G.add_edge('Salviati', 'Pazzi')\n    G.add_edge('Peruzzi', 'Strozzi')\n    G.add_edge('Peruzzi', 'Bischeri')\n    G.add_edge('Strozzi', 'Ridolfi')\n    G.add_edge('Strozzi', 'Bischeri')\n    G.add_edge('Ridolfi', 'Tornabuoni')\n    G.add_edge('Tornabuoni', 'Guadagni')\n    G.add_edge('Albizzi', 'Ginori')\n    G.add_edge('Albizzi', 'Guadagni')\n    G.add_edge('Bischeri', 'Guadagni')\n    G.add_edge('Guadagni', 'Lamberteschi')\n    return G"
 },
 {
  "docstring": "Returns coappearance network of characters in the novel Les Miserables.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef les_miserables_graph():\n    G = nx.Graph()\n    G.add_edge('Napoleon', 'Myriel', weight=1)\n    G.add_edge('MlleBaptistine', 'Myriel', weight=8)\n    G.add_edge('MmeMagloire', 'Myriel', weight=10)\n    G.add_edge('MmeMagloire', 'MlleBaptistine', weight=6)\n    G.add_edge('CountessDeLo', 'Myriel', weight=1)\n    G.add_edge('Geborand', 'Myriel', weight=1)\n    G.add_edge('Champtercier', 'Myriel', weight=1)\n    G.add_edge('Cravatte', 'Myriel', weight=1)\n    G.add_edge('Count', 'Myriel', weight=2)\n    G.add_edge('OldMan', 'Myriel', weight=1)\n    G.add_edge('Valjean', 'Labarre', weight=1)\n    G.add_edge('Valjean', 'MmeMagloire', weight=3)\n    G.add_edge('Valjean', 'MlleBaptistine', weight=3)\n    G.add_edge('Valjean', 'Myriel', weight=5)\n    G.add_edge('Marguerite', 'Valjean', weight=1)\n    G.add_edge('MmeDeR', 'Valjean', weight=1)\n    G.add_edge('Isabeau', 'Valjean', weight=1)\n    G.add_edge('Gervais', 'Valjean', weight=1)\n    G.add_edge('Listolier', 'Tholomyes', weight=4)\n    G.add_edge('Fameuil', 'Tholomyes', weight=4)\n    G.add_edge('Fameuil', 'Listolier', weight=4)\n    G.add_edge('Blacheville', 'Tholomyes', weight=4)\n    G.add_edge('Blacheville', 'Listolier', weight=4)\n    G.add_edge('Blacheville', 'Fameuil', weight=4)\n    G.add_edge('Favourite', 'Tholomyes', weight=3)\n    G.add_edge('Favourite', 'Listolier', weight=3)\n    G.add_edge('Favourite', 'Fameuil', weight=3)\n    G.add_edge('Favourite', 'Blacheville', weight=4)\n    G.add_edge('Dahlia', 'Tholomyes', weight=3)\n    G.add_edge('Dahlia', 'Listolier', weight=3)\n    G.add_edge('Dahlia', 'Fameuil', weight=3)\n    G.add_edge('Dahlia', 'Blacheville', weight=3)\n    G.add_edge('Dahlia', 'Favourite', weight=5)\n    G.add_edge('Zephine', 'Tholomyes', weight=3)\n    G.add_edge('Zephine', 'Listolier', weight=3)\n    G.add_edge('Zephine', 'Fameuil', weight=3)\n    G.add_edge('Zephine', 'Blacheville', weight=3)\n    G.add_edge('Zephine', 'Favourite', weight=4)\n    G.add_edge('Zephine', 'Dahlia', weight=4)\n    G.add_edge('Fantine', 'Tholomyes', weight=3)\n    G.add_edge('Fantine', 'Listolier', weight=3)\n    G.add_edge('Fantine', 'Fameuil', weight=3)\n    G.add_edge('Fantine', 'Blacheville', weight=3)\n    G.add_edge('Fantine', 'Favourite', weight=4)\n    G.add_edge('Fantine', 'Dahlia', weight=4)\n    G.add_edge('Fantine', 'Zephine', weight=4)\n    G.add_edge('Fantine', 'Marguerite', weight=2)\n    G.add_edge('Fantine', 'Valjean', weight=9)\n    G.add_edge('MmeThenardier', 'Fantine', weight=2)\n    G.add_edge('MmeThenardier', 'Valjean', weight=7)\n    G.add_edge('Thenardier', 'MmeThenardier', weight=13)\n    G.add_edge('Thenardier', 'Fantine', weight=1)\n    G.add_edge('Thenardier', 'Valjean', weight=12)\n    G.add_edge('Cosette', 'MmeThenardier', weight=4)\n    G.add_edge('Cosette', 'Valjean', weight=31)\n    G.add_edge('Cosette', 'Tholomyes', weight=1)\n    G.add_edge('Cosette', 'Thenardier', weight=1)\n    G.add_edge('Javert', 'Valjean', weight=17)\n    G.add_edge('Javert', 'Fantine', weight=5)\n    G.add_edge('Javert', 'Thenardier', weight=5)\n    G.add_edge('Javert', 'MmeThenardier', weight=1)\n    G.add_edge('Javert', 'Cosette', weight=1)\n    G.add_edge('Fauchelevent', 'Valjean', weight=8)\n    G.add_edge('Fauchelevent', 'Javert', weight=1)\n    G.add_edge('Bamatabois', 'Fantine', weight=1)\n    G.add_edge('Bamatabois', 'Javert', weight=1)\n    G.add_edge('Bamatabois', 'Valjean', weight=2)\n    G.add_edge('Perpetue', 'Fantine', weight=1)\n    G.add_edge('Simplice', 'Perpetue', weight=2)\n    G.add_edge('Simplice', 'Valjean', weight=3)\n    G.add_edge('Simplice', 'Fantine', weight=2)\n    G.add_edge('Simplice', 'Javert', weight=1)\n    G.add_edge('Scaufflaire', 'Valjean', weight=1)\n    G.add_edge('Woman1', 'Valjean', weight=2)\n    G.add_edge('Woman1', 'Javert', weight=1)\n    G.add_edge('Judge', 'Valjean', weight=3)\n    G.add_edge('Judge', 'Bamatabois', weight=2)\n    G.add_edge('Champmathieu', 'Valjean', weight=3)\n    G.add_edge('Champmathieu', 'Judge', weight=3)\n    G.add_edge('Champmathieu', 'Bamatabois', weight=2)\n    G.add_edge('Brevet', 'Judge', weight=2)\n    G.add_edge('Brevet', 'Champmathieu', weight=2)\n    G.add_edge('Brevet', 'Valjean', weight=2)\n    G.add_edge('Brevet', 'Bamatabois', weight=1)\n    G.add_edge('Chenildieu', 'Judge', weight=2)\n    G.add_edge('Chenildieu', 'Champmathieu', weight=2)\n    G.add_edge('Chenildieu', 'Brevet', weight=2)\n    G.add_edge('Chenildieu', 'Valjean', weight=2)\n    G.add_edge('Chenildieu', 'Bamatabois', weight=1)\n    G.add_edge('Cochepaille', 'Judge', weight=2)\n    G.add_edge('Cochepaille', 'Champmathieu', weight=2)\n    G.add_edge('Cochepaille', 'Brevet', weight=2)\n    G.add_edge('Cochepaille', 'Chenildieu', weight=2)\n    G.add_edge('Cochepaille', 'Valjean', weight=2)\n    G.add_edge('Cochepaille', 'Bamatabois', weight=1)\n    G.add_edge('Pontmercy', 'Thenardier', weight=1)\n    G.add_edge('Boulatruelle', 'Thenardier', weight=1)\n    G.add_edge('Eponine', 'MmeThenardier', weight=2)\n    G.add_edge('Eponine', 'Thenardier', weight=3)\n    G.add_edge('Anzelma', 'Eponine', weight=2)\n    G.add_edge('Anzelma', 'Thenardier', weight=2)\n    G.add_edge('Anzelma', 'MmeThenardier', weight=1)\n    G.add_edge('Woman2', 'Valjean', weight=3)\n    G.add_edge('Woman2', 'Cosette', weight=1)\n    G.add_edge('Woman2', 'Javert', weight=1)\n    G.add_edge('MotherInnocent', 'Fauchelevent', weight=3)\n    G.add_edge('MotherInnocent', 'Valjean', weight=1)\n    G.add_edge('Gribier', 'Fauchelevent', weight=2)\n    G.add_edge('MmeBurgon', 'Jondrette', weight=1)\n    G.add_edge('Gavroche', 'MmeBurgon', weight=2)\n    G.add_edge('Gavroche', 'Thenardier', weight=1)\n    G.add_edge('Gavroche', 'Javert', weight=1)\n    G.add_edge('Gavroche', 'Valjean', weight=1)\n    G.add_edge('Gillenormand', 'Cosette', weight=3)\n    G.add_edge('Gillenormand', 'Valjean', weight=2)\n    G.add_edge('Magnon', 'Gillenormand', weight=1)\n    G.add_edge('Magnon', 'MmeThenardier', weight=1)\n    G.add_edge('MlleGillenormand', 'Gillenormand', weight=9)\n    G.add_edge('MlleGillenormand', 'Cosette', weight=2)\n    G.add_edge('MlleGillenormand', 'Valjean', weight=2)\n    G.add_edge('MmePontmercy', 'MlleGillenormand', weight=1)\n    G.add_edge('MmePontmercy', 'Pontmercy', weight=1)\n    G.add_edge('MlleVaubois', 'MlleGillenormand', weight=1)\n    G.add_edge('LtGillenormand', 'MlleGillenormand', weight=2)\n    G.add_edge('LtGillenormand', 'Gillenormand', weight=1)\n    G.add_edge('LtGillenormand', 'Cosette', weight=1)\n    G.add_edge('Marius', 'MlleGillenormand', weight=6)\n    G.add_edge('Marius', 'Gillenormand', weight=12)\n    G.add_edge('Marius', 'Pontmercy', weight=1)\n    G.add_edge('Marius', 'LtGillenormand', weight=1)\n    G.add_edge('Marius', 'Cosette', weight=21)\n    G.add_edge('Marius', 'Valjean', weight=19)\n    G.add_edge('Marius', 'Tholomyes', weight=1)\n    G.add_edge('Marius', 'Thenardier', weight=2)\n    G.add_edge('Marius', 'Eponine', weight=5)\n    G.add_edge('Marius', 'Gavroche', weight=4)\n    G.add_edge('BaronessT', 'Gillenormand', weight=1)\n    G.add_edge('BaronessT', 'Marius', weight=1)\n    G.add_edge('Mabeuf', 'Marius', weight=1)\n    G.add_edge('Mabeuf', 'Eponine', weight=1)\n    G.add_edge('Mabeuf', 'Gavroche', weight=1)\n    G.add_edge('Enjolras', 'Marius', weight=7)\n    G.add_edge('Enjolras', 'Gavroche', weight=7)\n    G.add_edge('Enjolras', 'Javert', weight=6)\n    G.add_edge('Enjolras', 'Mabeuf', weight=1)\n    G.add_edge('Enjolras', 'Valjean', weight=4)\n    G.add_edge('Combeferre', 'Enjolras', weight=15)\n    G.add_edge('Combeferre', 'Marius', weight=5)\n    G.add_edge('Combeferre', 'Gavroche', weight=6)\n    G.add_edge('Combeferre', 'Mabeuf', weight=2)\n    G.add_edge('Prouvaire', 'Gavroche', weight=1)\n    G.add_edge('Prouvaire', 'Enjolras', weight=4)\n    G.add_edge('Prouvaire', 'Combeferre', weight=2)\n    G.add_edge('Feuilly', 'Gavroche', weight=2)\n    G.add_edge('Feuilly', 'Enjolras', weight=6)\n    G.add_edge('Feuilly', 'Prouvaire', weight=2)\n    G.add_edge('Feuilly', 'Combeferre', weight=5)\n    G.add_edge('Feuilly', 'Mabeuf', weight=1)\n    G.add_edge('Feuilly', 'Marius', weight=1)\n    G.add_edge('Courfeyrac', 'Marius', weight=9)\n    G.add_edge('Courfeyrac', 'Enjolras', weight=17)\n    G.add_edge('Courfeyrac', 'Combeferre', weight=13)\n    G.add_edge('Courfeyrac', 'Gavroche', weight=7)\n    G.add_edge('Courfeyrac', 'Mabeuf', weight=2)\n    G.add_edge('Courfeyrac', 'Eponine', weight=1)\n    G.add_edge('Courfeyrac', 'Feuilly', weight=6)\n    G.add_edge('Courfeyrac', 'Prouvaire', weight=3)\n    G.add_edge('Bahorel', 'Combeferre', weight=5)\n    G.add_edge('Bahorel', 'Gavroche', weight=5)\n    G.add_edge('Bahorel', 'Courfeyrac', weight=6)\n    G.add_edge('Bahorel', 'Mabeuf', weight=2)\n    G.add_edge('Bahorel', 'Enjolras', weight=4)\n    G.add_edge('Bahorel', 'Feuilly', weight=3)\n    G.add_edge('Bahorel', 'Prouvaire', weight=2)\n    G.add_edge('Bahorel', 'Marius', weight=1)\n    G.add_edge('Bossuet', 'Marius', weight=5)\n    G.add_edge('Bossuet', 'Courfeyrac', weight=12)\n    G.add_edge('Bossuet', 'Gavroche', weight=5)\n    G.add_edge('Bossuet', 'Bahorel', weight=4)\n    G.add_edge('Bossuet', 'Enjolras', weight=10)\n    G.add_edge('Bossuet', 'Feuilly', weight=6)\n    G.add_edge('Bossuet', 'Prouvaire', weight=2)\n    G.add_edge('Bossuet', 'Combeferre', weight=9)\n    G.add_edge('Bossuet', 'Mabeuf', weight=1)\n    G.add_edge('Bossuet', 'Valjean', weight=1)\n    G.add_edge('Joly', 'Bahorel', weight=5)\n    G.add_edge('Joly', 'Bossuet', weight=7)\n    G.add_edge('Joly', 'Gavroche', weight=3)\n    G.add_edge('Joly', 'Courfeyrac', weight=5)\n    G.add_edge('Joly', 'Enjolras', weight=5)\n    G.add_edge('Joly', 'Feuilly', weight=5)\n    G.add_edge('Joly', 'Prouvaire', weight=2)\n    G.add_edge('Joly', 'Combeferre', weight=5)\n    G.add_edge('Joly', 'Mabeuf', weight=1)\n    G.add_edge('Joly', 'Marius', weight=2)\n    G.add_edge('Grantaire', 'Bossuet', weight=3)\n    G.add_edge('Grantaire', 'Enjolras', weight=3)\n    G.add_edge('Grantaire', 'Combeferre', weight=1)\n    G.add_edge('Grantaire', 'Courfeyrac', weight=2)\n    G.add_edge('Grantaire', 'Joly', weight=2)\n    G.add_edge('Grantaire', 'Gavroche', weight=1)\n    G.add_edge('Grantaire', 'Bahorel', weight=1)\n    G.add_edge('Grantaire', 'Feuilly', weight=1)\n    G.add_edge('Grantaire', 'Prouvaire', weight=1)\n    G.add_edge('MotherPlutarch', 'Mabeuf', weight=3)\n    G.add_edge('Gueulemer', 'Thenardier', weight=5)\n    G.add_edge('Gueulemer', 'Valjean', weight=1)\n    G.add_edge('Gueulemer', 'MmeThenardier', weight=1)\n    G.add_edge('Gueulemer', 'Javert', weight=1)\n    G.add_edge('Gueulemer', 'Gavroche', weight=1)\n    G.add_edge('Gueulemer', 'Eponine', weight=1)\n    G.add_edge('Babet', 'Thenardier', weight=6)\n    G.add_edge('Babet', 'Gueulemer', weight=6)\n    G.add_edge('Babet', 'Valjean', weight=1)\n    G.add_edge('Babet', 'MmeThenardier', weight=1)\n    G.add_edge('Babet', 'Javert', weight=2)\n    G.add_edge('Babet', 'Gavroche', weight=1)\n    G.add_edge('Babet', 'Eponine', weight=1)\n    G.add_edge('Claquesous', 'Thenardier', weight=4)\n    G.add_edge('Claquesous', 'Babet', weight=4)\n    G.add_edge('Claquesous', 'Gueulemer', weight=4)\n    G.add_edge('Claquesous', 'Valjean', weight=1)\n    G.add_edge('Claquesous', 'MmeThenardier', weight=1)\n    G.add_edge('Claquesous', 'Javert', weight=1)\n    G.add_edge('Claquesous', 'Eponine', weight=1)\n    G.add_edge('Claquesous', 'Enjolras', weight=1)\n    G.add_edge('Montparnasse', 'Javert', weight=1)\n    G.add_edge('Montparnasse', 'Babet', weight=2)\n    G.add_edge('Montparnasse', 'Gueulemer', weight=2)\n    G.add_edge('Montparnasse', 'Claquesous', weight=2)\n    G.add_edge('Montparnasse', 'Valjean', weight=1)\n    G.add_edge('Montparnasse', 'Gavroche', weight=1)\n    G.add_edge('Montparnasse', 'Eponine', weight=1)\n    G.add_edge('Montparnasse', 'Thenardier', weight=1)\n    G.add_edge('Toussaint', 'Cosette', weight=2)\n    G.add_edge('Toussaint', 'Javert', weight=1)\n    G.add_edge('Toussaint', 'Valjean', weight=1)\n    G.add_edge('Child1', 'Gavroche', weight=2)\n    G.add_edge('Child2', 'Gavroche', weight=2)\n    G.add_edge('Child2', 'Child1', weight=3)\n    G.add_edge('Brujon', 'Babet', weight=3)\n    G.add_edge('Brujon', 'Gueulemer', weight=3)\n    G.add_edge('Brujon', 'Thenardier', weight=3)\n    G.add_edge('Brujon', 'Gavroche', weight=1)\n    G.add_edge('Brujon', 'Eponine', weight=1)\n    G.add_edge('Brujon', 'Claquesous', weight=1)\n    G.add_edge('Brujon', 'Montparnasse', weight=1)\n    G.add_edge('MmeHucheloup', 'Bossuet', weight=1)\n    G.add_edge('MmeHucheloup', 'Joly', weight=1)\n    G.add_edge('MmeHucheloup', 'Grantaire', weight=1)\n    G.add_edge('MmeHucheloup', 'Bahorel', weight=1)\n    G.add_edge('MmeHucheloup', 'Courfeyrac', weight=1)\n    G.add_edge('MmeHucheloup', 'Gavroche', weight=1)\n    G.add_edge('MmeHucheloup', 'Enjolras', weight=1)\n    return G"
 },
 {
  "docstring": "Returns a random simple graph with spectrum resembling that of `G`\n\nThis algorithm, called Spectral Graph Forge (SGF), computes the\neigenvectors of a given graph adjacency matrix, filters them and\nbuilds a random graph with a similar eigenstructure.\nSGF has been proved to be particularly useful for synthesizing\nrealistic social networks and it can also be used to anonymize\ngraph sensitive data.\n\nParameters\n----------\nG : Graph\nalpha :  float\n    Ratio representing the percentage of eigenvectors of G to consider,\n    values in [0,1].\ntransformation : string, optional\n    Represents the intended matrix linear transformation, possible values\n    are 'identity' and 'modularity'\nseed : integer, random_state, or None (default)\n    Indicator of numpy random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\nH : Graph\n    A graph with a similar eigenvector structure of the input one.\n\nRaises\n------\nNetworkXError\n    If transformation has a value different from 'identity' or 'modularity'\n\n",
  "code": "@np_random_state(3)\n@nx._dispatch\ndef spectral_graph_forge(G, alpha, transformation='identity', seed=None):\n    import numpy as np\n    import scipy as sp\n    available_transformations = ['identity', 'modularity']\n    alpha = np.clip(alpha, 0, 1)\n    A = nx.to_numpy_array(G)\n    n = A.shape[1]\n    level = round(n * alpha)\n    if transformation not in available_transformations:\n        msg = f'{transformation!r} is not a valid transformation. '\n        msg += f'Transformations: {available_transformations}'\n        raise nx.NetworkXError(msg)\n    K = np.ones((1, n)) @ A\n    B = A\n    if transformation == 'modularity':\n        B -= K.T @ K / K.sum()\n    evals, evecs = np.linalg.eigh(B)\n    k = np.argsort(np.abs(evals))[::-1]\n    evecs[:, k[np.arange(level, n)]] = 0\n    B = evecs @ np.diag(evals) @ evecs.T\n    if transformation == 'modularity':\n        B += K.T @ K / K.sum()\n    B = np.clip(B, 0, 1)\n    np.fill_diagonal(B, 0)\n    for i in range(n - 1):\n        B[i, i + 1:] = sp.stats.bernoulli.rvs(B[i, i + 1:], random_state=seed)\n        B[i + 1:, i] = np.transpose(B[i, i + 1:])\n    H = nx.from_numpy_array(B)\n    return H"
 },
 {
  "docstring": "Returns a right-stochastic representation of directed graph `G`.\n\nA right-stochastic graph is a weighted digraph in which for each\nnode, the sum of the weights of all the out-edges of that node is\n1. If the graph is already weighted (for example, via a 'weight'\nedge attribute), the reweighting takes that into account.\n\nParameters\n----------\nG : directed graph\n    A :class:`~networkx.DiGraph` or :class:`~networkx.MultiDiGraph`.\n\ncopy : boolean, optional\n    If this is True, then this function returns a new graph with\n    the stochastic reweighting. Otherwise, the original graph is\n    modified in-place (and also returned, for convenience).\n\nweight : edge attribute key (optional, default='weight')\n    Edge attribute key used for reading the existing weight and\n    setting the new weight.  If no attribute with this key is found\n    for an edge, then the edge weight is assumed to be 1. If an edge\n    has a weight, it must be a positive number.",
  "code": "@not_implemented_for('undirected')\n@nx._dispatch(edge_attrs='weight')\ndef stochastic_graph(G, copy=True, weight='weight'):\n    if copy:\n        G = MultiDiGraph(G) if G.is_multigraph() else DiGraph(G)\n    degree = dict(G.out_degree(weight=weight))\n    for u, v, d in G.edges(data=True):\n        if degree[u] == 0:\n            d[weight] = 0\n        else:\n            d[weight] = d.get(weight, 1) / degree[u]\n    return G"
 },
 {
  "docstring": "Returns the n-Sudoku graph. The default value of n is 3.\n\nThe n-Sudoku graph is a graph with n^4 vertices, corresponding to the\ncells of an n^2 by n^2 grid. Two distinct vertices are adjacent if and\nonly if they belong to the same row, column, or n-by-n box.\n\nParameters\n----------\nn: integer\n   The order of the Sudoku graph, equal to the square root of the\n   number of rows. The default is 3.\n\nReturns\n-------\nNetworkX graph\n    The n-Sudoku graph Sud(n).\n\nExamples\n--------\n>>> G = nx.sudoku_graph()\n>>> G.number_of_nodes()\n81\n>>> G.number_of_edges()\n810\n>>> sorted(G.neighbors(42))\n[6, 15, 24, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 51, 52, 53, 60, 69, 78]\n>>> G = nx.sudoku_graph(2)\n>>> G.number_of_nodes()\n16\n>>> G.number_of_edges()\n56\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef sudoku_graph(n=3):\n    if n < 0:\n        raise NetworkXError('The order must be greater than or equal to zero.')\n    n2 = n * n\n    n3 = n2 * n\n    n4 = n3 * n\n    G = nx.empty_graph(n4)\n    if n < 2:\n        return G\n    for row_no in range(n2):\n        row_start = row_no * n2\n        for j in range(1, n2):\n            for i in range(j):\n                G.add_edge(row_start + i, row_start + j)\n    for col_no in range(n2):\n        for j in range(col_no, n4, n2):\n            for i in range(col_no, j, n2):\n                G.add_edge(i, j)\n    for band_no in range(n):\n        for stack_no in range(n):\n            box_start = n3 * band_no + n * stack_no\n            for j in range(1, n2):\n                for i in range(j):\n                    u = box_start + i % n + n2 * (i // n)\n                    v = box_start + j % n + n2 * (j // n)\n                    G.add_edge(u, v)\n    return G"
 },
 {
  "docstring": "Return a Visibility Graph of an input Time Series.\n\nA visibility graph converts a time series into a graph. The constructed graph\nuses integer nodes to indicate which event in the series the node represents.\nEdges are formed as follows: consider a bar plot of the series and view that\nas a side view of a landscape with a node at the top of each bar. An edge\nmeans that the nodes can be connected by a straight \"line-of-sight\" without\nbeing obscured by any bars between the nodes.\n\nThe resulting graph inherits several properties of the series in its structure.\nThereby, periodic series convert into regular graphs, random series convert\ninto random graphs, and fractal series convert into scale-free networks [1]_.\n\nParameters\n----------\nseries : Sequence[Number]\n   A Time Series sequence (iterable and sliceable) of numeric values\n   representing times.\n\nReturns\n-------\nNetworkX Graph\n    The Visibility Graph of the input series\n\nExamples\n--------\n>>> series_list = [range(10), [2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1, 3]]\n>>> for s in series_list:\n...     g = nx.visibility_graph(s)\n...     print(g)\nGraph with 10 nodes and 9 edges\nGraph with 12 nodes and 18 edges\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef visibility_graph(series):\n    G = nx.path_graph(len(series))\n    nx.set_node_attributes(G, dict(enumerate(series)), 'value')\n    for (n1, t1), (n2, t2) in itertools.combinations(enumerate(series), 2):\n        slope = (t2 - t1) / (n2 - n1)\n        offset = t2 - slope * n2\n        obstructed = any((t >= slope * n + offset for n, t in enumerate(series[n1 + 1:n2], start=n1 + 1)))\n        if not obstructed:\n            G.add_edge(n1, n2)\n    return G"
 },
 {
  "docstring": "Creates a directed prefix tree from a list of paths.\n\nUsually the paths are described as strings or lists of integers.\n\nA \"prefix tree\" represents the prefix structure of the strings.\nEach node represents a prefix of some string. The root represents\nthe empty prefix with children for the single letter prefixes which\nin turn have children for each double letter prefix starting with\nthe single letter corresponding to the parent node, and so on.\n\nMore generally the prefixes do not need to be strings. A prefix refers\nto the start of a sequence. The root has children for each one element\nprefix and they have children for each two element prefix that starts\nwith the one element sequence of the parent, and so on.\n\nNote that this implementation uses integer nodes with an attribute.\nEach node has an attribute \"source\" whose value is the original element\nof the path to which this node corresponds. For example, suppose `paths`\nconsists of one path: \"can\". Then the nodes `[1, 2, 3]` which represent\nthis path have \"source\" values \"c\", \"a\" and \"n\".\n\nAll the descendants of a node have a common prefix in the sequence/path\nassociated with that node. From the returned tree, the prefix for each\nnode can be constructed by traversing the tree up to the root and\naccumulating the \"source\" values along the way.\n\nThe root node is always `0` and has \"source\" attribute `None`.\nThe root is the only node with in-degree zero.\nThe nil node is always `-1` and has \"source\" attribute `\"NIL\"`.\nThe nil node is the only node with out-degree zero.\n\n\nParameters\n----------\npaths: iterable of paths\n    An iterable of paths which are themselves sequences.\n    Matching prefixes among these sequences are identified with\n    nodes of the prefix tree. One leaf of the tree is associated\n    with each path. (Identical paths are associated with the same\n    leaf of the tree.)\n\n\nReturns\n-------\ntree: DiGraph\n    A directed graph representing an arborescence consisting of the\n    prefix tree generated by `paths`. Nodes are directed \"downward\",\n    from parent to child. A special \"synthetic\" root node is added\n    to be the parent of the first node in each path. A special\n    \"synthetic\" leaf node, the \"nil\" node `-1`, is added to be the child\n    of all nodes representing the last element in a path. (The\n    addition of this nil node technically makes this not an\n    arborescence but a directed acyclic graph; removing the nil node\n    makes it an arborescence.)\n\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef prefix_tree(paths):\n\n    def get_children(parent, paths):\n        children = defaultdict(list)\n        for path in paths:\n            if not path:\n                tree.add_edge(parent, NIL)\n                continue\n            child, *rest = path\n            children[child].append(rest)\n        return children\n    tree = nx.DiGraph()\n    root = 0\n    tree.add_node(root, source=None)\n    NIL = -1\n    tree.add_node(NIL, source='NIL')\n    children = get_children(root, paths)\n    stack = [(root, iter(children.items()))]\n    while stack:\n        parent, remaining_children = stack[-1]\n        try:\n            child, remaining_paths = next(remaining_children)\n        except StopIteration:\n            stack.pop()\n            continue\n        new_name = len(tree) - 1\n        tree.add_node(new_name, source=child)\n        tree.add_edge(parent, new_name)\n        children = get_children(new_name, remaining_paths)\n        stack.append((new_name, iter(children.items())))\n    return tree"
 },
 {
  "docstring": "Recursively creates a directed prefix tree from a list of paths.\n\nThe original recursive version of prefix_tree for comparison. It is\nthe same algorithm but the recursion is unrolled onto a stack.\n\nUsually the paths are described as strings or lists of integers.\n\nA \"prefix tree\" represents the prefix structure of the strings.\nEach node represents a prefix of some string. The root represents\nthe empty prefix with children for the single letter prefixes which\nin turn have children for each double letter prefix starting with\nthe single letter corresponding to the parent node, and so on.\n\nMore generally the prefixes do not need to be strings. A prefix refers\nto the start of a sequence. The root has children for each one element\nprefix and they have children for each two element prefix that starts\nwith the one element sequence of the parent, and so on.\n\nNote that this implementation uses integer nodes with an attribute.\nEach node has an attribute \"source\" whose value is the original element\nof the path to which this node corresponds. For example, suppose `paths`\nconsists of one path: \"can\". Then the nodes `[1, 2, 3]` which represent\nthis path have \"source\" values \"c\", \"a\" and \"n\".\n\nAll the descendants of a node have a common prefix in the sequence/path\nassociated with that node. From the returned tree, ehe prefix for each\nnode can be constructed by traversing the tree up to the root and\naccumulating the \"source\" values along the way.\n\nThe root node is always `0` and has \"source\" attribute `None`.\nThe root is the only node with in-degree zero.\nThe nil node is always `-1` and has \"source\" attribute `\"NIL\"`.\nThe nil node is the only node with out-degree zero.\n\n\nParameters\n----------\npaths: iterable of paths\n    An iterable of paths which are themselves sequences.\n    Matching prefixes among these sequences are identified with\n    nodes of the prefix tree. One leaf of the tree is associated\n    with each path. (Identical paths are associated with the same\n    leaf of the tree.)\n\n\nReturns\n-------\ntree: DiGraph\n    A directed graph representing an arborescence consisting of the\n    prefix tree generated by `paths`. Nodes are directed \"downward\",\n    from parent to child. A special \"synthetic\" root node is added\n    to be the parent of the first node in each path. A special\n    \"synthetic\" leaf node, the \"nil\" node `-1`, is added to be the child\n    of all nodes representing the last element in a path. (The\n    addition of this nil node technically makes this not an\n    arborescence but a directed acyclic graph; removing the nil node\n    makes it an arborescence.)\n\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef prefix_tree_recursive(paths):\n\n    def _helper(paths, root, tree):\n        \"\"\"Recursively create a trie from the given list of paths.\n\n        `paths` is a list of paths, each of which is itself a list of\n        nodes, relative to the given `root` (but not including it). This\n        list of paths will be interpreted as a tree-like structure, in\n        which two paths that share a prefix represent two branches of\n        the tree with the same initial segment.\n\n        `root` is the parent of the node at index 0 in each path.\n\n        `tree` is the \"accumulator\", the :class:`networkx.DiGraph`\n        representing the branching to which the new nodes and edges will\n        be added.\n\n        \"\"\"\n        children = defaultdict(list)\n        for path in paths:\n            if not path:\n                tree.add_edge(root, NIL)\n                continue\n            child, *rest = path\n            children[child].append(rest)\n        for child, remaining_paths in children.items():\n            new_name = len(tree) - 1\n            tree.add_node(new_name, source=child)\n            tree.add_edge(root, new_name)\n            _helper(remaining_paths, new_name, tree)\n    tree = nx.DiGraph()\n    root = 0\n    tree.add_node(root, source=None)\n    NIL = -1\n    tree.add_node(NIL, source='NIL')\n    _helper(paths, root, tree)\n    return tree"
 },
 {
  "docstring": "Returns a uniformly random tree on `n` nodes.\n\n.. deprecated:: 3.2\n\n   ``random_tree`` is deprecated and will be removed in NX v3.4\n   Use ``random_labeled_tree`` instead.\n\nParameters\n----------\nn : int\n    A positive integer representing the number of nodes in the tree.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n    Graph type to create. If graph instance, then cleared before populated.\n\nReturns\n-------\nNetworkX graph\n    A tree, given as an undirected graph, whose nodes are numbers in\n    the set {0, \u2026, *n* - 1}.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `n` is zero (because the null graph is not a tree).\n\n",
  "code": "@py_random_state(1)\n@nx._dispatch(graphs=None)\ndef random_tree(n, seed=None, create_using=None):\n    warnings.warn('\\n\\nrandom_tree is deprecated and will be removed in NX v3.4\\nUse random_labeled_tree instead.', DeprecationWarning, stacklevel=2)\n    if n == 0:\n        raise nx.NetworkXPointlessConcept('the null graph is not a tree')\n    if n == 1:\n        utree = nx.empty_graph(1, create_using)\n    else:\n        sequence = [seed.choice(range(n)) for i in range(n - 2)]\n        utree = nx.from_prufer_sequence(sequence)\n    if create_using is None:\n        tree = utree\n    else:\n        tree = nx.empty_graph(0, create_using)\n        if tree.is_directed():\n            edges = nx.dfs_edges(utree, source=0)\n        else:\n            edges = utree.edges\n        tree.add_nodes_from(utree.nodes)\n        tree.add_edges_from(edges)\n    return tree"
 },
 {
  "docstring": "Returns a labeled tree on `n` nodes chosen uniformly at random.\n\nGenerating uniformly distributed random Pr\u00fcfer sequences and\nconverting them into the corresponding trees is a straightforward\nmethod of generating uniformly distributed random labeled trees.\nThis function implements this method.\n\nParameters\n----------\nn : int\n    The number of nodes, greater than zero.\nseed : random_state\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`\n\nReturns\n-------\n :class:`networkx.Graph`\n    A `networkx.Graph` with nodes in the set {0, \u2026, *n* - 1}.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `n` is zero (because the null graph is not a tree).",
  "code": "@py_random_state('seed')\n@nx._dispatch(graphs=None)\ndef random_labeled_tree(n, *, seed=None):\n    if n == 0:\n        raise nx.NetworkXPointlessConcept('the null graph is not a tree')\n    if n == 1:\n        return nx.empty_graph(1)\n    return nx.from_prufer_sequence([seed.choice(range(n)) for i in range(n - 2)])"
 },
 {
  "docstring": "Returns a labeled rooted tree with `n` nodes.\n\nThe returned tree is chosen uniformly at random from all labeled rooted trees.\n\nParameters\n----------\nn : int\n    The number of nodes\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph`\n    A `networkx.Graph` with integer nodes 0 <= node <= `n` - 1.\n    The root of the tree is selected uniformly from the nodes.\n    The \"root\" graph attribute identifies the root of the tree.\n\n",
  "code": "@py_random_state('seed')\n@nx._dispatch(graphs=None)\ndef random_labeled_rooted_tree(n, *, seed=None):\n    t = random_labeled_tree(n, seed=seed)\n    t.graph['root'] = seed.randint(0, n - 1)\n    return t"
 },
 {
  "docstring": "Returns a labeled rooted forest with `n` nodes.\n\nThe returned forest is chosen uniformly at random using a\ngeneralization of Pr\u00fcfer sequences [1]_ in the form described in [2]_.\n\nParameters\n----------\nn : int\n    The number of nodes.\nseed : random_state\n   See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph`\n    A `networkx.Graph` with integer nodes 0 <= node <= `n` - 1.\n    The \"roots\" graph attribute is a set of integers containing the roots.\n\n",
  "code": "@py_random_state('seed')\n@nx._dispatch(graphs=None)\ndef random_labeled_rooted_forest(n, *, seed=None):\n\n    def _select_k(n, seed):\n        r = seed.randint(0, (n + 1) ** (n - 1) - 1)\n        cum_sum = 0\n        for k in range(1, n):\n            cum_sum += factorial(n - 1) * n ** (n - k) // (factorial(k - 1) * factorial(n - k))\n            if r < cum_sum:\n                return k\n        return n\n    F = nx.empty_graph(n)\n    if n == 0:\n        F.graph['roots'] = {}\n        return F\n    k = _select_k(n, seed)\n    if k == n:\n        F.graph['roots'] = set(range(n))\n        return F\n    roots = seed.sample(range(n), k)\n    p = set(range(n)).difference(roots)\n    N = [seed.randint(0, n - 1) for i in range(n - k - 1)]\n    degree = Counter([x for x in N if x in p])\n    iterator = iter((x for x in p if degree[x] == 0))\n    u = last = next(iterator)\n    for v in N:\n        F.add_edge(u, v)\n        degree[v] -= 1\n        if v < last and degree[v] == 0:\n            u = v\n        else:\n            last = u = next(iterator)\n    F.add_edge(u, roots[0])\n    F.graph['roots'] = set(roots)\n    return F"
 },
 {
  "docstring": "Converts the (edges, n_nodes) input to a :class:`networkx.Graph`.\nThe (edges, n_nodes) input is a list of even length, where each pair\nof consecutive integers represents an edge, and an integer `n_nodes`.\nIntegers in the list are elements of `range(n_nodes)`.\n\nParameters\n----------\nedges : list of ints\n    The flattened list of edges of the graph.\nn_nodes : int\n    The number of nodes of the graph.\nroot: int (default=None)\n    If not None, the \"root\" attribute of the graph will be set to this value.\nroots: collection of ints (default=None)\n    If not None, he \"roots\" attribute of the graph will be set to this value.\n\nReturns\n-------\n:class:`networkx.Graph`\n    The graph with `n_nodes` nodes and edges given by `edges`.",
  "code": "def _to_nx(edges, n_nodes, root=None, roots=None):\n    G = nx.empty_graph(n_nodes)\n    G.add_edges_from(edges)\n    if root is not None:\n        G.graph['root'] = root\n    if roots is not None:\n        G.graph['roots'] = roots\n    return G"
 },
 {
  "docstring": "Returns the number of unlabeled rooted trees with `n` nodes.\n\nSee also https://oeis.org/A000081.\n\nParameters\n----------\nn : int\n    The number of nodes\ncache_trees : list of ints\n    The $i$-th element is the number of unlabeled rooted trees with $i$ nodes,\n    which is used as a cache (and is extended to length $n+1$ if needed)\n\nReturns\n-------\nint\n    The number of unlabeled rooted trees with `n` nodes.",
  "code": "def _num_rooted_trees(n, cache_trees):\n    for n_i in range(len(cache_trees), n + 1):\n        cache_trees.append(sum([d * cache_trees[n_i - j * d] * cache_trees[d] for d in range(1, n_i) for j in range(1, (n_i - 1) // d + 1)]) // (n_i - 1))\n    return cache_trees[n]"
 },
 {
  "docstring": "Returns a pair $(j,d)$ with a specific probability\n\nGiven $n$, returns a pair of positive integers $(j,d)$ with the probability\nspecified in formula (5) of Chapter 29 of [1]_.\n\nParameters\n----------\nn : int\n    The number of nodes\ncache_trees : list of ints\n    Cache for :func:`_num_rooted_trees`.\nseed : random_state\n   See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n(int, int)\n    A pair of positive integers $(j,d)$ satisfying formula (5) of\n    Chapter 29 of [1]_.\n\n",
  "code": "def _select_jd_trees(n, cache_trees, seed):\n    p = seed.randint(0, _num_rooted_trees(n, cache_trees) * (n - 1) - 1)\n    cumsum = 0\n    for d in range(n - 1, 0, -1):\n        for j in range(1, (n - 1) // d + 1):\n            cumsum += d * _num_rooted_trees(n - j * d, cache_trees) * _num_rooted_trees(d, cache_trees)\n            if p < cumsum:\n                return (j, d)"
 },
 {
  "docstring": "Returns an unlabeled rooted tree with `n` nodes.\n\nReturns an unlabeled rooted tree with `n` nodes chosen uniformly\nat random using the \"RANRUT\" algorithm from [1]_.\nThe tree is returned in the form: (list_of_edges, number_of_nodes)\n\nParameters\n----------\nn : int\n    The number of nodes, greater than zero.\ncache_trees : list ints\n    Cache for :func:`_num_rooted_trees`.\nseed : random_state\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n(list_of_edges, number_of_nodes) : list, int\n    A random unlabeled rooted tree with `n` nodes as a 2-tuple\n    ``(list_of_edges, number_of_nodes)``.\n    The root is node 0.\n\n",
  "code": "def _random_unlabeled_rooted_tree(n, cache_trees, seed):\n    if n == 1:\n        edges, n_nodes = ([], 1)\n        return (edges, n_nodes)\n    if n == 2:\n        edges, n_nodes = ([(0, 1)], 2)\n        return (edges, n_nodes)\n    j, d = _select_jd_trees(n, cache_trees, seed)\n    t1, t1_nodes = _random_unlabeled_rooted_tree(n - j * d, cache_trees, seed)\n    t2, t2_nodes = _random_unlabeled_rooted_tree(d, cache_trees, seed)\n    t12 = [(0, t2_nodes * i + t1_nodes) for i in range(j)]\n    t1.extend(t12)\n    for _ in range(j):\n        t1.extend(((n1 + t1_nodes, n2 + t1_nodes) for n1, n2 in t2))\n        t1_nodes += t2_nodes\n    return (t1, t1_nodes)"
 },
 {
  "docstring": "Returns a number of unlabeled rooted trees uniformly at random\n\nReturns one or more (depending on `number_of_trees`)\nunlabeled rooted trees with `n` nodes drawn uniformly\nat random.\n\nParameters\n----------\nn : int\n    The number of nodes\nnumber_of_trees : int or None (default)\n    If not None, this number of trees is generated and returned.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph` or list of :class:`networkx.Graph`\n    A single `networkx.Graph` (or a list thereof, if `number_of_trees`\n    is specified) with nodes in the set {0, \u2026, *n* - 1}.\n    The \"root\" graph attribute identifies the root of the tree.\n\n",
  "code": "@py_random_state('seed')\n@nx._dispatch(graphs=None)\ndef random_unlabeled_rooted_tree(n, *, number_of_trees=None, seed=None):\n    if n == 0:\n        raise nx.NetworkXPointlessConcept('the null graph is not a tree')\n    cache_trees = [0, 1]\n    if number_of_trees is None:\n        return _to_nx(*_random_unlabeled_rooted_tree(n, cache_trees, seed), root=0)\n    return [_to_nx(*_random_unlabeled_rooted_tree(n, cache_trees, seed), root=0) for i in range(number_of_trees)]"
 },
 {
  "docstring": "Returns the number of unlabeled rooted forests with `n` nodes, and with\nno more than `q` nodes per tree. A recursive formula for this is (2) in\n[1]_. This function is implemented using dynamic programming instead of\nrecursion.\n\nParameters\n----------\nn : int\n    The number of nodes.\nq : int\n    The maximum number of nodes for each tree of the forest.\ncache_forests : list of ints\n    The $i$-th element is the number of unlabeled rooted forests with\n    $i$ nodes, and with no more than `q` nodes per tree; this is used\n    as a cache (and is extended to length `n` + 1 if needed).\n\nReturns\n-------\nint\n    The number of unlabeled rooted forests with `n` nodes with no more than\n    `q` nodes per tree.\n\n",
  "code": "def _num_rooted_forests(n, q, cache_forests):\n    for n_i in range(len(cache_forests), n + 1):\n        q_i = min(n_i, q)\n        cache_forests.append(sum([d * cache_forests[n_i - j * d] * cache_forests[d - 1] for d in range(1, q_i + 1) for j in range(1, n_i // d + 1)]) // n_i)\n    return cache_forests[n]"
 },
 {
  "docstring": "Given `n` and `q`, returns a pair of positive integers $(j,d)$\nsuch that $j\\leq d$, with probability satisfying (F1) of [1]_.\n\nParameters\n----------\nn : int\n    The number of nodes.\nq : int\n    The maximum number of nodes for each tree of the forest.\ncache_forests : list of ints\n    Cache for :func:`_num_rooted_forests`.\nseed : random_state\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n(int, int)\n    A pair of positive integers $(j,d)$\n\n",
  "code": "def _select_jd_forests(n, q, cache_forests, seed):\n    p = seed.randint(0, _num_rooted_forests(n, q, cache_forests) * n - 1)\n    cumsum = 0\n    for d in range(q, 0, -1):\n        for j in range(1, n // d + 1):\n            cumsum += d * _num_rooted_forests(n - j * d, q, cache_forests) * _num_rooted_forests(d - 1, q, cache_forests)\n            if p < cumsum:\n                return (j, d)"
 },
 {
  "docstring": "Returns an unlabeled rooted forest with `n` nodes, and with no more\nthan `q` nodes per tree, drawn uniformly at random. It is an implementation\nof the algorithm \"Forest\" of [1]_.\n\nParameters\n----------\nn : int\n    The number of nodes.\nq : int\n    The maximum number of nodes per tree.\ncache_trees :\n    Cache for :func:`_num_rooted_trees`.\ncache_forests :\n    Cache for :func:`_num_rooted_forests`.\nseed : random_state\n   See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n(edges, n, r) : (list, int, list)\n    The forest (edges, n) and a list r of root nodes.\n\n",
  "code": "def _random_unlabeled_rooted_forest(n, q, cache_trees, cache_forests, seed):\n    if n == 0:\n        return ([], 0, [])\n    j, d = _select_jd_forests(n, q, cache_forests, seed)\n    t1, t1_nodes, r1 = _random_unlabeled_rooted_forest(n - j * d, q, cache_trees, cache_forests, seed)\n    t2, t2_nodes = _random_unlabeled_rooted_tree(d, cache_trees, seed)\n    for _ in range(j):\n        r1.append(t1_nodes)\n        t1.extend(((n1 + t1_nodes, n2 + t1_nodes) for n1, n2 in t2))\n        t1_nodes += t2_nodes\n    return (t1, t1_nodes, r1)"
 },
 {
  "docstring": "Returns a forest or list of forests selected at random.\n\nReturns one or more (depending on `number_of_forests`)\nunlabeled rooted forests with `n` nodes, and with no more than\n`q` nodes per tree, drawn uniformly at random.\nThe \"roots\" graph attribute identifies the roots of the forest.\n\nParameters\n----------\nn : int\n    The number of nodes\nq : int or None (default)\n    The maximum number of nodes per tree.\nnumber_of_forests : int or None (default)\n    If not None, this number of forests is generated and returned.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph` or list of :class:`networkx.Graph`\n    A single `networkx.Graph` (or a list thereof, if `number_of_forests`\n    is specified) with nodes in the set {0, \u2026, *n* - 1}.\n    The \"roots\" graph attribute is a set containing the roots\n    of the trees in the forest.\n\n",
  "code": "@py_random_state('seed')\n@nx._dispatch(graphs=None)\ndef random_unlabeled_rooted_forest(n, *, q=None, number_of_forests=None, seed=None):\n    if q is None:\n        q = n\n    if q == 0 and n != 0:\n        raise ValueError('q must be a positive integer if n is positive.')\n    cache_trees = [0, 1]\n    cache_forests = [1]\n    if number_of_forests is None:\n        g, nodes, rs = _random_unlabeled_rooted_forest(n, q, cache_trees, cache_forests, seed)\n        return _to_nx(g, nodes, roots=set(rs))\n    res = []\n    for i in range(number_of_forests):\n        g, nodes, rs = _random_unlabeled_rooted_forest(n, q, cache_trees, cache_forests, seed)\n        res.append(_to_nx(g, nodes, roots=set(rs)))\n    return res"
 },
 {
  "docstring": "Returns the number of unlabeled trees with `n` nodes.\n\nSee also https://oeis.org/A000055.\n\nParameters\n----------\nn : int\n    The number of nodes.\ncache_trees : list of ints\n    Cache for :func:`_num_rooted_trees`.\n\nReturns\n-------\nint\n    The number of unlabeled trees with `n` nodes.",
  "code": "def _num_trees(n, cache_trees):\n    r = _num_rooted_trees(n, cache_trees) - sum([_num_rooted_trees(j, cache_trees) * _num_rooted_trees(n - j, cache_trees) for j in range(1, n // 2 + 1)])\n    if n % 2 == 0:\n        r += comb(_num_rooted_trees(n // 2, cache_trees) + 1, 2)\n    return r"
 },
 {
  "docstring": "Returns a bi-centroidal tree on `n` nodes drawn uniformly at random.\n\nThis function implements the algorithm Bicenter of [1]_.\n\nParameters\n----------\nn : int\n    The number of nodes (must be even).\ncache : list of ints.\n    Cache for :func:`_num_rooted_trees`.\nseed : random_state\n    See :ref:`Randomness<randomness>`\n\nReturns\n-------\n(edges, n)\n    The tree as a list of edges and number of nodes.\n\n",
  "code": "def _bicenter(n, cache, seed):\n    t, t_nodes = _random_unlabeled_rooted_tree(n // 2, cache, seed)\n    if seed.randint(0, _num_rooted_trees(n // 2, cache)) == 0:\n        t2, t2_nodes = (t, t_nodes)\n    else:\n        t2, t2_nodes = _random_unlabeled_rooted_tree(n // 2, cache, seed)\n    t.extend([(n1 + n // 2, n2 + n // 2) for n1, n2 in t2])\n    t.append((0, n // 2))\n    return (t, t_nodes + t2_nodes)"
 },
 {
  "docstring": "Returns a tree on `n` nodes drawn uniformly at random.\nIt implements the Wilf's algorithm \"Free\" of [1]_.\n\nParameters\n----------\nn : int\n    The number of nodes, greater than zero.\ncache_trees : list of ints\n    Cache for :func:`_num_rooted_trees`.\ncache_forests : list of ints\n    Cache for :func:`_num_rooted_forests`.\nseed : random_state\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`\n\nReturns\n-------\n(edges, n)\n    The tree as a list of edges and number of nodes.\n\n",
  "code": "def _random_unlabeled_tree(n, cache_trees, cache_forests, seed):\n    if n % 2 == 1:\n        p = 0\n    else:\n        p = comb(_num_rooted_trees(n // 2, cache_trees) + 1, 2)\n    if seed.randint(0, _num_trees(n, cache_trees) - 1) < p:\n        return _bicenter(n, cache_trees, seed)\n    else:\n        f, n_f, r = _random_unlabeled_rooted_forest(n - 1, (n - 1) // 2, cache_trees, cache_forests, seed)\n        for i in r:\n            f.append((i, n_f))\n        return (f, n_f + 1)"
 },
 {
  "docstring": "Returns a tree or list of trees chosen randomly.\n\nReturns one or more (depending on `number_of_trees`)\nunlabeled trees with `n` nodes drawn uniformly at random.\n\nParameters\n----------\nn : int\n    The number of nodes\nnumber_of_trees : int or None (default)\n    If not None, this number of trees is generated and returned.\nseed : integer, random_state, or None (default)\n    Indicator of random number generation state.\n    See :ref:`Randomness<randomness>`.\n\nReturns\n-------\n:class:`networkx.Graph` or list of :class:`networkx.Graph`\n    A single `networkx.Graph` (or a list thereof, if\n    `number_of_trees` is specified) with nodes in the set {0, \u2026, *n* - 1}.\n\nRaises\n------\nNetworkXPointlessConcept\n    If `n` is zero (because the null graph is not a tree).\n\n",
  "code": "@py_random_state('seed')\n@nx._dispatch(graphs=None)\ndef random_unlabeled_tree(n, *, number_of_trees=None, seed=None):\n    if n == 0:\n        raise nx.NetworkXPointlessConcept('the null graph is not a tree')\n    cache_trees = [0, 1]\n    cache_forests = [1]\n    if number_of_trees is None:\n        return _to_nx(*_random_unlabeled_tree(n, cache_trees, cache_forests, seed))\n    else:\n        return [_to_nx(*_random_unlabeled_tree(n, cache_trees, cache_forests, seed)) for i in range(number_of_trees)]"
 },
 {
  "docstring": "Recursively create a trie from the given list of paths.\n\n`paths` is a list of paths, each of which is itself a list of\nnodes, relative to the given `root` (but not including it). This\nlist of paths will be interpreted as a tree-like structure, in\nwhich two paths that share a prefix represent two branches of\nthe tree with the same initial segment.\n\n`root` is the parent of the node at index 0 in each path.\n\n`tree` is the \"accumulator\", the :class:`networkx.DiGraph`\nrepresenting the branching to which the new nodes and edges will\nbe added.",
  "code": "def _helper(paths, root, tree):\n    children = defaultdict(list)\n    for path in paths:\n        if not path:\n            tree.add_edge(root, NIL)\n            continue\n        child, *rest = path\n        children[child].append(rest)\n    for child, remaining_paths in children.items():\n        new_name = len(tree) - 1\n        tree.add_node(new_name, source=child)\n        tree.add_edge(root, new_name)\n        _helper(remaining_paths, new_name, tree)"
 },
 {
  "docstring": "Returns the triad graph with the given name.\n\nEach string in the following tuple is a valid triad name::\n\n    ('003', '012', '102', '021D', '021U', '021C', '111D', '111U',\n     '030T', '030C', '201', '120D', '120U', '120C', '210', '300')\n\nEach triad name corresponds to one of the possible valid digraph on\nthree nodes.\n\nParameters\n----------\ntriad_name : string\n    The name of a triad, as described above.\n\nReturns\n-------\n:class:`~networkx.DiGraph`\n    The digraph on three nodes with the given name. The nodes of the\n    graph are the single-character strings 'a', 'b', and 'c'.\n\nRaises\n------\nValueError\n    If `triad_name` is not the name of a triad.\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef triad_graph(triad_name):\n    if triad_name not in TRIAD_EDGES:\n        raise ValueError(f'unknown triad name \"{triad_name}\"; use one of the triad names in the TRIAD_NAMES constant')\n    G = DiGraph()\n    G.add_nodes_from('abc')\n    G.add_edges_from(TRIAD_EDGES[triad_name])\n    return G"
 },
 {
  "docstring": "Tests that the balanced tree with branching factor one is the\npath graph.",
  "code": "def test_balanced_tree_path(self):\n    T = nx.balanced_tree(1, 4)\n    P = nx.path_graph(5)\n    assert is_isomorphic(T, P)"
 },
 {
  "docstring": "Tests that the complete 0-partite graph is the null graph.",
  "code": "def test_complete_0_partite_graph(self):\n    G = nx.complete_multipartite_graph()\n    H = nx.null_graph()\n    assert nodes_equal(G, H)\n    assert edges_equal(G.edges(), H.edges())"
 },
 {
  "docstring": "Tests that the complete 1-partite graph is the empty graph.",
  "code": "def test_complete_1_partite_graph(self):\n    G = nx.complete_multipartite_graph(3)\n    H = nx.empty_graph(3)\n    assert nodes_equal(G, H)\n    assert edges_equal(G.edges(), H.edges())"
 },
 {
  "docstring": "Tests that the complete 2-partite graph is the complete bipartite\ngraph.",
  "code": "def test_complete_2_partite_graph(self):\n    G = nx.complete_multipartite_graph(2, 3)\n    H = nx.complete_bipartite_graph(2, 3)\n    assert nodes_equal(G, H)\n    assert edges_equal(G.edges(), H.edges())"
 },
 {
  "docstring": "Tests for generating the complete multipartite graph.",
  "code": "def test_complete_multipartite_graph(self):\n    G = nx.complete_multipartite_graph(2, 3, 4)\n    blocks = [(0, 1), (2, 3, 4), (5, 6, 7, 8)]\n    for block in blocks:\n        for u, v in itertools.combinations_with_replacement(block, 2):\n            assert v not in G[u]\n            assert G.nodes[u] == G.nodes[v]\n    for block1, block2 in itertools.combinations(blocks, 2):\n        for u, v in itertools.product(block1, block2):\n            assert v in G[u]\n            assert G.nodes[u] != G.nodes[v]\n    with pytest.raises(nx.NetworkXError, match='Negative number of nodes'):\n        nx.complete_multipartite_graph(2, -3, 4)"
 },
 {
  "docstring": "Tests that an empty degree sequence yields the null graph.",
  "code": "def test_empty_degree_sequence(self):\n    G = nx.configuration_model([])\n    assert len(G) == 0"
 },
 {
  "docstring": "Tests that a degree sequence of all zeros yields the empty\ngraph.",
  "code": "def test_degree_zero(self):\n    G = nx.configuration_model([0, 0, 0])\n    assert len(G) == 3\n    assert G.number_of_edges() == 0"
 },
 {
  "docstring": "Tests that the degree sequence of the generated graph matches\nthe input degree sequence.",
  "code": "def test_degree_sequence(self):\n    deg_seq = [5, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1]\n    G = nx.configuration_model(deg_seq, seed=12345678)\n    assert sorted((d for n, d in G.degree()), reverse=True) == [5, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1]\n    assert sorted((d for n, d in G.degree(range(len(deg_seq)))), reverse=True) == [5, 3, 3, 3, 3, 2, 2, 2, 1, 1, 1]"
 },
 {
  "docstring": "Tests that each call with the same random seed generates the\nsame graph.",
  "code": "def test_random_seed(self):\n    deg_seq = [3] * 12\n    G1 = nx.configuration_model(deg_seq, seed=1000)\n    G2 = nx.configuration_model(deg_seq, seed=1000)\n    assert nx.is_isomorphic(G1, G2)\n    G1 = nx.configuration_model(deg_seq, seed=10)\n    G2 = nx.configuration_model(deg_seq, seed=10)\n    assert nx.is_isomorphic(G1, G2)"
 },
 {
  "docstring": "Tests that attempting to create a configuration model graph\nusing a directed graph yields an exception.",
  "code": "def test_directed_disallowed(self):\n    with pytest.raises(nx.NetworkXNotImplemented):\n        nx.configuration_model([], create_using=nx.DiGraph())"
 },
 {
  "docstring": "Tests that a degree sequence whose sum is odd yields an\nexception.",
  "code": "def test_odd_degree_sum(self):\n    with pytest.raises(nx.NetworkXError):\n        nx.configuration_model([1, 2])"
 },
 {
  "docstring": "Tests that the generated graph is `k`-out-regular.",
  "code": "def test_regularity(self):\n    n = 10\n    k = 3\n    alpha = 1\n    G = random_k_out_graph(n, k, alpha)\n    assert all((d == k for v, d in G.out_degree()))\n    G = random_k_out_graph(n, k, alpha, seed=42)\n    assert all((d == k for v, d in G.out_degree()))"
 },
 {
  "docstring": "Tests for forbidding self-loops.",
  "code": "def test_no_self_loops(self):\n    n = 10\n    k = 3\n    alpha = 1\n    G = random_k_out_graph(n, k, alpha, self_loops=False)\n    assert nx.number_of_selfloops(G) == 0"
 },
 {
  "docstring": "Tests that the generated graph is `k`-out-regular.",
  "code": "def test_regularity(self):\n    n = 10\n    k = 3\n    G = random_uniform_k_out_graph(n, k)\n    assert all((d == k for v, d in G.out_degree()))\n    G = random_uniform_k_out_graph(n, k, seed=42)\n    assert all((d == k for v, d in G.out_degree()))"
 },
 {
  "docstring": "Tests for forbidding self-loops.",
  "code": "def test_no_self_loops(self):\n    n = 10\n    k = 3\n    G = random_uniform_k_out_graph(n, k, self_loops=False)\n    assert nx.number_of_selfloops(G) == 0\n    assert all((d == k for v, d in G.out_degree()))"
 },
 {
  "docstring": "Test for the :func:`networkx.chordal_cycle_graph` function.",
  "code": "@pytest.mark.parametrize('p', (3, 5, 7, 11))\ndef test_chordal_cycle_graph(p):\n    G = nx.chordal_cycle_graph(p)\n    assert len(G) == p"
 },
 {
  "docstring": "Test for the :func:`networkx.paley_graph` function.",
  "code": "@pytest.mark.parametrize('p', (3, 5, 7, 11, 13))\ndef test_paley_graph(p):\n    G = nx.paley_graph(p)\n    assert len(G) == p\n    in_degrees = {G.in_degree(node) for node in G.nodes}\n    out_degrees = {G.out_degree(node) for node in G.nodes}\n    assert len(in_degrees) == 1 and in_degrees.pop() == (p - 1) // 2\n    assert len(out_degrees) == 1 and out_degrees.pop() == (p - 1) // 2\n    if p % 4 == 1:\n        for u, v in G.edges:\n            assert (v, u) in G.edges"
 },
 {
  "docstring": "Returns ``True`` if and only if the nodes whose attributes are\n``du`` and ``dv`` should be joined, according to the threshold\ncondition for geographical threshold graphs.\n\n``G`` is an undirected NetworkX graph, and ``u`` and ``v`` are nodes\nin that graph. The nodes must have node attributes ``'pos'`` and\n``'weight'``.\n\n``metric`` is a distance metric.",
  "code": "def join(G, u, v, theta, alpha, metric):\n    du, dv = (G.nodes[u], G.nodes[v])\n    u_pos, v_pos = (du['pos'], dv['pos'])\n    u_weight, v_weight = (du['weight'], dv['weight'])\n    return (u_weight + v_weight) * metric(u_pos, v_pos) ** alpha >= theta"
 },
 {
  "docstring": "Tests that pairs of vertices adjacent if and only if they are\nwithin the prescribed radius.",
  "code": "def test_distances(self):\n    G = nx.random_geometric_graph(50, 0.25)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert math.dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25\n        else:\n            assert not math.dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25"
 },
 {
  "docstring": "Tests for providing an alternate distance metric to the generator.",
  "code": "def test_p(self):\n    G = nx.random_geometric_graph(50, 0.25, p=1)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert l1dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25\n        else:\n            assert not l1dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25"
 },
 {
  "docstring": "Tests using values other than sequential numbers as node IDs.",
  "code": "def test_node_names(self):\n    import string\n    nodes = list(string.ascii_lowercase)\n    G = nx.random_geometric_graph(nodes, 0.25)\n    assert len(G) == len(nodes)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert math.dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25\n        else:\n            assert not math.dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25"
 },
 {
  "docstring": "Tests that pairs of vertices adjacent if and only if they are\nwithin the prescribed radius.",
  "code": "def test_distances(self):\n    G = nx.soft_random_geometric_graph(50, 0.25)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert math.dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25"
 },
 {
  "docstring": "Tests for providing an alternate distance metric to the generator.",
  "code": "def test_p(self):\n\n    def dist(x, y):\n        return sum((abs(a - b) for a, b in zip(x, y)))\n    G = nx.soft_random_geometric_graph(50, 0.25, p=1)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25"
 },
 {
  "docstring": "Tests using values other than sequential numbers as node IDs.",
  "code": "def test_node_names(self):\n    import string\n    nodes = list(string.ascii_lowercase)\n    G = nx.soft_random_geometric_graph(nodes, 0.25)\n    assert len(G) == len(nodes)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert math.dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25"
 },
 {
  "docstring": "Tests default p_dict = 0.5 returns graph with edge count <= RGG with\nsame n, radius, dim and positions",
  "code": "def test_p_dist_default(self):\n    nodes = 50\n    dim = 2\n    pos = {v: [random.random() for i in range(dim)] for v in range(nodes)}\n    RGG = nx.random_geometric_graph(50, 0.25, pos=pos)\n    SRGG = nx.soft_random_geometric_graph(50, 0.25, pos=pos)\n    assert len(SRGG.edges()) <= len(RGG.edges())"
 },
 {
  "docstring": "Tests if p_dict = 0 returns disconnected graph with 0 edges",
  "code": "def test_p_dist_zero(self):\n\n    def p_dist(dist):\n        return 0\n    G = nx.soft_random_geometric_graph(50, 0.25, p_dist=p_dist)\n    assert len(G.edges) == 0"
 },
 {
  "docstring": "Tests that pairs of vertices adjacent if and only if their\ndistances meet the given threshold.",
  "code": "def test_distances(self):\n    G = nx.geographical_threshold_graph(50, 10)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert join(G, u, v, 10, -2, math.dist)\n        else:\n            assert not join(G, u, v, 10, -2, math.dist)"
 },
 {
  "docstring": "Tests for providing an alternate distance metric to the generator.",
  "code": "def test_metric(self):\n    G = nx.geographical_threshold_graph(50, 10, metric=l1dist)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert join(G, u, v, 10, -2, l1dist)\n        else:\n            assert not join(G, u, v, 10, -2, l1dist)"
 },
 {
  "docstring": "Tests if p_dict = 0 returns disconnected graph with 0 edges",
  "code": "def test_p_dist_zero(self):\n\n    def p_dist(dist):\n        return 0\n    G = nx.geographical_threshold_graph(50, 1, p_dist=p_dist)\n    assert len(G.edges) == 0"
 },
 {
  "docstring": "Tests for providing an alternate distance metric to the generator.",
  "code": "def test_metric(self):\n    G = nx.waxman_graph(50, 0.5, 0.1, metric=l1dist)\n    assert len(G) == 50"
 },
 {
  "docstring": "Smoke test for radius in range [0, 1]",
  "code": "def test_r_between_0_and_1(self):\n    G = nx.navigable_small_world_graph(3, p=1, q=0, r=0.5, dim=2, seed=42)\n    expected = nx.grid_2d_graph(3, 3, create_using=nx.DiGraph)\n    assert nx.utils.graphs_equal(G, expected)"
 },
 {
  "docstring": "The probability of adding a long-range edge scales with `1 / dist**r`,\nso a navigable_small_world graph created with r < 1 should generally\nresult in more edges than a navigable_small_world graph with r >= 1\n(for 0 < q << n).\n\nN.B. this is probabilistic, so this test may not hold for all seeds.",
  "code": "@pytest.mark.parametrize('seed', range(2478, 2578, 10))\ndef test_r_general_scaling(self, seed):\n    G1 = nx.navigable_small_world_graph(7, q=3, r=0.5, seed=seed)\n    G2 = nx.navigable_small_world_graph(7, q=3, r=1, seed=seed)\n    G3 = nx.navigable_small_world_graph(7, q=3, r=2, seed=seed)\n    assert G1.number_of_edges() > G2.number_of_edges()\n    assert G2.number_of_edges() > G3.number_of_edges()"
 },
 {
  "docstring": "Tests that pairs of vertices adjacent if and only if they are\nwithin the prescribed radius.",
  "code": "def test_distances(self):\n    G = nx.thresholded_random_geometric_graph(50, 0.25, 0.1, seed=42)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert math.dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25"
 },
 {
  "docstring": "Tests for providing an alternate distance metric to the generator.",
  "code": "def test_p(self):\n\n    def dist(x, y):\n        return sum((abs(a - b) for a, b in zip(x, y)))\n    G = nx.thresholded_random_geometric_graph(50, 0.25, 0.1, p=1, seed=42)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25"
 },
 {
  "docstring": "Tests using values other than sequential numbers as node IDs.",
  "code": "def test_node_names(self):\n    import string\n    nodes = list(string.ascii_lowercase)\n    G = nx.thresholded_random_geometric_graph(nodes, 0.25, 0.1, seed=42)\n    assert len(G) == len(nodes)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert math.dist(G.nodes[u]['pos'], G.nodes[v]['pos']) <= 0.25"
 },
 {
  "docstring": "Tests that pairs of vertices adjacent if and only if their sum\nweights exceeds the threshold parameter theta.",
  "code": "def test_theta(self):\n    G = nx.thresholded_random_geometric_graph(50, 0.25, 0.1, seed=42)\n    for u, v in combinations(G, 2):\n        if v in G[u]:\n            assert G.nodes[u]['weight'] + G.nodes[v]['weight'] >= 0.1"
 },
 {
  "docstring": "Tests for trivial case of empty input",
  "code": "def test_empty(self):\n    assert len(interval_graph([])) == 0"
 },
 {
  "docstring": "Tests for conditions that raise Exceptions",
  "code": "def test_interval_graph_check_invalid(self):\n    invalids_having_none = [None, (1, 2)]\n    with pytest.raises(TypeError):\n        interval_graph(invalids_having_none)\n    invalids_having_set = [{1, 2}]\n    with pytest.raises(TypeError):\n        interval_graph(invalids_having_set)\n    invalids_having_seq_but_not_length2 = [(1, 2, 3)]\n    with pytest.raises(TypeError):\n        interval_graph(invalids_having_seq_but_not_length2)\n    invalids_interval = [[3, 2]]\n    with pytest.raises(ValueError):\n        interval_graph(invalids_interval)"
 },
 {
  "docstring": "test all possible overlaps",
  "code": "def test_interval_graph_4(self):\n    intervals = [(0, 2), (-2, -1), (-2, 0), (-2, 1), (-2, 2), (-2, 3), (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (3, 4)]\n    expected_graph = nx.Graph()\n    expected_graph.add_nodes_from(intervals)\n    expected_nbrs = {(-2, 0), (-2, 1), (-2, 2), (-2, 3), (0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)}\n    actual_g = nx.interval_graph(intervals)\n    actual_nbrs = nx.neighbors(actual_g, (0, 2))\n    assert set(actual_nbrs) == expected_nbrs"
 },
 {
  "docstring": "this test is to see that an interval supports infinite number",
  "code": "def test_interval_graph_5(self):\n    intervals = {(-math.inf, 0), (-1, -1), (0.5, 0.5), (1, 1), (1, math.inf)}\n    expected_graph = nx.Graph()\n    expected_graph.add_nodes_from(intervals)\n    e1 = ((-math.inf, 0), (-1, -1))\n    e2 = ((1, 1), (1, math.inf))\n    expected_graph.add_edges_from([e1, e2])\n    actual_g = interval_graph(intervals)\n    assert set(actual_g.nodes) == set(expected_graph.nodes)\n    assert edges_equal(expected_graph, actual_g)"
 },
 {
  "docstring": "Tests for conditions that invalidate a joint degree dict",
  "code": "def test_is_valid_joint_degree():\n    joint_degrees = {1: {4: 1}, 2: {2: 2, 3: 2, 4: 2}, 3: {2: 2, 4: 1}, 4: {1: 1, 2: 2, 3: 1}}\n    assert is_valid_joint_degree(joint_degrees)\n    joint_degrees_1 = {1: {4: 1.5}, 2: {2: 2, 3: 2, 4: 2}, 3: {2: 2, 4: 1}, 4: {1: 1.5, 2: 2, 3: 1}}\n    assert not is_valid_joint_degree(joint_degrees_1)\n    joint_degrees_2 = {1: {4: 1}, 2: {2: 2, 3: 2, 4: 3}, 3: {2: 2, 4: 1}, 4: {1: 1, 2: 3, 3: 1}}\n    assert not is_valid_joint_degree(joint_degrees_2)\n    joint_degrees_3 = {1: {4: 2}, 2: {2: 2, 3: 2, 4: 2}, 3: {2: 2, 4: 1}, 4: {1: 2, 2: 2, 3: 1}}\n    assert not is_valid_joint_degree(joint_degrees_3)\n    joint_degrees_5 = {1: {1: 9}}\n    assert not is_valid_joint_degree(joint_degrees_5)"
 },
 {
  "docstring": "grid_graph([n,m]) is a connected simple graph with the\nfollowing properties:\nnumber_of_nodes = n*m\ndegree_histogram = [0,0,4,2*(n+m)-8,(n-2)*(m-2)]",
  "code": "def test_grid_graph(self):\n    for n, m in [(3, 5), (5, 3), (4, 5), (5, 4)]:\n        dim = [n, m]\n        g = nx.grid_graph(dim)\n        assert len(g) == n * m\n        assert nx.degree_histogram(g) == [0, 0, 4, 2 * (n + m) - 8, (n - 2) * (m - 2)]\n    for n, m in [(1, 5), (5, 1)]:\n        dim = [n, m]\n        g = nx.grid_graph(dim)\n        assert len(g) == n * m\n        assert nx.is_isomorphic(g, nx.path_graph(5))"
 },
 {
  "docstring": "Tests that the graph is really a triangular lattice.",
  "code": "def test_lattice_points(self):\n    for m, n in [(2, 3), (2, 2), (2, 1), (3, 3), (3, 2), (3, 4)]:\n        G = nx.triangular_lattice_graph(m, n)\n        N = (n + 1) // 2\n        assert len(G) == (m + 1) * (1 + N) - n % 2 * ((m + 1) // 2)\n    for i, j in G.nodes():\n        nbrs = G[i, j]\n        if i < N:\n            assert (i + 1, j) in nbrs\n        if j < m:\n            assert (i, j + 1) in nbrs\n        if j < m and (i > 0 or j % 2) and (i < N or (j + 1) % 2):\n            assert (i + 1, j + 1) in nbrs or (i - 1, j + 1) in nbrs"
 },
 {
  "docstring": "Tests for creating a directed triangular lattice.",
  "code": "def test_directed(self):\n    G = nx.triangular_lattice_graph(3, 4, create_using=nx.Graph())\n    H = nx.triangular_lattice_graph(3, 4, create_using=nx.DiGraph())\n    assert H.is_directed()\n    for u, v in H.edges():\n        assert v[1] >= u[1]\n        if v[1] == u[1]:\n            assert v[0] > u[0]"
 },
 {
  "docstring": "Tests for creating a triangular lattice multigraph.",
  "code": "def test_multigraph(self):\n    G = nx.triangular_lattice_graph(3, 4, create_using=nx.Graph())\n    H = nx.triangular_lattice_graph(3, 4, create_using=nx.MultiGraph())\n    assert list(H.edges()) == list(G.edges())"
 },
 {
  "docstring": "Tests that the graph is really a hexagonal lattice.",
  "code": "def test_lattice_points(self):\n    for m, n in [(4, 5), (4, 4), (4, 3), (3, 2), (3, 3), (3, 5)]:\n        G = nx.hexagonal_lattice_graph(m, n)\n        assert len(G) == 2 * (m + 1) * (n + 1) - 2\n    C_6 = nx.cycle_graph(6)\n    hexagons = [[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)], [(0, 2), (0, 3), (0, 4), (1, 2), (1, 3), (1, 4)], [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3)], [(2, 0), (2, 1), (2, 2), (3, 0), (3, 1), (3, 2)], [(2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4)]]\n    for hexagon in hexagons:\n        assert nx.is_isomorphic(G.subgraph(hexagon), C_6)"
 },
 {
  "docstring": "Tests for creating a directed hexagonal lattice.",
  "code": "def test_directed(self):\n    G = nx.hexagonal_lattice_graph(3, 5, create_using=nx.Graph())\n    H = nx.hexagonal_lattice_graph(3, 5, create_using=nx.DiGraph())\n    assert H.is_directed()\n    pos = nx.get_node_attributes(H, 'pos')\n    for u, v in H.edges():\n        assert pos[v][1] >= pos[u][1]\n        if pos[v][1] == pos[u][1]:\n            assert pos[v][0] > pos[u][0]"
 },
 {
  "docstring": "Tests for creating a hexagonal lattice multigraph.",
  "code": "def test_multigraph(self):\n    G = nx.hexagonal_lattice_graph(3, 5, create_using=nx.Graph())\n    H = nx.hexagonal_lattice_graph(3, 5, create_using=nx.MultiGraph())\n    assert list(H.edges()) == list(G.edges())"
 },
 {
  "docstring": "If the edge probability `p` is <=0, the resulting graph should have no edges.",
  "code": "@pytest.mark.parametrize('generator', _gnp_generators)\n@pytest.mark.parametrize('directed', (True, False))\ndef test_gnp_generators_negative_edge_probability(generator, directed):\n    G = generator(10, -1.1, directed=directed)\n    assert len(G) == 10\n    assert G.number_of_edges() == 0\n    assert G.is_directed() == directed"
 },
 {
  "docstring": "If the edge probability `p` is >=1, the resulting graph should be complete.",
  "code": "@pytest.mark.parametrize('generator', _gnp_generators)\n@pytest.mark.parametrize(('directed', 'expected_num_edges'), [(False, 45), (True, 90)])\ndef test_gnp_generators_greater_than_1_edge_probability(generator, directed, expected_num_edges):\n    G = generator(10, 1.1, directed=directed)\n    assert len(G) == 10\n    assert G.number_of_edges() == expected_num_edges\n    assert G.is_directed() == directed"
 },
 {
  "docstring": "If the edge probability `p` is >0 and <1, test only the basic properties.",
  "code": "@pytest.mark.parametrize('generator', _gnp_generators)\n@pytest.mark.parametrize('directed', (True, False))\ndef test_gnp_generators_basic(generator, directed):\n    G = generator(10, 0.1, directed=directed)\n    assert len(G) == 10\n    assert G.is_directed() == directed"
 },
 {
  "docstring": "If the edge probability `p` is close to 1, the resulting graph should have all edges.",
  "code": "@pytest.mark.parametrize('generator', _gnp_generators)\ndef test_gnp_generators_for_p_close_to_1(generator):\n    runs = 100\n    edges = sum((generator(10, 0.99999, directed=True).number_of_edges() for _ in range(runs)))\n    assert abs(edges / float(runs) - 90) <= runs * 2.0 / 100"
 },
 {
  "docstring": "Test that gnp generators generate edges according to the their probability `p`.",
  "code": "@pytest.mark.parametrize('generator', _gnp_generators)\n@pytest.mark.parametrize('p', (0.2, 0.8))\n@pytest.mark.parametrize('directed', (True, False))\ndef test_gnp_generators_edge_probability(generator, p, directed):\n    runs = 5000\n    n = 5\n    edge_counts = [[0] * n for _ in range(n)]\n    for i in range(runs):\n        G = generator(n, p, directed=directed)\n        for v, w in G.edges:\n            edge_counts[v][w] += 1\n            if not directed:\n                edge_counts[w][v] += 1\n    for v in range(n):\n        for w in range(n):\n            if v == w:\n                assert edge_counts[v][w] == 0\n            else:\n                assert abs(edge_counts[v][w] / float(runs) - p) <= 0.03"
 },
 {
  "docstring": "Test that aliases give the same result with the same seed.",
  "code": "@pytest.mark.parametrize('generator', [nx.gnp_random_graph, nx.binomial_graph, nx.erdos_renyi_graph])\n@pytest.mark.parametrize(('seed', 'directed', 'expected_num_edges'), [(42, False, 1219), (42, True, 2454), (314, False, 1247), (314, True, 2476)])\ndef test_gnp_random_graph_aliases(generator, seed, directed, expected_num_edges):\n    G = generator(100, 0.25, seed=seed, directed=directed)\n    assert len(G) == 100\n    assert G.number_of_edges() == expected_num_edges\n    assert G.is_directed() == directed"
 },
 {
  "docstring": "Tests that the dual BA random graph generated behaves consistently.\n\nTests the exceptions are raised as expected.\n\nThe graphs generation are repeated several times to prevent lucky shots",
  "code": "def test_dual_barabasi_albert(self, m1=1, m2=4, p=0.5):\n    seeds = [42, 314, 2718]\n    initial_graph = nx.complete_graph(10)\n    for seed in seeds:\n        BA1 = nx.barabasi_albert_graph(100, m1, seed)\n        DBA1 = nx.dual_barabasi_albert_graph(100, m1, m2, 1, seed)\n        assert BA1.edges() == DBA1.edges()\n        BA2 = nx.barabasi_albert_graph(100, m2, seed)\n        DBA2 = nx.dual_barabasi_albert_graph(100, m1, m2, 0, seed)\n        assert BA2.edges() == DBA2.edges()\n        BA3 = nx.barabasi_albert_graph(100, m1, seed)\n        DBA3 = nx.dual_barabasi_albert_graph(100, m1, m1, p, seed)\n        assert BA3.size() == DBA3.size()\n        DBA = nx.dual_barabasi_albert_graph(100, m1, m2, p, seed, initial_graph)\n        BA1 = nx.barabasi_albert_graph(100, m1, seed, initial_graph)\n        BA2 = nx.barabasi_albert_graph(100, m2, seed, initial_graph)\n        assert min(BA1.size(), BA2.size()) <= DBA.size() <= max(BA1.size(), BA2.size())\n    dbag = nx.dual_barabasi_albert_graph\n    pytest.raises(nx.NetworkXError, dbag, m1, m1, m2, 0)\n    pytest.raises(nx.NetworkXError, dbag, m2, m1, m2, 0)\n    pytest.raises(nx.NetworkXError, dbag, 100, m1, m2, -0.5)\n    pytest.raises(nx.NetworkXError, dbag, 100, m1, m2, 1.5)\n    initial = nx.complete_graph(max(m1, m2) - 1)\n    pytest.raises(nx.NetworkXError, dbag, 100, m1, m2, p, initial_graph=initial)"
 },
 {
  "docstring": "Tests that the extended BA random graph generated behaves consistently.\n\nTests the exceptions are raised as expected.\n\nThe graphs generation are repeated several times to prevent lucky-shots",
  "code": "def test_extended_barabasi_albert(self, m=2):\n    seeds = [42, 314, 2718]\n    for seed in seeds:\n        BA_model = nx.barabasi_albert_graph(100, m, seed)\n        BA_model_edges = BA_model.number_of_edges()\n        G1 = nx.extended_barabasi_albert_graph(100, m, 0, 0, seed)\n        assert G1.size() == BA_model_edges\n        G1 = nx.extended_barabasi_albert_graph(100, m, 0.8, 0, seed)\n        assert G1.size() > BA_model_edges * 2\n        G2 = nx.extended_barabasi_albert_graph(100, m, 0, 0.8, seed)\n        assert G2.size() == BA_model_edges\n        G3 = nx.extended_barabasi_albert_graph(100, m, 0.3, 0.3, seed)\n        assert G3.size() > G2.size()\n        assert G3.size() < G1.size()\n    ebag = nx.extended_barabasi_albert_graph\n    pytest.raises(nx.NetworkXError, ebag, m, m, 0, 0)\n    pytest.raises(nx.NetworkXError, ebag, 1, 0.5, 0, 0)\n    pytest.raises(nx.NetworkXError, ebag, 100, 2, 0.5, 0.5)"
 },
 {
  "docstring": "Tests that a 0-regular graph has the correct number of nodes and\nedges.",
  "code": "def test_random_zero_regular_graph(self):\n    seed = 42\n    G = nx.random_regular_graph(0, 10, seed)\n    assert len(G) == 10\n    assert G.number_of_edges() == 0"
 },
 {
  "docstring": "A tree is a caterpillar iff all nodes of degree >=3 are surrounded\nby at most two nodes of degree two or greater.\nref: http://mathworld.wolfram.com/CaterpillarGraph.html",
  "code": "def is_caterpillar(g):\n    deg_over_3 = [n for n in g if g.degree(n) >= 3]\n    for n in deg_over_3:\n        nbh_deg_over_2 = [nbh for nbh in g.neighbors(n) if g.degree(nbh) >= 2]\n        if not len(nbh_deg_over_2) <= 2:\n            return False\n    return True"
 },
 {
  "docstring": "A tree is a lobster if it has the property that the removal of leaf\nnodes leaves a caterpillar graph (Gallian 2007)\nref: http://mathworld.wolfram.com/LobsterGraph.html",
  "code": "def is_lobster(g):\n    non_leafs = [n for n in g if g.degree(n) > 1]\n    return is_caterpillar(g.subgraph(non_leafs))"
 },
 {
  "docstring": "Tests for an in-place reweighting of the edges of the graph.",
  "code": "def test_in_place(self):\n    G = nx.DiGraph()\n    G.add_edge(0, 1, weight=1)\n    G.add_edge(0, 2, weight=1)\n    nx.stochastic_graph(G, copy=False)\n    assert sorted(G.edges(data=True)) == [(0, 1, {'weight': 0.5}), (0, 2, {'weight': 0.5})]"
 },
 {
  "docstring": "Smoke test: ensure ZeroDivisionError is not raised.",
  "code": "def test_zero_weights(self):\n    G = nx.DiGraph()\n    G.add_edge(0, 1, weight=0)\n    G.add_edge(0, 2, weight=0)\n    S = nx.stochastic_graph(G)\n    assert sorted(S.edges(data=True)) == [(0, 1, {'weight': 0}), (0, 2, {'weight': 0})]"
 },
 {
  "docstring": "Raise an error when generating a Sudoku graph of order -1.",
  "code": "def test_sudoku_negative():\n    pytest.raises(nx.NetworkXError, nx.sudoku_graph, n=-1)"
 },
 {
  "docstring": "Generate Sudoku graphs of various sizes and verify their properties.",
  "code": "@pytest.mark.parametrize('n', [0, 1, 2, 3, 4])\ndef test_sudoku_generator(n):\n    G = nx.sudoku_graph(n)\n    expected_nodes = n ** 4\n    expected_degree = (n - 1) * (3 * n + 1)\n    expected_edges = expected_nodes * expected_degree // 2\n    assert not G.is_directed()\n    assert not G.is_multigraph()\n    assert G.number_of_nodes() == expected_nodes\n    assert G.number_of_edges() == expected_edges\n    assert all((d == expected_degree for _, d in G.degree))\n    if n == 2:\n        assert sorted(G.neighbors(6)) == [2, 3, 4, 5, 7, 10, 14]\n    elif n == 3:\n        assert sorted(G.neighbors(42)) == [6, 15, 24, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 44, 51, 52, 53, 60, 69, 78]\n    elif n == 4:\n        assert sorted(G.neighbors(0)) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 32, 33, 34, 35, 48, 49, 50, 51, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240]"
 },
 {
  "docstring": "Ensure results are consistent between prefix_tree implementations.",
  "code": "@pytest.mark.parametrize('strings', (['a', 'to', 'tea', 'ted', 'ten', 'i', 'in', 'inn'], ['ab', 'abs', 'ad'], ['ab', 'abs', 'ad', ''], ['distant', 'disparaging', 'distant', 'diamond', 'ruby']))\ndef test_implementations_consistent(strings):\n    assert graphs_equal(nx.prefix_tree(strings), nx.prefix_tree_recursive(strings))"
 },
 {
  "docstring": "Tests that a random tree is in fact a tree.",
  "code": "@pytest.mark.filterwarnings('ignore')\ndef test_random_tree():\n    T = nx.random_tree(10, seed=1234)\n    assert nx.is_tree(T)"
 },
 {
  "docstring": "Generates a directed tree.",
  "code": "@pytest.mark.filterwarnings('ignore')\ndef test_random_directed_tree():\n    T = nx.random_tree(10, seed=1234, create_using=nx.DiGraph())\n    assert T.is_directed()"
 },
 {
  "docstring": "Tests that creating a random tree with a generator works",
  "code": "@pytest.mark.filterwarnings('ignore')\ndef test_random_tree_using_generator():\n    G = nx.Graph()\n    T = nx.random_tree(10, seed=1234, create_using=G)\n    assert nx.is_tree(T)"
 },
 {
  "docstring": "Tests if n = 0 then the NetworkXPointlessConcept exception is raised.",
  "code": "def test_random_labeled_tree_n_zero():\n    with pytest.raises(nx.NetworkXPointlessConcept):\n        T = nx.random_labeled_tree(0, seed=1234)\n    with pytest.raises(nx.NetworkXPointlessConcept):\n        T = nx.random_labeled_rooted_tree(0, seed=1234)"
 },
 {
  "docstring": "Tests generation of empty labeled forests.",
  "code": "def test_random_labeled_rooted_forest_n_zero():\n    F = nx.random_labeled_rooted_forest(0, seed=1234)\n    assert len(F) == 0\n    assert len(F.graph['roots']) == 0"
 },
 {
  "docstring": "Tests if n = 0 then the NetworkXPointlessConcept exception is raised.",
  "code": "def test_random_unlabeled_tree_n_zero():\n    with pytest.raises(nx.NetworkXPointlessConcept):\n        T = nx.random_unlabeled_tree(0, seed=1234)\n    with pytest.raises(nx.NetworkXPointlessConcept):\n        T = nx.random_unlabeled_rooted_tree(0, seed=1234)"
 },
 {
  "docstring": "Tests generation of empty unlabeled forests.",
  "code": "def test_random_unlabeled_forest_n_zero():\n    F = nx.random_unlabeled_rooted_forest(0, seed=1234)\n    assert len(F) == 0\n    assert len(F.graph['roots']) == 0"
 }
]