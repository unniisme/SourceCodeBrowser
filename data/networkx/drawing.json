[
 {
  "docstring": "Position nodes uniformly at random in the unit square.\n\nFor every node, a position is generated by choosing each of dim\ncoordinates uniformly at random on the interval [0.0, 1.0).\n\nNumPy (http://scipy.org) is required for this function.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n\nseed : int, RandomState instance or None  optional (default=None)\n    Set the random state for deterministic node layouts.\n    If int, `seed` is the seed used by the random number generator,\n    if numpy.random.RandomState instance, `seed` is the random\n    number generator,\n    if None, the random number generator is the RandomState instance used\n    by numpy.random.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nExamples\n--------\n>>> G = nx.lollipop_graph(4, 3)\n>>> pos = nx.random_layout(G)",
  "code": "@np_random_state(3)\ndef random_layout(G, center=None, dim=2, seed=None):\n    import numpy as np\n    G, center = _process_params(G, center, dim)\n    pos = seed.rand(len(G), dim) + center\n    pos = pos.astype(np.float32)\n    pos = dict(zip(G, pos))\n    return pos"
 },
 {
  "docstring": "Position nodes on a circle.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n    If dim>2, the remaining dimensions are set to zero\n    in the returned positions.\n    If dim<2, a ValueError is raised.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nRaises\n------\nValueError\n    If dim < 2\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.circular_layout(G)\n\n",
  "code": "def circular_layout(G, scale=1, center=None, dim=2):\n    import numpy as np\n    if dim < 2:\n        raise ValueError('cannot handle dimensions < 2')\n    G, center = _process_params(G, center, dim)\n    paddims = max(0, dim - 2)\n    if len(G) == 0:\n        pos = {}\n    elif len(G) == 1:\n        pos = {nx.utils.arbitrary_element(G): center}\n    else:\n        theta = np.linspace(0, 1, len(G) + 1)[:-1] * 2 * np.pi\n        theta = theta.astype(np.float32)\n        pos = np.column_stack([np.cos(theta), np.sin(theta), np.zeros((len(G), paddims))])\n        pos = rescale_layout(pos, scale=scale) + center\n        pos = dict(zip(G, pos))\n    return pos"
 },
 {
  "docstring": "Position nodes in concentric circles.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nnlist : list of lists\n   List of node lists for each shell.\n\nrotate : angle in radians (default=pi/len(nlist))\n   Angle by which to rotate the starting position of each shell\n   relative to the starting position of the previous shell.\n   To recreate behavior before v2.5 use rotate=0.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout, currently only dim=2 is supported.\n    Other dimension values result in a ValueError.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nRaises\n------\nValueError\n    If dim != 2\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> shells = [[0], [1, 2, 3]]\n>>> pos = nx.shell_layout(G, shells)\n\n",
  "code": "def shell_layout(G, nlist=None, rotate=None, scale=1, center=None, dim=2):\n    import numpy as np\n    if dim != 2:\n        raise ValueError('can only handle 2 dimensions')\n    G, center = _process_params(G, center, dim)\n    if len(G) == 0:\n        return {}\n    if len(G) == 1:\n        return {nx.utils.arbitrary_element(G): center}\n    if nlist is None:\n        nlist = [list(G)]\n    radius_bump = scale / len(nlist)\n    if len(nlist[0]) == 1:\n        radius = 0.0\n    else:\n        radius = radius_bump\n    if rotate is None:\n        rotate = np.pi / len(nlist)\n    first_theta = rotate\n    npos = {}\n    for nodes in nlist:\n        theta = np.linspace(0, 2 * np.pi, len(nodes), endpoint=False, dtype=np.float32) + first_theta\n        pos = radius * np.column_stack([np.cos(theta), np.sin(theta)]) + center\n        npos.update(zip(nodes, pos))\n        radius += radius_bump\n        first_theta += rotate\n    return npos"
 },
 {
  "docstring": "Position nodes in two straight lines.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nnodes : list or container\n    Nodes in one node set of the bipartite graph.\n    This set will be placed on left or top.\n\nalign : string (default='vertical')\n    The alignment of nodes. Vertical or horizontal.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\naspect_ratio : number (default=4/3):\n    The ratio of the width to the height of the layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node.\n\nExamples\n--------\n>>> G = nx.bipartite.gnmk_random_graph(3, 5, 10, seed=123)\n>>> top = nx.bipartite.sets(G)[0]\n>>> pos = nx.bipartite_layout(G, top)\n\n",
  "code": "def bipartite_layout(G, nodes, align='vertical', scale=1, center=None, aspect_ratio=4 / 3):\n    import numpy as np\n    if align not in ('vertical', 'horizontal'):\n        msg = 'align must be either vertical or horizontal.'\n        raise ValueError(msg)\n    G, center = _process_params(G, center=center, dim=2)\n    if len(G) == 0:\n        return {}\n    height = 1\n    width = aspect_ratio * height\n    offset = (width / 2, height / 2)\n    top = dict.fromkeys(nodes)\n    bottom = [v for v in G if v not in top]\n    nodes = list(top) + bottom\n    left_xs = np.repeat(0, len(top))\n    right_xs = np.repeat(width, len(bottom))\n    left_ys = np.linspace(0, height, len(top))\n    right_ys = np.linspace(0, height, len(bottom))\n    top_pos = np.column_stack([left_xs, left_ys]) - offset\n    bottom_pos = np.column_stack([right_xs, right_ys]) - offset\n    pos = np.concatenate([top_pos, bottom_pos])\n    pos = rescale_layout(pos, scale=scale) + center\n    if align == 'horizontal':\n        pos = pos[:, ::-1]\n    pos = dict(zip(nodes, pos))\n    return pos"
 },
 {
  "docstring": "Position nodes using Fruchterman-Reingold force-directed algorithm.\n\nThe algorithm simulates a force-directed representation of the network\ntreating edges as springs holding nodes close, while treating nodes\nas repelling objects, sometimes called an anti-gravity force.\nSimulation continues until the positions are close to an equilibrium.\n\nThere are some hard-coded values: minimal distance between\nnodes (0.01) and \"temperature\" of 0.1 to ensure nodes don't fly away.\nDuring the simulation, `k` helps determine the distance between nodes,\nthough `scale` and `center` determine the size and place after\nrescaling occurs at the end of the simulation.\n\nFixing some nodes doesn't allow them to move in the simulation.\nIt also turns off the rescaling feature at the simulation's end.\nIn addition, setting `scale` to `None` turns off rescaling.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nk : float (default=None)\n    Optimal distance between nodes.  If None the distance is set to\n    1/sqrt(n) where n is the number of nodes.  Increase this value\n    to move nodes farther apart.\n\npos : dict or None  optional (default=None)\n    Initial positions for nodes as a dictionary with node as keys\n    and values as a coordinate list or tuple.  If None, then use\n    random initial positions.\n\nfixed : list or None  optional (default=None)\n    Nodes to keep fixed at initial position.\n    Nodes not in ``G.nodes`` are ignored.\n    ValueError raised if `fixed` specified and `pos` not.\n\niterations : int  optional (default=50)\n    Maximum number of iterations taken\n\nthreshold: float optional (default = 1e-4)\n    Threshold for relative error in node position changes.\n    The iteration stops if the error is below this threshold.\n\nweight : string or None   optional (default='weight')\n    The edge attribute that holds the numerical value used for\n    the edge weight.  Larger means a stronger attractive force.\n    If None, then all edge weights are 1.\n\nscale : number or None (default: 1)\n    Scale factor for positions. Not used unless `fixed is None`.\n    If scale is None, no rescaling is performed.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n    Not used unless `fixed is None`.\n\ndim : int\n    Dimension of layout.\n\nseed : int, RandomState instance or None  optional (default=None)\n    Set the random state for deterministic node layouts.\n    If int, `seed` is the seed used by the random number generator,\n    if numpy.random.RandomState instance, `seed` is the random\n    number generator,\n    if None, the random number generator is the RandomState instance used\n    by numpy.random.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.spring_layout(G)\n\n# The same using longer but equivalent function name\n>>> pos = nx.fruchterman_reingold_layout(G)",
  "code": "@np_random_state(10)\ndef spring_layout(G, k=None, pos=None, fixed=None, iterations=50, threshold=0.0001, weight='weight', scale=1, center=None, dim=2, seed=None):\n    import numpy as np\n    G, center = _process_params(G, center, dim)\n    if fixed is not None:\n        if pos is None:\n            raise ValueError('nodes are fixed without positions given')\n        for node in fixed:\n            if node not in pos:\n                raise ValueError('nodes are fixed without positions given')\n        nfixed = {node: i for i, node in enumerate(G)}\n        fixed = np.asarray([nfixed[node] for node in fixed if node in nfixed])\n    if pos is not None:\n        dom_size = max((coord for pos_tup in pos.values() for coord in pos_tup))\n        if dom_size == 0:\n            dom_size = 1\n        pos_arr = seed.rand(len(G), dim) * dom_size + center\n        for i, n in enumerate(G):\n            if n in pos:\n                pos_arr[i] = np.asarray(pos[n])\n    else:\n        pos_arr = None\n        dom_size = 1\n    if len(G) == 0:\n        return {}\n    if len(G) == 1:\n        return {nx.utils.arbitrary_element(G.nodes()): center}\n    try:\n        if len(G) < 500:\n            raise ValueError\n        A = nx.to_scipy_sparse_array(G, weight=weight, dtype='f')\n        if k is None and fixed is not None:\n            nnodes, _ = A.shape\n            k = dom_size / np.sqrt(nnodes)\n        pos = _sparse_fruchterman_reingold(A, k, pos_arr, fixed, iterations, threshold, dim, seed)\n    except ValueError:\n        A = nx.to_numpy_array(G, weight=weight)\n        if k is None and fixed is not None:\n            nnodes, _ = A.shape\n            k = dom_size / np.sqrt(nnodes)\n        pos = _fruchterman_reingold(A, k, pos_arr, fixed, iterations, threshold, dim, seed)\n    if fixed is None and scale is not None:\n        pos = rescale_layout(pos, scale=scale) + center\n    pos = dict(zip(G, pos))\n    return pos"
 },
 {
  "docstring": "Position nodes using Kamada-Kawai path-length cost-function.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\ndist : dict (default=None)\n    A two-level dictionary of optimal distances between nodes,\n    indexed by source and destination node.\n    If None, the distance is computed using shortest_path_length().\n\npos : dict or None  optional (default=None)\n    Initial positions for nodes as a dictionary with node as keys\n    and values as a coordinate list or tuple.  If None, then use\n    circular_layout() for dim >= 2 and a linear layout for dim == 1.\n\nweight : string or None   optional (default='weight')\n    The edge attribute that holds the numerical value used for\n    the edge weight.  If None, then all edge weights are 1.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.kamada_kawai_layout(G)",
  "code": "def kamada_kawai_layout(G, dist=None, pos=None, weight='weight', scale=1, center=None, dim=2):\n    import numpy as np\n    G, center = _process_params(G, center, dim)\n    nNodes = len(G)\n    if nNodes == 0:\n        return {}\n    if dist is None:\n        dist = dict(nx.shortest_path_length(G, weight=weight))\n    dist_mtx = 1000000.0 * np.ones((nNodes, nNodes))\n    for row, nr in enumerate(G):\n        if nr not in dist:\n            continue\n        rdist = dist[nr]\n        for col, nc in enumerate(G):\n            if nc not in rdist:\n                continue\n            dist_mtx[row][col] = rdist[nc]\n    if pos is None:\n        if dim >= 3:\n            pos = random_layout(G, dim=dim)\n        elif dim == 2:\n            pos = circular_layout(G, dim=dim)\n        else:\n            pos = dict(zip(G, np.linspace(0, 1, len(G))))\n    pos_arr = np.array([pos[n] for n in G])\n    pos = _kamada_kawai_solve(dist_mtx, pos_arr, dim)\n    pos = rescale_layout(pos, scale=scale) + center\n    return dict(zip(G, pos))"
 },
 {
  "docstring": "Position nodes using the eigenvectors of the graph Laplacian.\n\nUsing the unnormalized Laplacian, the layout shows possible clusters of\nnodes which are an approximation of the ratio cut. If dim is the number of\ndimensions then the positions are the entries of the dim eigenvectors\ncorresponding to the ascending eigenvalues starting from the second one.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nweight : string or None   optional (default='weight')\n    The edge attribute that holds the numerical value used for\n    the edge weight.  If None, then all edge weights are 1.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.spectral_layout(G)\n\n",
  "code": "def spectral_layout(G, weight='weight', scale=1, center=None, dim=2):\n    import numpy as np\n    G, center = _process_params(G, center, dim)\n    if len(G) <= 2:\n        if len(G) == 0:\n            pos = np.array([])\n        elif len(G) == 1:\n            pos = np.array([center])\n        else:\n            pos = np.array([np.zeros(dim), np.array(center) * 2.0])\n        return dict(zip(G, pos))\n    try:\n        if len(G) < 500:\n            raise ValueError\n        A = nx.to_scipy_sparse_array(G, weight=weight, dtype='d')\n        if G.is_directed():\n            A = A + np.transpose(A)\n        pos = _sparse_spectral(A, dim)\n    except (ImportError, ValueError):\n        A = nx.to_numpy_array(G, weight=weight)\n        if G.is_directed():\n            A += A.T\n        pos = _spectral(A, dim)\n    pos = rescale_layout(pos, scale=scale) + center\n    pos = dict(zip(G, pos))\n    return pos"
 },
 {
  "docstring": "Position nodes without edge intersections.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G. If G is of type\n    nx.PlanarEmbedding, the positions are selected accordingly.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\ndim : int\n    Dimension of layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nRaises\n------\nNetworkXException\n    If G is not planar\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.planar_layout(G)",
  "code": "def planar_layout(G, scale=1, center=None, dim=2):\n    import numpy as np\n    if dim != 2:\n        raise ValueError('can only handle 2 dimensions')\n    G, center = _process_params(G, center, dim)\n    if len(G) == 0:\n        return {}\n    if isinstance(G, nx.PlanarEmbedding):\n        embedding = G\n    else:\n        is_planar, embedding = nx.check_planarity(G)\n        if not is_planar:\n            raise nx.NetworkXException('G is not planar.')\n    pos = nx.combinatorial_embedding_to_pos(embedding)\n    node_list = list(embedding)\n    pos = np.row_stack([pos[x] for x in node_list])\n    pos = pos.astype(np.float64)\n    pos = rescale_layout(pos, scale=scale) + center\n    return dict(zip(node_list, pos))"
 },
 {
  "docstring": "Position nodes in a spiral layout.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\nscale : number (default: 1)\n    Scale factor for positions.\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\ndim : int, default=2\n    Dimension of layout, currently only dim=2 is supported.\n    Other dimension values result in a ValueError.\nresolution : float, default=0.35\n    The compactness of the spiral layout returned.\n    Lower values result in more compressed spiral layouts.\nequidistant : bool, default=False\n    If True, nodes will be positioned equidistant from each other\n    by decreasing angle further from center.\n    If False, nodes will be positioned at equal angles\n    from each other by increasing separation further from center.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node\n\nRaises\n------\nValueError\n    If dim != 2\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> pos = nx.spiral_layout(G)\n>>> nx.draw(G, pos=pos)\n\n",
  "code": "def spiral_layout(G, scale=1, center=None, dim=2, resolution=0.35, equidistant=False):\n    import numpy as np\n    if dim != 2:\n        raise ValueError('can only handle 2 dimensions')\n    G, center = _process_params(G, center, dim)\n    if len(G) == 0:\n        return {}\n    if len(G) == 1:\n        return {nx.utils.arbitrary_element(G): center}\n    pos = []\n    if equidistant:\n        chord = 1\n        step = 0.5\n        theta = resolution\n        theta += chord / (step * theta)\n        for _ in range(len(G)):\n            r = step * theta\n            theta += chord / r\n            pos.append([np.cos(theta) * r, np.sin(theta) * r])\n    else:\n        dist = np.arange(len(G), dtype=float)\n        angle = resolution * dist\n        pos = np.transpose(dist * np.array([np.cos(angle), np.sin(angle)]))\n    pos = rescale_layout(np.array(pos), scale=scale) + center\n    pos = dict(zip(G, pos))\n    return pos"
 },
 {
  "docstring": "Position nodes in layers of straight lines.\n\nParameters\n----------\nG : NetworkX graph or list of nodes\n    A position will be assigned to every node in G.\n\nsubset_key : string (default='subset')\n    Key of node data to be used as layer subset.\n\nalign : string (default='vertical')\n    The alignment of nodes. Vertical or horizontal.\n\nscale : number (default: 1)\n    Scale factor for positions.\n\ncenter : array-like or None\n    Coordinate pair around which to center the layout.\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node.\n\nExamples\n--------\n>>> G = nx.complete_multipartite_graph(28, 16, 10)\n>>> pos = nx.multipartite_layout(G)\n\n",
  "code": "def multipartite_layout(G, subset_key='subset', align='vertical', scale=1, center=None):\n    import numpy as np\n    if align not in ('vertical', 'horizontal'):\n        msg = 'align must be either vertical or horizontal.'\n        raise ValueError(msg)\n    G, center = _process_params(G, center=center, dim=2)\n    if len(G) == 0:\n        return {}\n    layers = {}\n    for v, data in G.nodes(data=True):\n        try:\n            layer = data[subset_key]\n        except KeyError:\n            msg = \"all nodes must have subset_key (default='subset') as data\"\n            raise ValueError(msg)\n        layers[layer] = [v] + layers.get(layer, [])\n    try:\n        layers = sorted(layers.items())\n    except TypeError:\n        layers = list(layers.items())\n    pos = None\n    nodes = []\n    width = len(layers)\n    for i, (_, layer) in enumerate(layers):\n        height = len(layer)\n        xs = np.repeat(i, height)\n        ys = np.arange(0, height, dtype=float)\n        offset = ((width - 1) / 2, (height - 1) / 2)\n        layer_pos = np.column_stack([xs, ys]) - offset\n        if pos is None:\n            pos = layer_pos\n        else:\n            pos = np.concatenate([pos, layer_pos])\n        nodes.extend(layer)\n    pos = rescale_layout(pos, scale=scale) + center\n    if align == 'horizontal':\n        pos = pos[:, ::-1]\n    pos = dict(zip(nodes, pos))\n    return pos"
 },
 {
  "docstring": "Arf layout for networkx\n\nThe attractive and repulsive forces (arf) layout [1]\nimproves the spring layout in three ways. First, it\nprevents congestion of highly connected nodes due to\nstrong forcing between nodes. Second, it utilizes the\nlayout space more effectively by preventing large gaps\nthat spring layout tends to create. Lastly, the arf\nlayout represents symmetries in the layout better than\nthe default spring layout.\n\nParameters\n----------\nG : nx.Graph or nx.DiGraph\n    Networkx graph.\npos : dict\n    Initial  position of  the nodes.  If set  to None  a\n    random layout will be used.\nscaling : float\n    Scales the radius of the circular layout space.\na : float\n    Strength of springs between connected nodes. Should be larger than 1. The greater a, the clearer the separation ofunconnected sub clusters.\netol : float\n    Gradient sum of spring forces must be larger than `etol` before successful termination.\ndt : float\n    Time step for force differential equation simulations.\nmax_iter : int\n    Max iterations before termination of the algorithm.\n\nReferences\n.. [1] \"Self-Organization Applied to Dynamic Network Layout\", M. Geipel,\n        International Journal of Modern Physics C, 2007, Vol 18, No 10, pp. 1537-1549.\n        https://doi.org/10.1142/S0129183107011558 https://arxiv.org/abs/0704.1748\n\nReturns\n-------\npos : dict\n    A dictionary of positions keyed by node.\n\nExamples\n--------\n>>> G = nx.grid_graph((5, 5))\n>>> pos = nx.arf_layout(G)",
  "code": "def arf_layout(G, pos=None, scaling=1, a=1.1, etol=1e-06, dt=0.001, max_iter=1000):\n    import warnings\n    import numpy as np\n    if a <= 1:\n        msg = 'The parameter a should be larger than 1'\n        raise ValueError(msg)\n    pos_tmp = nx.random_layout(G)\n    if pos is None:\n        pos = pos_tmp\n    else:\n        for node in G.nodes():\n            if node not in pos:\n                pos[node] = pos_tmp[node].copy()\n    N = len(G)\n    if N == 0:\n        return pos\n    K = np.ones((N, N)) - np.eye(N)\n    node_order = {node: i for i, node in enumerate(G)}\n    for x, y in G.edges():\n        if x != y:\n            idx, jdx = (node_order[i] for i in (x, y))\n            K[idx, jdx] = a\n    p = np.asarray(list(pos.values()))\n    rho = scaling * np.sqrt(N)\n    error = etol + 1\n    n_iter = 0\n    while error > etol:\n        diff = p[:, np.newaxis] - p[np.newaxis]\n        A = np.linalg.norm(diff, axis=-1)[..., np.newaxis]\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore')\n            change = K[..., np.newaxis] * diff - rho / A * diff\n        change = np.nansum(change, axis=0)\n        p += change * dt\n        error = np.linalg.norm(change, axis=-1).sum()\n        if n_iter > max_iter:\n            break\n        n_iter += 1\n    return dict(zip(G.nodes(), p))"
 },
 {
  "docstring": "Returns scaled position array to (-scale, scale) in all axes.\n\nThe function acts on NumPy arrays which hold position information.\nEach position is one row of the array. The dimension of the space\nequals the number of columns. Each coordinate in one column.\n\nTo rescale, the mean (center) is subtracted from each axis separately.\nThen all values are scaled so that the largest magnitude value\nfrom all axes equals `scale` (thus, the aspect ratio is preserved).\nThe resulting NumPy Array is returned (order of rows unchanged).\n\nParameters\n----------\npos : numpy array\n    positions to be scaled. Each row is a position.\n\nscale : number (default: 1)\n    The size of the resulting extent in all directions.\n\nReturns\n-------\npos : numpy array\n    scaled positions. Each row is a position.\n\nSee Also\n--------\nrescale_layout_dict",
  "code": "def rescale_layout(pos, scale=1):\n    import numpy as np\n    pos -= pos.mean(axis=0)\n    lim = np.abs(pos).max()\n    if lim > 0:\n        pos *= scale / lim\n    return pos"
 },
 {
  "docstring": "Return a dictionary of scaled positions keyed by node\n\nParameters\n----------\npos : A dictionary of positions keyed by node\n\nscale : number (default: 1)\n    The size of the resulting extent in all directions.\n\nReturns\n-------\npos : A dictionary of positions keyed by node\n\nExamples\n--------\n>>> import numpy as np\n>>> pos = {0: np.array((0, 0)), 1: np.array((1, 1)), 2: np.array((0.5, 0.5))}\n>>> nx.rescale_layout_dict(pos)\n{0: array([-1., -1.]), 1: array([1., 1.]), 2: array([0., 0.])}\n\n>>> pos = {0: np.array((0, 0)), 1: np.array((-1, 1)), 2: np.array((-0.5, 0.5))}\n>>> nx.rescale_layout_dict(pos, scale=2)\n{0: array([ 2., -2.]), 1: array([-2.,  2.]), 2: array([0., 0.])}\n\nSee Also\n--------\nrescale_layout",
  "code": "def rescale_layout_dict(pos, scale=1):\n    import numpy as np\n    if not pos:\n        return {}\n    pos_v = np.array(list(pos.values()))\n    pos_v = rescale_layout(pos_v, scale=scale)\n    return dict(zip(pos, pos_v))"
 },
 {
  "docstring": "Returns a NetworkX Graph or DiGraph from a PyGraphviz graph.\n\nParameters\n----------\nA : PyGraphviz AGraph\n  A graph created with PyGraphviz\n\ncreate_using : NetworkX graph constructor, optional (default=None)\n   Graph type to create. If graph instance, then cleared before populated.\n   If `None`, then the appropriate Graph type is inferred from `A`.\n\nExamples\n--------\n>>> K5 = nx.complete_graph(5)\n>>> A = nx.nx_agraph.to_agraph(K5)\n>>> G = nx.nx_agraph.from_agraph(A)\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef from_agraph(A, create_using=None):\n    if create_using is None:\n        if A.is_directed():\n            if A.is_strict():\n                create_using = nx.DiGraph\n            else:\n                create_using = nx.MultiDiGraph\n        elif A.is_strict():\n            create_using = nx.Graph\n        else:\n            create_using = nx.MultiGraph\n    N = nx.empty_graph(0, create_using)\n    if A.name is not None:\n        N.name = A.name\n    N.graph.update(A.graph_attr)\n    for n in A.nodes():\n        str_attr = {str(k): v for k, v in n.attr.items()}\n        N.add_node(str(n), **str_attr)\n    for e in A.edges():\n        u, v = (str(e[0]), str(e[1]))\n        attr = dict(e.attr)\n        str_attr = {str(k): v for k, v in attr.items()}\n        if not N.is_multigraph():\n            if e.name is not None:\n                str_attr['key'] = e.name\n            N.add_edge(u, v, **str_attr)\n        else:\n            N.add_edge(u, v, key=e.name, **str_attr)\n    N.graph['graph'] = dict(A.graph_attr)\n    N.graph['node'] = dict(A.node_attr)\n    N.graph['edge'] = dict(A.edge_attr)\n    return N"
 },
 {
  "docstring": "Returns a pygraphviz graph from a NetworkX graph N.\n\nParameters\n----------\nN : NetworkX graph\n  A graph created with NetworkX\n\nExamples\n--------\n>>> K5 = nx.complete_graph(5)\n>>> A = nx.nx_agraph.to_agraph(K5)\n\n",
  "code": "def to_agraph(N):\n    try:\n        import pygraphviz\n    except ImportError as err:\n        raise ImportError('requires pygraphviz http://pygraphviz.github.io/') from err\n    directed = N.is_directed()\n    strict = nx.number_of_selfloops(N) == 0 and (not N.is_multigraph())\n    for node in N:\n        if 'pos' in N.nodes[node]:\n            N.nodes[node]['pos'] = '{},{}!'.format(N.nodes[node]['pos'][0], N.nodes[node]['pos'][1])\n    A = pygraphviz.AGraph(name=N.name, strict=strict, directed=directed)\n    A.graph_attr.update(N.graph.get('graph', {}))\n    A.node_attr.update(N.graph.get('node', {}))\n    A.edge_attr.update(N.graph.get('edge', {}))\n    A.graph_attr.update(((k, v) for k, v in N.graph.items() if k not in ('graph', 'node', 'edge')))\n    for n, nodedata in N.nodes(data=True):\n        A.add_node(n)\n        a = A.get_node(n)\n        a.attr.update({k: str(v) for k, v in nodedata.items()})\n    if N.is_multigraph():\n        for u, v, key, edgedata in N.edges(data=True, keys=True):\n            str_edgedata = {k: str(v) for k, v in edgedata.items() if k != 'key'}\n            A.add_edge(u, v, key=str(key))\n            a = A.get_edge(u, v)\n            a.attr.update(str_edgedata)\n    else:\n        for u, v, edgedata in N.edges(data=True):\n            str_edgedata = {k: str(v) for k, v in edgedata.items()}\n            A.add_edge(u, v)\n            a = A.get_edge(u, v)\n            a.attr.update(str_edgedata)\n    return A"
 },
 {
  "docstring": "Write NetworkX graph G to Graphviz dot format on path.\n\nParameters\n----------\nG : graph\n   A networkx graph\npath : filename\n   Filename or file handle to write\n\n",
  "code": "def write_dot(G, path):\n    A = to_agraph(G)\n    A.write(path)\n    A.clear()\n    return"
 },
 {
  "docstring": "Returns a NetworkX graph from a dot file on path.\n\nParameters\n----------\npath : file or string\n   File name or file handle to read.",
  "code": "@nx._dispatch(name='agraph_read_dot', graphs=None)\ndef read_dot(path):\n    try:\n        import pygraphviz\n    except ImportError as err:\n        raise ImportError('read_dot() requires pygraphviz http://pygraphviz.github.io/') from err\n    A = pygraphviz.AGraph(file=path)\n    gr = from_agraph(A)\n    A.clear()\n    return gr"
 },
 {
  "docstring": "Create node positions for G using Graphviz.\n\nParameters\n----------\nG : NetworkX graph\n  A graph created with NetworkX\nprog : string\n  Name of Graphviz layout program\nroot : string, optional\n  Root node for twopi layout\nargs : string, optional\n  Extra arguments to Graphviz layout program\n\nReturns\n-------\nDictionary of x, y, positions keyed by node.\n\nExamples\n--------\n>>> G = nx.petersen_graph()\n>>> pos = nx.nx_agraph.graphviz_layout(G)\n>>> pos = nx.nx_agraph.graphviz_layout(G, prog=\"dot\")\n\n",
  "code": "def graphviz_layout(G, prog='neato', root=None, args=''):\n    return pygraphviz_layout(G, prog=prog, root=root, args=args)"
 },
 {
  "docstring": "Create node positions for G using Graphviz.\n\nParameters\n----------\nG : NetworkX graph\n  A graph created with NetworkX\nprog : string\n  Name of Graphviz layout program\nroot : string, optional\n  Root node for twopi layout\nargs : string, optional\n  Extra arguments to Graphviz layout program\n\nReturns\n-------\nnode_pos : dict\n  Dictionary of x, y, positions keyed by node.\n\nExamples\n--------\n>>> G = nx.petersen_graph()\n>>> pos = nx.nx_agraph.graphviz_layout(G)\n>>> pos = nx.nx_agraph.graphviz_layout(G, prog=\"dot\")\n\n",
  "code": "def pygraphviz_layout(G, prog='neato', root=None, args=''):\n    try:\n        import pygraphviz\n    except ImportError as err:\n        raise ImportError('requires pygraphviz http://pygraphviz.github.io/') from err\n    if root is not None:\n        args += f'-Groot={root}'\n    A = to_agraph(G)\n    A.layout(prog=prog, args=args)\n    node_pos = {}\n    for n in G:\n        node = pygraphviz.Node(A, n)\n        try:\n            xs = node.attr['pos'].split(',')\n            node_pos[n] = tuple((float(x) for x in xs))\n        except:\n            print('no position for node', n)\n            node_pos[n] = (0.0, 0.0)\n    return node_pos"
 },
 {
  "docstring": "Views the graph G using the specified layout algorithm.\n\nParameters\n----------\nG : NetworkX graph\n    The machine to draw.\nedgelabel : str, callable, None\n    If a string, then it specifies the edge attribute to be displayed\n    on the edge labels. If a callable, then it is called for each\n    edge and it should return the string to be displayed on the edges.\n    The function signature of `edgelabel` should be edgelabel(data),\n    where `data` is the edge attribute dictionary.\nprog : string\n    Name of Graphviz layout program.\nargs : str\n    Additional arguments to pass to the Graphviz layout program.\nsuffix : str\n    If `filename` is None, we save to a temporary file.  The value of\n    `suffix` will appear at the tail end of the temporary filename.\npath : str, None\n    The filename used to save the image.  If None, save to a temporary\n    file.  File formats are the same as those from pygraphviz.agraph.draw.\nshow : bool, default = True\n    Whether to display the graph with :mod:`PIL.Image.show`,\n    default is `True`. If `False`, the rendered graph is still available\n    at `path`.\n\nReturns\n-------\npath : str\n    The filename of the generated image.\nA : PyGraphviz graph\n    The PyGraphviz graph instance used to generate the image.\n\n",
  "code": "@nx.utils.open_file(5, 'w+b')\ndef view_pygraphviz(G, edgelabel=None, prog='dot', args='', suffix='', path=None, show=True):\n    if not len(G):\n        raise nx.NetworkXException('An empty graph cannot be drawn.')\n    attrs = ['edge', 'node', 'graph']\n    for attr in attrs:\n        if attr not in G.graph:\n            G.graph[attr] = {}\n    edge_attrs = {'fontsize': '10'}\n    node_attrs = {'style': 'filled', 'fillcolor': '#0000FF40', 'height': '0.75', 'width': '0.75', 'shape': 'circle'}\n    graph_attrs = {}\n\n    def update_attrs(which, attrs):\n        added = []\n        for k, v in attrs.items():\n            if k not in G.graph[which]:\n                G.graph[which][k] = v\n                added.append(k)\n\n    def clean_attrs(which, added):\n        for attr in added:\n            del G.graph[which][attr]\n        if not G.graph[which]:\n            del G.graph[which]\n    update_attrs('edge', edge_attrs)\n    update_attrs('node', node_attrs)\n    update_attrs('graph', graph_attrs)\n    A = to_agraph(G)\n    clean_attrs('edge', edge_attrs)\n    clean_attrs('node', node_attrs)\n    clean_attrs('graph', graph_attrs)\n    if edgelabel is not None:\n        if not callable(edgelabel):\n\n            def func(data):\n                return ''.join(['  ', str(data[edgelabel]), '  '])\n        else:\n            func = edgelabel\n        if G.is_multigraph():\n            for u, v, key, data in G.edges(keys=True, data=True):\n                edge = A.get_edge(u, v, str(key))\n                edge.attr['label'] = str(func(data))\n        else:\n            for u, v, data in G.edges(data=True):\n                edge = A.get_edge(u, v)\n                edge.attr['label'] = str(func(data))\n    if path is None:\n        ext = 'png'\n        if suffix:\n            suffix = f'_{suffix}.{ext}'\n        else:\n            suffix = f'.{ext}'\n        path = tempfile.NamedTemporaryFile(suffix=suffix, delete=False)\n    else:\n        pass\n    A.draw(path=path, format=None, prog=prog, args=args)\n    path.close()\n    if show:\n        from PIL import Image\n        Image.open(path.name).show()\n    return (path.name, A)"
 },
 {
  "docstring": "Return a string of the LaTeX/TikZ code to draw `G`\n\nThis function produces just the code for the tikzpicture\nwithout any enclosing environment.\n\nParameters\n==========\nG : NetworkX graph\n    The NetworkX graph to be drawn\npos : string or dict (default \"pos\")\n    The name of the node attribute on `G` that holds the position of each node.\n    Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n    They can also be strings to denote positions in TikZ style, such as (x, y)\n    or (angle:radius).\n    If a dict, it should be keyed by node to a position.\n    If an empty dict, a circular layout is computed by TikZ.\ntikz_options : string\n    The tikzpicture options description defining the options for the picture.\n    Often large scale options like `[scale=2]`.\ndefault_node_options : string\n    The draw options for a path of nodes. Individual node options override these.\nnode_options : string or dict\n    The name of the node attribute on `G` that holds the options for each node.\n    Or a dict keyed by node to a string holding the options for that node.\nnode_label : string or dict\n    The name of the node attribute on `G` that holds the node label (text)\n    displayed for each node. If the attribute is \"\" or not present, the node\n    itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n    Or a dict keyed by node to a string holding the label for that node.\ndefault_edge_options : string\n    The options for the scope drawing all edges. The default is \"[-]\" for\n    undirected graphs and \"[->]\" for directed graphs.\nedge_options : string or dict\n    The name of the edge attribute on `G` that holds the options for each edge.\n    If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n    \"loop,\" is added to the options for the self-loop edge. Hence you can\n    use \"[loop above]\" explicitly, but the default is \"[loop]\".\n    Or a dict keyed by edge to a string holding the options for that edge.\nedge_label : string or dict\n    The name of the edge attribute on `G` that holds the edge label (text)\n    displayed for each edge. If the attribute is \"\" or not present, no edge\n    label is drawn.\n    Or a dict keyed by edge to a string holding the label for that edge.\nedge_label_options : string or dict\n    The name of the edge attribute on `G` that holds the label options for\n    each edge. For example, \"[sloped,above,blue]\". The default is no options.\n    Or a dict keyed by edge to a string holding the label options for that edge.\n\nReturns\n=======\nlatex_code : string\n   The text string which draws the desired graph(s) when compiled by LaTeX.\n\nSee Also\n========\nto_latex\nwrite_latex",
  "code": "@nx.utils.not_implemented_for('multigraph')\ndef to_latex_raw(G, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='label', default_edge_options='', edge_options='edge_options', edge_label='label', edge_label_options='edge_label_options'):\n    i4 = '\\n    '\n    i8 = '\\n        '\n    if not isinstance(pos, dict):\n        pos = nx.get_node_attributes(G, pos)\n    if not pos:\n        pos = {n: f'({round(360.0 * i / len(G), 3)}:2)' for i, n in enumerate(G)}\n    for node in G:\n        if node not in pos:\n            raise nx.NetworkXError(f'node {node} has no specified pos {pos}')\n        posnode = pos[node]\n        if not isinstance(posnode, str):\n            try:\n                posx, posy = posnode\n                pos[node] = f'({round(posx, 3)}, {round(posy, 3)})'\n            except (TypeError, ValueError):\n                msg = f'position pos[{node}] is not 2-tuple or a string: {posnode}'\n                raise nx.NetworkXError(msg)\n    if not isinstance(node_options, dict):\n        node_options = nx.get_node_attributes(G, node_options)\n    if not isinstance(node_label, dict):\n        node_label = nx.get_node_attributes(G, node_label)\n    if not isinstance(edge_options, dict):\n        edge_options = nx.get_edge_attributes(G, edge_options)\n    if not isinstance(edge_label, dict):\n        edge_label = nx.get_edge_attributes(G, edge_label)\n    if not isinstance(edge_label_options, dict):\n        edge_label_options = nx.get_edge_attributes(G, edge_label_options)\n    topts = '' if tikz_options == '' else f'[{tikz_options.strip('[]')}]'\n    defn = '' if default_node_options == '' else f'[{default_node_options.strip('[]')}]'\n    linestyle = f'{('->' if G.is_directed() else '-')}'\n    if default_edge_options == '':\n        defe = '[' + linestyle + ']'\n    elif '-' in default_edge_options:\n        defe = default_edge_options\n    else:\n        defe = f'[{linestyle},{default_edge_options.strip('[]')}]'\n    result = '  \\\\begin{tikzpicture}' + topts\n    result += i4 + '  \\\\draw' + defn\n    for n in G:\n        nopts = f'[{node_options[n].strip('[]')}]' if n in node_options else ''\n        ntext = f'{{{node_label[n]}}}' if n in node_label else f'{{{n}}}'\n        result += i8 + f'{pos[n]} node{nopts} ({n}){ntext}'\n    result += ';\\n'\n    result += '      \\\\begin{scope}' + defe\n    for edge in G.edges:\n        u, v = edge[:2]\n        e_opts = f'{edge_options[edge]}'.strip('[]') if edge in edge_options else ''\n        if u == v and 'loop' not in e_opts:\n            e_opts = 'loop,' + e_opts\n        e_opts = f'[{e_opts}]' if e_opts != '' else ''\n        els = edge_label_options[edge] if edge in edge_label_options else ''\n        els = f'[{els.strip('[]')}]'\n        e_label = f' node{els} {{{edge_label[edge]}}}' if edge in edge_label else ''\n        result += i8 + f'\\\\draw{e_opts} ({u}) to{e_label} ({v});'\n    result += '\\n      \\\\end{scope}\\n    \\\\end{tikzpicture}\\n'\n    return result"
 },
 {
  "docstring": "Return latex code to draw the graph(s) in `Gbunch`\n\nThe TikZ drawing utility in LaTeX is used to draw the graph(s).\nIf `Gbunch` is a graph, it is drawn in a figure environment.\nIf `Gbunch` is an iterable of graphs, each is drawn in a subfigure environment\nwithin a single figure environment.\n\nIf `as_document` is True, the figure is wrapped inside a document environment\nso that the resulting string is ready to be compiled by LaTeX. Otherwise,\nthe string is ready for inclusion in a larger tex document using ``\\include``\nor ``\\input`` statements.\n\nParameters\n==========\nGbunch : NetworkX graph or iterable of NetworkX graphs\n    The NetworkX graph to be drawn or an iterable of graphs\n    to be drawn inside subfigures of a single figure.\npos : string or list of strings\n    The name of the node attribute on `G` that holds the position of each node.\n    Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n    They can also be strings to denote positions in TikZ style, such as (x, y)\n    or (angle:radius).\n    If a dict, it should be keyed by node to a position.\n    If an empty dict, a circular layout is computed by TikZ.\n    If you are drawing many graphs in subfigures, use a list of position dicts.\ntikz_options : string\n    The tikzpicture options description defining the options for the picture.\n    Often large scale options like `[scale=2]`.\ndefault_node_options : string\n    The draw options for a path of nodes. Individual node options override these.\nnode_options : string or dict\n    The name of the node attribute on `G` that holds the options for each node.\n    Or a dict keyed by node to a string holding the options for that node.\nnode_label : string or dict\n    The name of the node attribute on `G` that holds the node label (text)\n    displayed for each node. If the attribute is \"\" or not present, the node\n    itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n    Or a dict keyed by node to a string holding the label for that node.\ndefault_edge_options : string\n    The options for the scope drawing all edges. The default is \"[-]\" for\n    undirected graphs and \"[->]\" for directed graphs.\nedge_options : string or dict\n    The name of the edge attribute on `G` that holds the options for each edge.\n    If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n    \"loop,\" is added to the options for the self-loop edge. Hence you can\n    use \"[loop above]\" explicitly, but the default is \"[loop]\".\n    Or a dict keyed by edge to a string holding the options for that edge.\nedge_label : string or dict\n    The name of the edge attribute on `G` that holds the edge label (text)\n    displayed for each edge. If the attribute is \"\" or not present, no edge\n    label is drawn.\n    Or a dict keyed by edge to a string holding the label for that edge.\nedge_label_options : string or dict\n    The name of the edge attribute on `G` that holds the label options for\n    each edge. For example, \"[sloped,above,blue]\". The default is no options.\n    Or a dict keyed by edge to a string holding the label options for that edge.\ncaption : string\n    The caption string for the figure environment\nlatex_label : string\n    The latex label used for the figure for easy referral from the main text\nsub_captions : list of strings\n    The sub_caption string for each subfigure in the figure\nsub_latex_labels : list of strings\n    The latex label for each subfigure in the figure\nn_rows : int\n    The number of rows of subfigures to arrange for multiple graphs\nas_document : bool\n    Whether to wrap the latex code in a document environment for compiling\ndocument_wrapper : formatted text string with variable ``content``.\n    This text is called to evaluate the content embedded in a document\n    environment with a preamble setting up TikZ.\nfigure_wrapper : formatted text string\n    This text is evaluated with variables ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\nsubfigure_wrapper : formatted text string\n    This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\n    It wraps the content and if a caption is provided, adds the latex code for\n    that caption, and if a label is provided, adds the latex code for a label.\n    The size is the vertical size of each row of subfigures as a fraction.\n\nReturns\n=======\nlatex_code : string\n    The text string which draws the desired graph(s) when compiled by LaTeX.\n\nSee Also\n========\nwrite_latex\nto_latex_raw",
  "code": "def to_latex(Gbunch, pos='pos', tikz_options='', default_node_options='', node_options='node_options', node_label='node_label', default_edge_options='', edge_options='edge_options', edge_label='edge_label', edge_label_options='edge_label_options', caption='', latex_label='', sub_captions=None, sub_labels=None, n_rows=1, as_document=True, document_wrapper=_DOC_WRAPPER_TIKZ, figure_wrapper=_FIG_WRAPPER, subfigure_wrapper=_SUBFIG_WRAPPER):\n    if hasattr(Gbunch, 'adj'):\n        raw = to_latex_raw(Gbunch, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n    else:\n        sbf = subfigure_wrapper\n        size = 1 / n_rows\n        N = len(Gbunch)\n        if isinstance(pos, str | dict):\n            pos = [pos] * N\n        if sub_captions is None:\n            sub_captions = [''] * N\n        if sub_labels is None:\n            sub_labels = [''] * N\n        if not len(Gbunch) == len(pos) == len(sub_captions) == len(sub_labels):\n            raise nx.NetworkXError('length of Gbunch, sub_captions and sub_figures must agree')\n        raw = ''\n        for G, pos, subcap, sublbl in zip(Gbunch, pos, sub_captions, sub_labels):\n            subraw = to_latex_raw(G, pos, tikz_options, default_node_options, node_options, node_label, default_edge_options, edge_options, edge_label, edge_label_options)\n            cap = f'    \\\\caption{{{subcap}}}' if subcap else ''\n            lbl = f'\\\\label{{{sublbl}}}' if sublbl else ''\n            raw += sbf.format(size=size, content=subraw, caption=cap, label=lbl)\n            raw += '\\n'\n    raw = raw[:-1]\n    cap = f'\\n  \\\\caption{{{caption}}}' if caption else ''\n    lbl = f'\\\\label{{{latex_label}}}' if latex_label else ''\n    fig = figure_wrapper.format(content=raw, caption=cap, label=lbl)\n    if as_document:\n        return document_wrapper.format(content=fig)\n    return fig"
 },
 {
  "docstring": "Write the latex code to draw the graph(s) onto `path`.\n\nThis convenience function creates the latex drawing code as a string\nand writes that to a file ready to be compiled when `as_document` is True\nor ready to be ``import`` ed or ``include`` ed into your main LaTeX document.\n\nThe `path` argument can be a string filename or a file handle to write to.\n\nParameters\n----------\nGbunch : NetworkX graph or iterable of NetworkX graphs\n    If Gbunch is a graph, it is drawn in a figure environment.\n    If Gbunch is an iterable of graphs, each is drawn in a subfigure\n    environment within a single figure environment.\npath : filename\n    Filename or file handle to write to\noptions : dict\n    By default, TikZ is used with options: (others are ignored)::\n\n        pos : string or dict or list\n            The name of the node attribute on `G` that holds the position of each node.\n            Positions can be sequences of length 2 with numbers for (x,y) coordinates.\n            They can also be strings to denote positions in TikZ style, such as (x, y)\n            or (angle:radius).\n            If a dict, it should be keyed by node to a position.\n            If an empty dict, a circular layout is computed by TikZ.\n            If you are drawing many graphs in subfigures, use a list of position dicts.\n        tikz_options : string\n            The tikzpicture options description defining the options for the picture.\n            Often large scale options like `[scale=2]`.\n        default_node_options : string\n            The draw options for a path of nodes. Individual node options override these.\n        node_options : string or dict\n            The name of the node attribute on `G` that holds the options for each node.\n            Or a dict keyed by node to a string holding the options for that node.\n        node_label : string or dict\n            The name of the node attribute on `G` that holds the node label (text)\n            displayed for each node. If the attribute is \"\" or not present, the node\n            itself is drawn as a string. LaTeX processing such as ``\"$A_1$\"`` is allowed.\n            Or a dict keyed by node to a string holding the label for that node.\n        default_edge_options : string\n            The options for the scope drawing all edges. The default is \"[-]\" for\n            undirected graphs and \"[->]\" for directed graphs.\n        edge_options : string or dict\n            The name of the edge attribute on `G` that holds the options for each edge.\n            If the edge is a self-loop and ``\"loop\" not in edge_options`` the option\n            \"loop,\" is added to the options for the self-loop edge. Hence you can\n            use \"[loop above]\" explicitly, but the default is \"[loop]\".\n            Or a dict keyed by edge to a string holding the options for that edge.\n        edge_label : string or dict\n            The name of the edge attribute on `G` that holds the edge label (text)\n            displayed for each edge. If the attribute is \"\" or not present, no edge\n            label is drawn.\n            Or a dict keyed by edge to a string holding the label for that edge.\n        edge_label_options : string or dict\n            The name of the edge attribute on `G` that holds the label options for\n            each edge. For example, \"[sloped,above,blue]\". The default is no options.\n            Or a dict keyed by edge to a string holding the label options for that edge.\n        caption : string\n            The caption string for the figure environment\n        latex_label : string\n            The latex label used for the figure for easy referral from the main text\n        sub_captions : list of strings\n            The sub_caption string for each subfigure in the figure\n        sub_latex_labels : list of strings\n            The latex label for each subfigure in the figure\n        n_rows : int\n            The number of rows of subfigures to arrange for multiple graphs\n        as_document : bool\n            Whether to wrap the latex code in a document environment for compiling\n        document_wrapper : formatted text string with variable ``content``.\n            This text is called to evaluate the content embedded in a document\n            environment with a preamble setting up the TikZ syntax.\n        figure_wrapper : formatted text string\n            This text is evaluated with variables ``content``, ``caption`` and ``label``.\n            It wraps the content and if a caption is provided, adds the latex code for\n            that caption, and if a label is provided, adds the latex code for a label.\n        subfigure_wrapper : formatted text string\n            This text evaluate variables ``size``, ``content``, ``caption`` and ``label``.\n            It wraps the content and if a caption is provided, adds the latex code for\n            that caption, and if a label is provided, adds the latex code for a label.\n            The size is the vertical size of each row of subfigures as a fraction.\n\nSee Also\n========\nto_latex",
  "code": "@nx.utils.open_file(1, mode='w')\ndef write_latex(Gbunch, path, **options):\n    path.write(to_latex(Gbunch, **options))"
 },
 {
  "docstring": "Write NetworkX graph G to Graphviz dot format on path.\n\nPath can be a string or a file handle.",
  "code": "@open_file(1, mode='w')\ndef write_dot(G, path):\n    msg = 'nx.nx_pydot.write_dot depends on the pydot package, which has known issues and is not actively maintained. Consider using nx.nx_agraph.write_dot instead.\\n\\nSee https://github.com/networkx/networkx/issues/5723'\n    warnings.warn(msg, DeprecationWarning, stacklevel=2)\n    P = to_pydot(G)\n    path.write(P.to_string())\n    return"
 },
 {
  "docstring": "Returns a NetworkX :class:`MultiGraph` or :class:`MultiDiGraph` from the\ndot file with the passed path.\n\nIf this file contains multiple graphs, only the first such graph is\nreturned. All graphs _except_ the first are silently ignored.\n\nParameters\n----------\npath : str or file\n    Filename or file handle.\n\nReturns\n-------\nG : MultiGraph or MultiDiGraph\n    A :class:`MultiGraph` or :class:`MultiDiGraph`.\n\n",
  "code": "@open_file(0, mode='r')\n@nx._dispatch(name='pydot_read_dot', graphs=None)\ndef read_dot(path):\n    import pydot\n    msg = 'nx.nx_pydot.read_dot depends on the pydot package, which has known issues and is not actively maintained. Consider using nx.nx_agraph.read_dot instead.\\n\\nSee https://github.com/networkx/networkx/issues/5723'\n    warnings.warn(msg, DeprecationWarning, stacklevel=2)\n    data = path.read()\n    P_list = pydot.graph_from_dot_data(data)\n    return from_pydot(P_list[0])"
 },
 {
  "docstring": "Returns a NetworkX graph from a Pydot graph.\n\nParameters\n----------\nP : Pydot graph\n  A graph created with Pydot\n\nReturns\n-------\nG : NetworkX multigraph\n    A MultiGraph or MultiDiGraph.\n\nExamples\n--------\n>>> K5 = nx.complete_graph(5)\n>>> A = nx.nx_pydot.to_pydot(K5)\n>>> G = nx.nx_pydot.from_pydot(A)  # return MultiGraph\n\n# make a Graph instead of MultiGraph\n>>> G = nx.Graph(nx.nx_pydot.from_pydot(A))",
  "code": "@nx._dispatch(graphs=None)\ndef from_pydot(P):\n    msg = 'nx.nx_pydot.from_pydot depends on the pydot package, which has known issues and is not actively maintained.\\n\\nSee https://github.com/networkx/networkx/issues/5723'\n    warnings.warn(msg, DeprecationWarning, stacklevel=2)\n    if P.get_strict(None):\n        multiedges = False\n    else:\n        multiedges = True\n    if P.get_type() == 'graph':\n        if multiedges:\n            N = nx.MultiGraph()\n        else:\n            N = nx.Graph()\n    elif multiedges:\n        N = nx.MultiDiGraph()\n    else:\n        N = nx.DiGraph()\n    name = P.get_name().strip('\"')\n    if name != '':\n        N.name = name\n    for p in P.get_node_list():\n        n = p.get_name().strip('\"')\n        if n in ('node', 'graph', 'edge'):\n            continue\n        N.add_node(n, **p.get_attributes())\n    for e in P.get_edge_list():\n        u = e.get_source()\n        v = e.get_destination()\n        attr = e.get_attributes()\n        s = []\n        d = []\n        if isinstance(u, str):\n            s.append(u.strip('\"'))\n        else:\n            for unodes in u['nodes']:\n                s.append(unodes.strip('\"'))\n        if isinstance(v, str):\n            d.append(v.strip('\"'))\n        else:\n            for vnodes in v['nodes']:\n                d.append(vnodes.strip('\"'))\n        for source_node in s:\n            for destination_node in d:\n                N.add_edge(source_node, destination_node, **attr)\n    pattr = P.get_attributes()\n    if pattr:\n        N.graph['graph'] = pattr\n    try:\n        N.graph['node'] = P.get_node_defaults()[0]\n    except (IndexError, TypeError):\n        pass\n    try:\n        N.graph['edge'] = P.get_edge_defaults()[0]\n    except (IndexError, TypeError):\n        pass\n    return N"
 },
 {
  "docstring": "Returns a pydot graph from a NetworkX graph N.\n\nParameters\n----------\nN : NetworkX graph\n  A graph created with NetworkX\n\nExamples\n--------\n>>> K5 = nx.complete_graph(5)\n>>> P = nx.nx_pydot.to_pydot(K5)\n\n",
  "code": "def to_pydot(N):\n    import pydot\n    msg = 'nx.nx_pydot.to_pydot depends on the pydot package, which has known issues and is not actively maintained.\\n\\nSee https://github.com/networkx/networkx/issues/5723'\n    warnings.warn(msg, DeprecationWarning, stacklevel=2)\n    if N.is_directed():\n        graph_type = 'digraph'\n    else:\n        graph_type = 'graph'\n    strict = nx.number_of_selfloops(N) == 0 and (not N.is_multigraph())\n    name = N.name\n    graph_defaults = N.graph.get('graph', {})\n    if name == '':\n        P = pydot.Dot('', graph_type=graph_type, strict=strict, **graph_defaults)\n    else:\n        P = pydot.Dot(f'\"{name}\"', graph_type=graph_type, strict=strict, **graph_defaults)\n    try:\n        P.set_node_defaults(**N.graph['node'])\n    except KeyError:\n        pass\n    try:\n        P.set_edge_defaults(**N.graph['edge'])\n    except KeyError:\n        pass\n    for n, nodedata in N.nodes(data=True):\n        str_nodedata = {str(k): str(v) for k, v in nodedata.items()}\n        n = str(n)\n        raise_error = _check_colon_quotes(n) or any((_check_colon_quotes(k) or _check_colon_quotes(v) for k, v in str_nodedata.items()))\n        if raise_error:\n            raise ValueError(f\"\"\"Node names and attributes should not contain \":\" unless they are quoted with \"\".                For example the string 'attribute:data1' should be written as '\"attribute:data1\"'.                Please refer https://github.com/pydot/pydot/issues/258\"\"\")\n        p = pydot.Node(n, **str_nodedata)\n        P.add_node(p)\n    if N.is_multigraph():\n        for u, v, key, edgedata in N.edges(data=True, keys=True):\n            str_edgedata = {str(k): str(v) for k, v in edgedata.items() if k != 'key'}\n            u, v = (str(u), str(v))\n            raise_error = _check_colon_quotes(u) or _check_colon_quotes(v) or any((_check_colon_quotes(k) or _check_colon_quotes(val) for k, val in str_edgedata.items()))\n            if raise_error:\n                raise ValueError(f\"\"\"Node names and attributes should not contain \":\" unless they are quoted with \"\".                    For example the string 'attribute:data1' should be written as '\"attribute:data1\"'.                    Please refer https://github.com/pydot/pydot/issues/258\"\"\")\n            edge = pydot.Edge(u, v, key=str(key), **str_edgedata)\n            P.add_edge(edge)\n    else:\n        for u, v, edgedata in N.edges(data=True):\n            str_edgedata = {str(k): str(v) for k, v in edgedata.items()}\n            u, v = (str(u), str(v))\n            raise_error = _check_colon_quotes(u) or _check_colon_quotes(v) or any((_check_colon_quotes(k) or _check_colon_quotes(val) for k, val in str_edgedata.items()))\n            if raise_error:\n                raise ValueError(f\"\"\"Node names and attributes should not contain \":\" unless they are quoted with \"\".                    For example the string 'attribute:data1' should be written as '\"attribute:data1\"'.                    Please refer https://github.com/pydot/pydot/issues/258\"\"\")\n            edge = pydot.Edge(u, v, **str_edgedata)\n            P.add_edge(edge)\n    return P"
 },
 {
  "docstring": "Create node positions using Pydot and Graphviz.\n\nReturns a dictionary of positions keyed by node.\n\nParameters\n----------\nG : NetworkX Graph\n    The graph for which the layout is computed.\nprog : string (default: 'neato')\n    The name of the GraphViz program to use for layout.\n    Options depend on GraphViz version but may include:\n    'dot', 'twopi', 'fdp', 'sfdp', 'circo'\nroot : Node from G or None (default: None)\n    The node of G from which to start some layout algorithms.\n\nReturns\n-------\n  Dictionary of (x, y) positions keyed by node.\n\nExamples\n--------\n>>> G = nx.complete_graph(4)\n>>> pos = nx.nx_pydot.graphviz_layout(G)\n>>> pos = nx.nx_pydot.graphviz_layout(G, prog=\"dot\")\n\n",
  "code": "def graphviz_layout(G, prog='neato', root=None):\n    msg = 'nx.nx_pydot.graphviz_layout depends on the pydot package, which has known issues and is not actively maintained. Consider using nx.nx_agraph.graphviz_layout instead.\\n\\nSee https://github.com/networkx/networkx/issues/5723'\n    warnings.warn(msg, DeprecationWarning, stacklevel=2)\n    return pydot_layout(G=G, prog=prog, root=root)"
 },
 {
  "docstring": "Create node positions using :mod:`pydot` and Graphviz.\n\nParameters\n----------\nG : Graph\n    NetworkX graph to be laid out.\nprog : string  (default: 'neato')\n    Name of the GraphViz command to use for layout.\n    Options depend on GraphViz version but may include:\n    'dot', 'twopi', 'fdp', 'sfdp', 'circo'\nroot : Node from G or None (default: None)\n    The node of G from which to start some layout algorithms.\n\nReturns\n-------\ndict\n    Dictionary of positions keyed by node.\n\nExamples\n--------\n>>> G = nx.complete_graph(4)\n>>> pos = nx.nx_pydot.pydot_layout(G)\n>>> pos = nx.nx_pydot.pydot_layout(G, prog=\"dot\")\n\n",
  "code": "def pydot_layout(G, prog='neato', root=None):\n    import pydot\n    msg = 'nx.nx_pydot.pydot_layout depends on the pydot package, which has known issues and is not actively maintained.\\n\\nSee https://github.com/networkx/networkx/issues/5723'\n    warnings.warn(msg, DeprecationWarning, stacklevel=2)\n    P = to_pydot(G)\n    if root is not None:\n        P.set('root', str(root))\n    D_bytes = P.create_dot(prog=prog)\n    D = str(D_bytes, encoding=getpreferredencoding())\n    if D == '':\n        print(f'Graphviz layout with {prog} failed')\n        print()\n        print('To debug what happened try:')\n        print('P = nx.nx_pydot.to_pydot(G)')\n        print('P.write_dot(\"file.dot\")')\n        print(f'And then run {prog} on file.dot')\n        return\n    Q_list = pydot.graph_from_dot_data(D)\n    assert len(Q_list) == 1\n    Q = Q_list[0]\n    node_pos = {}\n    for n in G.nodes():\n        str_n = str(n)\n        if _check_colon_quotes(str_n):\n            raise ValueError(f\"\"\"Node names and node attributes should not contain \":\" unless they are quoted with \"\".                For example the string 'attribute:data1' should be written as '\"attribute:data1\"'.                Please refer https://github.com/pydot/pydot/issues/258\"\"\")\n        pydot_node = pydot.Node(str_n).get_name()\n        node = Q.get_node(pydot_node)\n        if isinstance(node, list):\n            node = node[0]\n        pos = node.get_pos()[1:-1]\n        if pos is not None:\n            xx, yy = pos.split(',')\n            node_pos[n] = (float(xx), float(yy))\n    return node_pos"
 },
 {
  "docstring": "Draw the graph G with Matplotlib.\n\nDraw the graph as a simple representation with no node\nlabels or edge labels and using the full Matplotlib figure area\nand no axis labels by default.  See draw_networkx() for more\nfull-featured drawing that allows title, axis labels etc.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary, optional\n    A dictionary with nodes as keys and positions as values.\n    If not specified a spring layout positioning will be computed.\n    See :py:mod:`networkx.drawing.layout` for functions that\n    compute node positions.\n\nax : Matplotlib Axes object, optional\n    Draw the graph in specified Matplotlib axes.\n\nkwds : optional keywords\n    See networkx.draw_networkx() for a description of optional keywords.\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> nx.draw(G)\n>>> nx.draw(G, pos=nx.spring_layout(G))  # use spring layout\n\nSee Also\n--------\ndraw_networkx\ndraw_networkx_nodes\ndraw_networkx_edges\ndraw_networkx_labels\ndraw_networkx_edge_labels\n\n",
  "code": "def draw(G, pos=None, ax=None, **kwds):\n    import matplotlib.pyplot as plt\n    if ax is None:\n        cf = plt.gcf()\n    else:\n        cf = ax.get_figure()\n    cf.set_facecolor('w')\n    if ax is None:\n        if cf.axes:\n            ax = cf.gca()\n        else:\n            ax = cf.add_axes((0, 0, 1, 1))\n    if 'with_labels' not in kwds:\n        kwds['with_labels'] = 'labels' in kwds\n    draw_networkx(G, pos=pos, ax=ax, **kwds)\n    ax.set_axis_off()\n    plt.draw_if_interactive()\n    return"
 },
 {
  "docstring": "Draw the graph G using Matplotlib.\n\nDraw the graph with Matplotlib with options for node positions,\nlabeling, titles, and many other drawing features.\nSee draw() for simple drawing without labels or axes.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary, optional\n    A dictionary with nodes as keys and positions as values.\n    If not specified a spring layout positioning will be computed.\n    See :py:mod:`networkx.drawing.layout` for functions that\n    compute node positions.\n\narrows : bool or None, optional (default=None)\n    If `None`, directed graphs draw arrowheads with\n    `~matplotlib.patches.FancyArrowPatch`, while undirected graphs draw edges\n    via `~matplotlib.collections.LineCollection` for speed.\n    If `True`, draw arrowheads with FancyArrowPatches (bendable and stylish).\n    If `False`, draw edges using LineCollection (linear and fast).\n    For directed graphs, if True draw arrowheads.\n    Note: Arrows will be the same color as edges.\n\narrowstyle : str (default='-\\|>' for directed graphs)\n    For directed graphs, choose the style of the arrowsheads.\n    For undirected graphs default to '-'\n\n    See `matplotlib.patches.ArrowStyle` for more options.\n\narrowsize : int or list (default=10)\n    For directed graphs, choose the size of the arrow head's length and\n    width. A list of values can be passed in to assign a different size for arrow head's length and width.\n    See `matplotlib.patches.FancyArrowPatch` for attribute `mutation_scale`\n    for more info.\n\nwith_labels :  bool (default=True)\n    Set to True to draw labels on the nodes.\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\nnodelist : list (default=list(G))\n    Draw only specified nodes\n\nedgelist : list (default=list(G.edges()))\n    Draw only specified edges\n\nnode_size : scalar or array (default=300)\n    Size of nodes.  If an array is specified it must be the\n    same length as nodelist.\n\nnode_color : color or array of colors (default='#1f78b4')\n    Node color. Can be a single color or a sequence of colors with the same\n    length as nodelist. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1. If numeric values are specified they will be\n    mapped to colors using the cmap and vmin,vmax parameters. See\n    matplotlib.scatter for more details.\n\nnode_shape :  string (default='o')\n    The shape of the node.  Specification is as matplotlib.scatter\n    marker, one of 'so^>v<dph8'.\n\nalpha : float or None (default=None)\n    The node and edge transparency\n\ncmap : Matplotlib colormap, optional\n    Colormap for mapping intensities of nodes\n\nvmin,vmax : float, optional\n    Minimum and maximum for node colormap scaling\n\nlinewidths : scalar or sequence (default=1.0)\n    Line width of symbol border\n\nwidth : float or array of floats (default=1.0)\n    Line width of edges\n\nedge_color : color or array of colors (default='k')\n    Edge color. Can be a single color or a sequence of colors with the same\n    length as edgelist. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1. If numeric values are specified they will be\n    mapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.\n\nedge_cmap : Matplotlib colormap, optional\n    Colormap for mapping intensities of edges\n\nedge_vmin,edge_vmax : floats, optional\n    Minimum and maximum for edge colormap scaling\n\nstyle : string (default=solid line)\n    Edge line style e.g.: '-', '--', '-.', ':'\n    or words like 'solid' or 'dashed'.\n    (See `matplotlib.patches.FancyArrowPatch`: `linestyle`)\n\nlabels : dictionary (default=None)\n    Node labels in a dictionary of text labels keyed by node\n\nfont_size : int (default=12 for nodes, 10 for edges)\n    Font size for text labels\n\nfont_color : color (default='k' black)\n    Font color string. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1.\n\nfont_weight : string (default='normal')\n    Font weight\n\nfont_family : string (default='sans-serif')\n    Font family\n\nlabel : string, optional\n    Label for graph legend\n\nkwds : optional keywords\n    See networkx.draw_networkx_nodes(), networkx.draw_networkx_edges(), and\n    networkx.draw_networkx_labels() for a description of optional keywords.\n\n",
  "code": "def draw_networkx(G, pos=None, arrows=None, with_labels=True, **kwds):\n    from inspect import signature\n    import matplotlib.pyplot as plt\n    valid_node_kwds = signature(draw_networkx_nodes).parameters.keys()\n    valid_edge_kwds = signature(draw_networkx_edges).parameters.keys()\n    valid_label_kwds = signature(draw_networkx_labels).parameters.keys()\n    valid_kwds = (valid_node_kwds | valid_edge_kwds | valid_label_kwds) - {'G', 'pos', 'arrows', 'with_labels'}\n    if any((k not in valid_kwds for k in kwds)):\n        invalid_args = ', '.join([k for k in kwds if k not in valid_kwds])\n        raise ValueError(f'Received invalid argument(s): {invalid_args}')\n    node_kwds = {k: v for k, v in kwds.items() if k in valid_node_kwds}\n    edge_kwds = {k: v for k, v in kwds.items() if k in valid_edge_kwds}\n    label_kwds = {k: v for k, v in kwds.items() if k in valid_label_kwds}\n    if pos is None:\n        pos = nx.drawing.spring_layout(G)\n    draw_networkx_nodes(G, pos, **node_kwds)\n    draw_networkx_edges(G, pos, arrows=arrows, **edge_kwds)\n    if with_labels:\n        draw_networkx_labels(G, pos, **label_kwds)\n    plt.draw_if_interactive()"
 },
 {
  "docstring": "Draw the nodes of the graph G.\n\nThis draws only the nodes of the graph G.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary\n    A dictionary with nodes as keys and positions as values.\n    Positions should be sequences of length 2.\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\nnodelist : list (default list(G))\n    Draw only specified nodes\n\nnode_size : scalar or array (default=300)\n    Size of nodes.  If an array it must be the same length as nodelist.\n\nnode_color : color or array of colors (default='#1f78b4')\n    Node color. Can be a single color or a sequence of colors with the same\n    length as nodelist. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1. If numeric values are specified they will be\n    mapped to colors using the cmap and vmin,vmax parameters. See\n    matplotlib.scatter for more details.\n\nnode_shape :  string (default='o')\n    The shape of the node.  Specification is as matplotlib.scatter\n    marker, one of 'so^>v<dph8'.\n\nalpha : float or array of floats (default=None)\n    The node transparency.  This can be a single alpha value,\n    in which case it will be applied to all the nodes of color. Otherwise,\n    if it is an array, the elements of alpha will be applied to the colors\n    in order (cycling through alpha multiple times if necessary).\n\ncmap : Matplotlib colormap (default=None)\n    Colormap for mapping intensities of nodes\n\nvmin,vmax : floats or None (default=None)\n    Minimum and maximum for node colormap scaling\n\nlinewidths : [None | scalar | sequence] (default=1.0)\n    Line width of symbol border\n\nedgecolors : [None | scalar | sequence] (default = node_color)\n    Colors of node borders. Can be a single color or a sequence of colors with the\n    same length as nodelist. Color can be string or rgb (or rgba) tuple of floats\n    from 0-1. If numeric values are specified they will be mapped to colors\n    using the cmap and vmin,vmax parameters. See `~matplotlib.pyplot.scatter` for more details.\n\nlabel : [None | string]\n    Label for legend\n\nmargins : float or 2-tuple, optional\n    Sets the padding for axis autoscaling. Increase margin to prevent\n    clipping for nodes that are near the edges of an image. Values should\n    be in the range ``[0, 1]``. See :meth:`matplotlib.axes.Axes.margins`\n    for details. The default is `None`, which uses the Matplotlib default.\n\nReturns\n-------\nmatplotlib.collections.PathCollection\n    `PathCollection` of the nodes.\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> nodes = nx.draw_networkx_nodes(G, pos=nx.spring_layout(G))\n\nAlso see the NetworkX drawing examples at\nhttps://networkx.org/documentation/latest/auto_examples/index.html\n\nSee Also\n--------\ndraw\ndraw_networkx\ndraw_networkx_edges\ndraw_networkx_labels\ndraw_networkx_edge_labels",
  "code": "def draw_networkx_nodes(G, pos, nodelist=None, node_size=300, node_color='#1f78b4', node_shape='o', alpha=None, cmap=None, vmin=None, vmax=None, ax=None, linewidths=None, edgecolors=None, label=None, margins=None):\n    from collections.abc import Iterable\n    import matplotlib as mpl\n    import matplotlib.collections\n    import matplotlib.pyplot as plt\n    import numpy as np\n    if ax is None:\n        ax = plt.gca()\n    if nodelist is None:\n        nodelist = list(G)\n    if len(nodelist) == 0:\n        return mpl.collections.PathCollection(None)\n    try:\n        xy = np.asarray([pos[v] for v in nodelist])\n    except KeyError as err:\n        raise nx.NetworkXError(f'Node {err} has no position.') from err\n    if isinstance(alpha, Iterable):\n        node_color = apply_alpha(node_color, alpha, nodelist, cmap, vmin, vmax)\n        alpha = None\n    node_collection = ax.scatter(xy[:, 0], xy[:, 1], s=node_size, c=node_color, marker=node_shape, cmap=cmap, vmin=vmin, vmax=vmax, alpha=alpha, linewidths=linewidths, edgecolors=edgecolors, label=label)\n    ax.tick_params(axis='both', which='both', bottom=False, left=False, labelbottom=False, labelleft=False)\n    if margins is not None:\n        if isinstance(margins, Iterable):\n            ax.margins(*margins)\n        else:\n            ax.margins(margins)\n    node_collection.set_zorder(2)\n    return node_collection"
 },
 {
  "docstring": "Draw the edges of the graph G.\n\nThis draws only the edges of the graph G.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary\n    A dictionary with nodes as keys and positions as values.\n    Positions should be sequences of length 2.\n\nedgelist : collection of edge tuples (default=G.edges())\n    Draw only specified edges\n\nwidth : float or array of floats (default=1.0)\n    Line width of edges\n\nedge_color : color or array of colors (default='k')\n    Edge color. Can be a single color or a sequence of colors with the same\n    length as edgelist. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1. If numeric values are specified they will be\n    mapped to colors using the edge_cmap and edge_vmin,edge_vmax parameters.\n\nstyle : string or array of strings (default='solid')\n    Edge line style e.g.: '-', '--', '-.', ':'\n    or words like 'solid' or 'dashed'.\n    Can be a single style or a sequence of styles with the same\n    length as the edge list.\n    If less styles than edges are given the styles will cycle.\n    If more styles than edges are given the styles will be used sequentially\n    and not be exhausted.\n    Also, `(offset, onoffseq)` tuples can be used as style instead of a strings.\n    (See `matplotlib.patches.FancyArrowPatch`: `linestyle`)\n\nalpha : float or array of floats (default=None)\n    The edge transparency.  This can be a single alpha value,\n    in which case it will be applied to all specified edges. Otherwise,\n    if it is an array, the elements of alpha will be applied to the colors\n    in order (cycling through alpha multiple times if necessary).\n\nedge_cmap : Matplotlib colormap, optional\n    Colormap for mapping intensities of edges\n\nedge_vmin,edge_vmax : floats, optional\n    Minimum and maximum for edge colormap scaling\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\narrows : bool or None, optional (default=None)\n    If `None`, directed graphs draw arrowheads with\n    `~matplotlib.patches.FancyArrowPatch`, while undirected graphs draw edges\n    via `~matplotlib.collections.LineCollection` for speed.\n    If `True`, draw arrowheads with FancyArrowPatches (bendable and stylish).\n    If `False`, draw edges using LineCollection (linear and fast).\n\n    Note: Arrowheads will be the same color as edges.\n\narrowstyle : str (default='-\\|>' for directed graphs)\n    For directed graphs and `arrows==True` defaults to '-\\|>',\n    For undirected graphs default to '-'.\n\n    See `matplotlib.patches.ArrowStyle` for more options.\n\narrowsize : int (default=10)\n    For directed graphs, choose the size of the arrow head's length and\n    width. See `matplotlib.patches.FancyArrowPatch` for attribute\n    `mutation_scale` for more info.\n\nconnectionstyle : string (default=\"arc3\")\n    Pass the connectionstyle parameter to create curved arc of rounding\n    radius rad. For example, connectionstyle='arc3,rad=0.2'.\n    See `matplotlib.patches.ConnectionStyle` and\n    `matplotlib.patches.FancyArrowPatch` for more info.\n\nnode_size : scalar or array (default=300)\n    Size of nodes. Though the nodes are not drawn with this function, the\n    node size is used in determining edge positioning.\n\nnodelist : list, optional (default=G.nodes())\n   This provides the node order for the `node_size` array (if it is an array).\n\nnode_shape :  string (default='o')\n    The marker used for nodes, used in determining edge positioning.\n    Specification is as a `matplotlib.markers` marker, e.g. one of 'so^>v<dph8'.\n\nlabel : None or string\n    Label for legend\n\nmin_source_margin : int (default=0)\n    The minimum margin (gap) at the beginning of the edge at the source.\n\nmin_target_margin : int (default=0)\n    The minimum margin (gap) at the end of the edge at the target.\n\nReturns\n-------\n matplotlib.collections.LineCollection or a list of matplotlib.patches.FancyArrowPatch\n    If ``arrows=True``, a list of FancyArrowPatches is returned.\n    If ``arrows=False``, a LineCollection is returned.\n    If ``arrows=None`` (the default), then a LineCollection is returned if\n    `G` is undirected, otherwise returns a list of FancyArrowPatches.\n\n",
  "code": "def draw_networkx_edges(G, pos, edgelist=None, width=1.0, edge_color='k', style='solid', alpha=None, arrowstyle=None, arrowsize=10, edge_cmap=None, edge_vmin=None, edge_vmax=None, ax=None, arrows=None, label=None, node_size=300, nodelist=None, node_shape='o', connectionstyle='arc3', min_source_margin=0, min_target_margin=0):\n    import matplotlib as mpl\n    import matplotlib.collections\n    import matplotlib.colors\n    import matplotlib.patches\n    import matplotlib.path\n    import matplotlib.pyplot as plt\n    import numpy as np\n    use_linecollection = not G.is_directed()\n    if arrows in (True, False):\n        use_linecollection = not arrows\n    if use_linecollection and any([arrowstyle is not None, arrowsize != 10, connectionstyle != 'arc3', min_source_margin != 0, min_target_margin != 0]):\n        import warnings\n        msg = '\\n\\nThe {0} keyword argument is not applicable when drawing edges\\nwith LineCollection.\\n\\nTo make this warning go away, either specify `arrows=True` to\\nforce FancyArrowPatches or use the default value for {0}.\\nNote that using FancyArrowPatches may be slow for large graphs.\\n'\n        if arrowstyle is not None:\n            msg = msg.format('arrowstyle')\n        if arrowsize != 10:\n            msg = msg.format('arrowsize')\n        if connectionstyle != 'arc3':\n            msg = msg.format('connectionstyle')\n        if min_source_margin != 0:\n            msg = msg.format('min_source_margin')\n        if min_target_margin != 0:\n            msg = msg.format('min_target_margin')\n        warnings.warn(msg, category=UserWarning, stacklevel=2)\n    if arrowstyle == None:\n        if G.is_directed():\n            arrowstyle = '-|>'\n        else:\n            arrowstyle = '-'\n    if ax is None:\n        ax = plt.gca()\n    if edgelist is None:\n        edgelist = list(G.edges())\n    if len(edgelist) == 0:\n        return []\n    if nodelist is None:\n        nodelist = list(G.nodes())\n    if edge_color is None:\n        edge_color = 'k'\n    edgelist_tuple = list(map(tuple, edgelist))\n    edge_pos = np.asarray([(pos[e[0]], pos[e[1]]) for e in edgelist])\n    if np.iterable(edge_color) and len(edge_color) == len(edge_pos) and np.all([isinstance(c, Number) for c in edge_color]):\n        if edge_cmap is not None:\n            assert isinstance(edge_cmap, mpl.colors.Colormap)\n        else:\n            edge_cmap = plt.get_cmap()\n        if edge_vmin is None:\n            edge_vmin = min(edge_color)\n        if edge_vmax is None:\n            edge_vmax = max(edge_color)\n        color_normal = mpl.colors.Normalize(vmin=edge_vmin, vmax=edge_vmax)\n        edge_color = [edge_cmap(color_normal(e)) for e in edge_color]\n\n    def _draw_networkx_edges_line_collection():\n        edge_collection = mpl.collections.LineCollection(edge_pos, colors=edge_color, linewidths=width, antialiaseds=(1,), linestyle=style, alpha=alpha)\n        edge_collection.set_cmap(edge_cmap)\n        edge_collection.set_clim(edge_vmin, edge_vmax)\n        edge_collection.set_zorder(1)\n        edge_collection.set_label(label)\n        ax.add_collection(edge_collection)\n        return edge_collection\n\n    def _draw_networkx_edges_fancy_arrow_patch():\n\n        def to_marker_edge(marker_size, marker):\n            if marker in 's^>v<d':\n                return np.sqrt(2 * marker_size) / 2\n            else:\n                return np.sqrt(marker_size) / 2\n        arrow_collection = []\n        if isinstance(arrowsize, list):\n            if len(arrowsize) != len(edge_pos):\n                raise ValueError('arrowsize should have the same length as edgelist')\n        else:\n            mutation_scale = arrowsize\n        base_connection_style = mpl.patches.ConnectionStyle(connectionstyle)\n        max_nodesize = np.array(node_size).max()\n\n        def _connectionstyle(posA, posB, *args, **kwargs):\n            if np.all(posA == posB):\n                selfloop_ht = 0.005 * max_nodesize if h == 0 else h\n                data_loc = ax.transData.inverted().transform(posA)\n                v_shift = 0.1 * selfloop_ht\n                h_shift = v_shift * 0.5\n                path = [data_loc + np.asarray([0, v_shift]), data_loc + np.asarray([h_shift, v_shift]), data_loc + np.asarray([h_shift, 0]), data_loc, data_loc + np.asarray([-h_shift, 0]), data_loc + np.asarray([-h_shift, v_shift]), data_loc + np.asarray([0, v_shift])]\n                ret = mpl.path.Path(ax.transData.transform(path), [1, 4, 4, 4, 4, 4, 4])\n            else:\n                ret = base_connection_style(posA, posB, *args, **kwargs)\n            return ret\n        arrow_colors = mpl.colors.colorConverter.to_rgba_array(edge_color, alpha)\n        for i, (src, dst) in zip(fancy_edges_indices, edge_pos):\n            x1, y1 = src\n            x2, y2 = dst\n            shrink_source = 0\n            shrink_target = 0\n            if isinstance(arrowsize, list):\n                mutation_scale = arrowsize[i]\n            if np.iterable(node_size):\n                source, target = edgelist[i][:2]\n                source_node_size = node_size[nodelist.index(source)]\n                target_node_size = node_size[nodelist.index(target)]\n                shrink_source = to_marker_edge(source_node_size, node_shape)\n                shrink_target = to_marker_edge(target_node_size, node_shape)\n            else:\n                shrink_source = shrink_target = to_marker_edge(node_size, node_shape)\n            if shrink_source < min_source_margin:\n                shrink_source = min_source_margin\n            if shrink_target < min_target_margin:\n                shrink_target = min_target_margin\n            if len(arrow_colors) > i:\n                arrow_color = arrow_colors[i]\n            elif len(arrow_colors) == 1:\n                arrow_color = arrow_colors[0]\n            else:\n                arrow_color = arrow_colors[i % len(arrow_colors)]\n            if np.iterable(width):\n                if len(width) > i:\n                    line_width = width[i]\n                else:\n                    line_width = width[i % len(width)]\n            else:\n                line_width = width\n            if np.iterable(style) and (not isinstance(style, str)) and (not isinstance(style, tuple)):\n                if len(style) > i:\n                    linestyle = style[i]\n                else:\n                    linestyle = style[i % len(style)]\n            else:\n                linestyle = style\n            arrow = mpl.patches.FancyArrowPatch((x1, y1), (x2, y2), arrowstyle=arrowstyle, shrinkA=shrink_source, shrinkB=shrink_target, mutation_scale=mutation_scale, color=arrow_color, linewidth=line_width, connectionstyle=_connectionstyle, linestyle=linestyle, zorder=1)\n            arrow_collection.append(arrow)\n            ax.add_patch(arrow)\n        return arrow_collection\n    minx = np.amin(np.ravel(edge_pos[:, :, 0]))\n    maxx = np.amax(np.ravel(edge_pos[:, :, 0]))\n    miny = np.amin(np.ravel(edge_pos[:, :, 1]))\n    maxy = np.amax(np.ravel(edge_pos[:, :, 1]))\n    w = maxx - minx\n    h = maxy - miny\n    if use_linecollection:\n        edge_viz_obj = _draw_networkx_edges_line_collection()\n        selfloops_to_draw = [loop for loop in nx.selfloop_edges(G) if loop in edgelist]\n        if selfloops_to_draw:\n            fancy_edges_indices = [edgelist_tuple.index(loop) for loop in selfloops_to_draw]\n            edge_pos = np.asarray([(pos[e[0]], pos[e[1]]) for e in selfloops_to_draw])\n            arrowstyle = '-'\n            _draw_networkx_edges_fancy_arrow_patch()\n    else:\n        fancy_edges_indices = range(len(edgelist))\n        edge_viz_obj = _draw_networkx_edges_fancy_arrow_patch()\n    padx, pady = (0.05 * w, 0.05 * h)\n    corners = ((minx - padx, miny - pady), (maxx + padx, maxy + pady))\n    ax.update_datalim(corners)\n    ax.autoscale_view()\n    ax.tick_params(axis='both', which='both', bottom=False, left=False, labelbottom=False, labelleft=False)\n    return edge_viz_obj"
 },
 {
  "docstring": "Draw node labels on the graph G.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary\n    A dictionary with nodes as keys and positions as values.\n    Positions should be sequences of length 2.\n\nlabels : dictionary (default={n: n for n in G})\n    Node labels in a dictionary of text labels keyed by node.\n    Node-keys in labels should appear as keys in `pos`.\n    If needed use: `{n:lab for n,lab in labels.items() if n in pos}`\n\nfont_size : int (default=12)\n    Font size for text labels\n\nfont_color : color (default='k' black)\n    Font color string. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1.\n\nfont_weight : string (default='normal')\n    Font weight\n\nfont_family : string (default='sans-serif')\n    Font family\n\nalpha : float or None (default=None)\n    The text transparency\n\nbbox : Matplotlib bbox, (default is Matplotlib's ax.text default)\n    Specify text box properties (e.g. shape, color etc.) for node labels.\n\nhorizontalalignment : string (default='center')\n    Horizontal alignment {'center', 'right', 'left'}\n\nverticalalignment : string (default='center')\n    Vertical alignment {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\nclip_on : bool (default=True)\n    Turn on clipping of node labels at axis boundaries\n\nReturns\n-------\ndict\n    `dict` of labels keyed on the nodes\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> labels = nx.draw_networkx_labels(G, pos=nx.spring_layout(G))\n\nAlso see the NetworkX drawing examples at\nhttps://networkx.org/documentation/latest/auto_examples/index.html\n\nSee Also\n--------\ndraw\ndraw_networkx\ndraw_networkx_nodes\ndraw_networkx_edges\ndraw_networkx_edge_labels",
  "code": "def draw_networkx_labels(G, pos, labels=None, font_size=12, font_color='k', font_family='sans-serif', font_weight='normal', alpha=None, bbox=None, horizontalalignment='center', verticalalignment='center', ax=None, clip_on=True):\n    import matplotlib.pyplot as plt\n    if ax is None:\n        ax = plt.gca()\n    if labels is None:\n        labels = {n: n for n in G.nodes()}\n    text_items = {}\n    for n, label in labels.items():\n        x, y = pos[n]\n        if not isinstance(label, str):\n            label = str(label)\n        t = ax.text(x, y, label, size=font_size, color=font_color, family=font_family, weight=font_weight, alpha=alpha, horizontalalignment=horizontalalignment, verticalalignment=verticalalignment, transform=ax.transData, bbox=bbox, clip_on=clip_on)\n        text_items[n] = t\n    ax.tick_params(axis='both', which='both', bottom=False, left=False, labelbottom=False, labelleft=False)\n    return text_items"
 },
 {
  "docstring": "Draw edge labels.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\npos : dictionary\n    A dictionary with nodes as keys and positions as values.\n    Positions should be sequences of length 2.\n\nedge_labels : dictionary (default=None)\n    Edge labels in a dictionary of labels keyed by edge two-tuple.\n    Only labels for the keys in the dictionary are drawn.\n\nlabel_pos : float (default=0.5)\n    Position of edge label along edge (0=head, 0.5=center, 1=tail)\n\nfont_size : int (default=10)\n    Font size for text labels\n\nfont_color : color (default='k' black)\n    Font color string. Color can be string or rgb (or rgba) tuple of\n    floats from 0-1.\n\nfont_weight : string (default='normal')\n    Font weight\n\nfont_family : string (default='sans-serif')\n    Font family\n\nalpha : float or None (default=None)\n    The text transparency\n\nbbox : Matplotlib bbox, optional\n    Specify text box properties (e.g. shape, color etc.) for edge labels.\n    Default is {boxstyle='round', ec=(1.0, 1.0, 1.0), fc=(1.0, 1.0, 1.0)}.\n\nhorizontalalignment : string (default='center')\n    Horizontal alignment {'center', 'right', 'left'}\n\nverticalalignment : string (default='center')\n    Vertical alignment {'center', 'top', 'bottom', 'baseline', 'center_baseline'}\n\nax : Matplotlib Axes object, optional\n    Draw the graph in the specified Matplotlib axes.\n\nrotate : bool (default=True)\n    Rotate edge labels to lie parallel to edges\n\nclip_on : bool (default=True)\n    Turn on clipping of edge labels at axis boundaries\n\nReturns\n-------\ndict\n    `dict` of labels keyed by edge\n\nExamples\n--------\n>>> G = nx.dodecahedral_graph()\n>>> edge_labels = nx.draw_networkx_edge_labels(G, pos=nx.spring_layout(G))\n\nAlso see the NetworkX drawing examples at\nhttps://networkx.org/documentation/latest/auto_examples/index.html\n\nSee Also\n--------\ndraw\ndraw_networkx\ndraw_networkx_nodes\ndraw_networkx_edges\ndraw_networkx_labels",
  "code": "def draw_networkx_edge_labels(G, pos, edge_labels=None, label_pos=0.5, font_size=10, font_color='k', font_family='sans-serif', font_weight='normal', alpha=None, bbox=None, horizontalalignment='center', verticalalignment='center', ax=None, rotate=True, clip_on=True):\n    import matplotlib.pyplot as plt\n    import numpy as np\n    if ax is None:\n        ax = plt.gca()\n    if edge_labels is None:\n        labels = {(u, v): d for u, v, d in G.edges(data=True)}\n    else:\n        labels = edge_labels\n        try:\n            u, v = next(iter(labels))\n        except ValueError as err:\n            raise nx.NetworkXError('draw_networkx_edge_labels does not support multiedges.') from err\n        except StopIteration:\n            pass\n    text_items = {}\n    for (n1, n2), label in labels.items():\n        x1, y1 = pos[n1]\n        x2, y2 = pos[n2]\n        x, y = (x1 * label_pos + x2 * (1.0 - label_pos), y1 * label_pos + y2 * (1.0 - label_pos))\n        if rotate:\n            angle = np.arctan2(y2 - y1, x2 - x1) / (2.0 * np.pi) * 360\n            if angle > 90:\n                angle -= 180\n            if angle < -90:\n                angle += 180\n            xy = np.array((x, y))\n            trans_angle = ax.transData.transform_angles(np.array((angle,)), xy.reshape((1, 2)))[0]\n        else:\n            trans_angle = 0.0\n        if bbox is None:\n            bbox = {'boxstyle': 'round', 'ec': (1.0, 1.0, 1.0), 'fc': (1.0, 1.0, 1.0)}\n        if not isinstance(label, str):\n            label = str(label)\n        t = ax.text(x, y, label, size=font_size, color=font_color, family=font_family, weight=font_weight, alpha=alpha, horizontalalignment=horizontalalignment, verticalalignment=verticalalignment, rotation=trans_angle, transform=ax.transData, bbox=bbox, zorder=1, clip_on=clip_on)\n        text_items[n1, n2] = t\n    ax.tick_params(axis='both', which='both', bottom=False, left=False, labelbottom=False, labelleft=False)\n    return text_items"
 },
 {
  "docstring": "Draw the graph `G` with a circular layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.circular_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\n",
  "code": "def draw_circular(G, **kwargs):\n    draw(G, circular_layout(G), **kwargs)"
 },
 {
  "docstring": "Draw the graph `G` with a Kamada-Kawai force-directed layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.kamada_kawai_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\n",
  "code": "def draw_kamada_kawai(G, **kwargs):\n    draw(G, kamada_kawai_layout(G), **kwargs)"
 },
 {
  "docstring": "Draw the graph `G` with a random layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.random_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\n",
  "code": "def draw_random(G, **kwargs):\n    draw(G, random_layout(G), **kwargs)"
 },
 {
  "docstring": "Draw the graph `G` with a spectral 2D layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.spectral_layout(G), **kwargs)\n\nFor more information about how node positions are determined, see\n`~networkx.drawing.layout.spectral_layout`.\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\n",
  "code": "def draw_spectral(G, **kwargs):\n    draw(G, spectral_layout(G), **kwargs)"
 },
 {
  "docstring": "Draw the graph `G` with a spring layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.spring_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\n",
  "code": "def draw_spring(G, **kwargs):\n    draw(G, spring_layout(G), **kwargs)"
 },
 {
  "docstring": "Draw networkx graph `G` with shell layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.shell_layout(G, nlist=nlist), **kwargs)\n\nParameters\n----------\nG : graph\n    A networkx graph\n\nnlist : list of list of nodes, optional\n    A list containing lists of nodes representing the shells.\n    Default is `None`, meaning all nodes are in a single shell.\n    See `~networkx.drawing.layout.shell_layout` for details.\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\n",
  "code": "def draw_shell(G, nlist=None, **kwargs):\n    draw(G, shell_layout(G, nlist=nlist), **kwargs)"
 },
 {
  "docstring": "Draw a planar networkx graph `G` with planar layout.\n\nThis is a convenience function equivalent to::\n\n    nx.draw(G, pos=nx.planar_layout(G), **kwargs)\n\nParameters\n----------\nG : graph\n    A planar networkx graph\n\nkwargs : optional keywords\n    See `draw_networkx` for a description of optional keywords.\n\nRaises\n------\nNetworkXException\n    When `G` is not planar\n\n",
  "code": "def draw_planar(G, **kwargs):\n    draw(G, planar_layout(G), **kwargs)"
 },
 {
  "docstring": "Apply an alpha (or list of alphas) to the colors provided.\n\nParameters\n----------\n\ncolors : color string or array of floats (default='r')\n    Color of element. Can be a single color format string,\n    or a sequence of colors with the same length as nodelist.\n    If numeric values are specified they will be mapped to\n    colors using the cmap and vmin,vmax parameters.  See\n    matplotlib.scatter for more details.\n\nalpha : float or array of floats\n    Alpha values for elements. This can be a single alpha value, in\n    which case it will be applied to all the elements of color. Otherwise,\n    if it is an array, the elements of alpha will be applied to the colors\n    in order (cycling through alpha multiple times if necessary).\n\nelem_list : array of networkx objects\n    The list of elements which are being colored. These could be nodes,\n    edges or labels.\n\ncmap : matplotlib colormap\n    Color map for use if colors is a list of floats corresponding to points\n    on a color mapping.\n\nvmin, vmax : float\n    Minimum and maximum values for normalizing colors if a colormap is used\n\nReturns\n-------\n\nrgba_colors : numpy ndarray\n    Array containing RGBA format values for each of the node colours.",
  "code": "def apply_alpha(colors, alpha, elem_list, cmap=None, vmin=None, vmax=None):\n    from itertools import cycle, islice\n    import matplotlib as mpl\n    import matplotlib.cm\n    import matplotlib.colors\n    import numpy as np\n    if len(colors) == len(elem_list) and isinstance(colors[0], Number):\n        mapper = mpl.cm.ScalarMappable(cmap=cmap)\n        mapper.set_clim(vmin, vmax)\n        rgba_colors = mapper.to_rgba(colors)\n    else:\n        try:\n            rgba_colors = np.array([mpl.colors.colorConverter.to_rgba(colors)])\n        except ValueError:\n            rgba_colors = np.array([mpl.colors.colorConverter.to_rgba(color) for color in colors])\n    try:\n        if len(alpha) > len(rgba_colors) or rgba_colors.size == len(elem_list):\n            rgba_colors = np.resize(rgba_colors, (len(elem_list), 4))\n            rgba_colors[1:, 0] = rgba_colors[0, 0]\n            rgba_colors[1:, 1] = rgba_colors[0, 1]\n            rgba_colors[1:, 2] = rgba_colors[0, 2]\n        rgba_colors[:, 3] = list(islice(cycle(alpha), len(rgba_colors)))\n    except TypeError:\n        rgba_colors[:, -1] = alpha\n    return rgba_colors"
 },
 {
  "docstring": "See gh-5123.",
  "code": "def test_multipartite_layout_nonnumeric_partition_labels():\n    G = nx.Graph()\n    G.add_node(0, subset='s0')\n    G.add_node(1, subset='s0')\n    G.add_node(2, subset='s1')\n    G.add_node(3, subset='s1')\n    G.add_edges_from([(0, 2), (0, 3), (1, 2)])\n    pos = nx.multipartite_layout(G)\n    assert len(pos) == len(G)"
 },
 {
  "docstring": "Return the layers in sorted order if the layers of the multipartite\ngraph are sortable. See gh-5691",
  "code": "def test_multipartite_layout_layer_order():\n    G = nx.Graph()\n    for node, layer in zip(('a', 'b', 'c', 'd', 'e'), (2, 3, 1, 2, 4)):\n        G.add_node(node, subset=layer)\n    pos = nx.multipartite_layout(G, align='horizontal')\n    assert pos['a'][-1] == pos['d'][-1]\n    assert pos['c'][-1] < pos['a'][-1] < pos['b'][-1] < pos['e'][-1]\n    G.nodes['a']['subset'] = 'layer_0'\n    pos_nosort = nx.multipartite_layout(G)\n    assert pos_nosort.keys() == pos.keys()"
 },
 {
  "docstring": "Checks whether partial pos input still returns a proper position.",
  "code": "def test_arf_layout_partial_input_test(self):\n    G = self.Gs\n    node = nx.utils.arbitrary_element(G)\n    pos = nx.circular_layout(G)\n    del pos[node]\n    pos = nx.arf_layout(G, pos=pos)\n    assert len(pos) == len(G)"
 },
 {
  "docstring": "Checks input parameters correctly raises errors. For example,  `a` should be larger than 1",
  "code": "def test_arf_layout_negative_a_check(self):\n    G = self.Gs\n    pytest.raises(ValueError, nx.arf_layout, G=G, a=-1)"
 },
 {
  "docstring": "Validate :mod:`pydot`-based usage of the passed NetworkX graph with the\npassed basename of an external GraphViz command (e.g., `dot`, `neato`).",
  "code": "def pydot_checks(self, G, prog):\n    G.graph['name'] = 'G'\n    G.add_edges_from([('A', 'B'), ('A', 'C'), ('B', 'C'), ('A', 'D')])\n    G.add_node('E')\n    graph_layout = nx.nx_pydot.pydot_layout(G, prog=prog)\n    assert isinstance(graph_layout, dict)\n    P = nx.nx_pydot.to_pydot(G)\n    G2 = G.__class__(nx.nx_pydot.from_pydot(P))\n    assert graphs_equal(G, G2)\n    fd, fname = tempfile.mkstemp()\n    P.write_raw(fname)\n    Pin_list = pydot.graph_from_dot_file(path=fname, encoding='utf-8')\n    assert len(Pin_list) == 1\n    Pin = Pin_list[0]\n    n1 = sorted((p.get_name() for p in P.get_node_list()))\n    n2 = sorted((p.get_name() for p in Pin.get_node_list()))\n    assert n1 == n2\n    e1 = sorted(((e.get_source(), e.get_destination()) for e in P.get_edge_list()))\n    e2 = sorted(((e.get_source(), e.get_destination()) for e in Pin.get_edge_list()))\n    assert e1 == e2\n    Hin = nx.nx_pydot.read_dot(fname)\n    Hin = G.__class__(Hin)\n    assert graphs_equal(G, Hin)\n    os.close(fd)\n    os.unlink(fname)"
 },
 {
  "docstring": "Tests ways of specifying all edges have a single color for edges\ndrawn with a LineCollection",
  "code": "@pytest.mark.parametrize(('edge_color', 'expected'), ((None, 'black'), ('r', 'red'), (['r'], 'red'), ((1.0, 1.0, 0.0), 'yellow'), ([(1.0, 1.0, 0.0)], 'yellow'), ((0, 1, 0, 1), 'lime'), ([(0, 1, 0, 1)], 'lime'), ('#0000ff', 'blue'), (['#0000ff'], 'blue')))\n@pytest.mark.parametrize('edgelist', (None, [(0, 1)]))\ndef test_single_edge_color_undirected(edge_color, expected, edgelist):\n    G = nx.path_graph(3)\n    drawn_edges = nx.draw_networkx_edges(G, pos=nx.random_layout(G), edgelist=edgelist, edge_color=edge_color)\n    assert mpl.colors.same_color(drawn_edges.get_color(), expected)"
 },
 {
  "docstring": "Tests ways of specifying all edges have a single color for edges drawn\nwith FancyArrowPatches",
  "code": "@pytest.mark.parametrize(('edge_color', 'expected'), ((None, 'black'), ('r', 'red'), (['r'], 'red'), ((1.0, 1.0, 0.0), 'yellow'), ([(1.0, 1.0, 0.0)], 'yellow'), ((0, 1, 0, 1), 'lime'), ([(0, 1, 0, 1)], 'lime'), ('#0000ff', 'blue'), (['#0000ff'], 'blue')))\n@pytest.mark.parametrize('edgelist', (None, [(0, 1)]))\ndef test_single_edge_color_directed(edge_color, expected, edgelist):\n    G = nx.path_graph(3, create_using=nx.DiGraph)\n    drawn_edges = nx.draw_networkx_edges(G, pos=nx.random_layout(G), edgelist=edgelist, edge_color=edge_color)\n    for fap in drawn_edges:\n        assert mpl.colors.same_color(fap.get_edgecolor(), expected)"
 },
 {
  "docstring": "If edge_color is a sequence with the same length as edgelist, then each\nvalue in edge_color is mapped onto each edge via colormap.",
  "code": "def test_edge_color_tuple_interpretation():\n    G = nx.path_graph(6, create_using=nx.DiGraph)\n    pos = {n: (n, n) for n in range(len(G))}\n    for ec in ((0, 0, 1), (0, 0, 1, 1)):\n        drawn_edges = nx.draw_networkx_edges(G, pos, edge_color=ec)\n        for fap in drawn_edges:\n            assert mpl.colors.same_color(fap.get_edgecolor(), ec)\n        drawn_edges = nx.draw_networkx_edges(G, pos, edgelist=[(0, 1), (1, 2)], edge_color=ec)\n        for fap in drawn_edges:\n            assert mpl.colors.same_color(fap.get_edgecolor(), ec)\n    drawn_edges = nx.draw_networkx_edges(G, pos, edgelist=[(0, 1), (1, 2), (2, 3)], edge_color=(0, 0, 1, 1))\n    for fap in drawn_edges:\n        assert mpl.colors.same_color(fap.get_edgecolor(), 'blue')\n    drawn_edges = nx.draw_networkx_edges(G, pos, edgelist=[(0, 1), (1, 2), (2, 3), (3, 4)], edge_color=(0, 0, 1))\n    for fap in drawn_edges:\n        assert mpl.colors.same_color(fap.get_edgecolor(), 'blue')\n    drawn_edges = nx.draw_networkx_edges(G, pos, edgelist=[(0, 1), (1, 2), (2, 3)], edge_color=(0, 0, 1))\n    assert mpl.colors.same_color(drawn_edges[0].get_edgecolor(), drawn_edges[1].get_edgecolor())\n    for fap in drawn_edges:\n        assert not mpl.colors.same_color(fap.get_edgecolor(), 'blue')\n    drawn_edges = nx.draw_networkx_edges(G, pos, edgelist=[(0, 1), (1, 2), (2, 3), (3, 4)], edge_color=(0, 0, 1, 1))\n    assert mpl.colors.same_color(drawn_edges[0].get_edgecolor(), drawn_edges[1].get_edgecolor())\n    assert mpl.colors.same_color(drawn_edges[2].get_edgecolor(), drawn_edges[3].get_edgecolor())\n    for fap in drawn_edges:\n        assert not mpl.colors.same_color(fap.get_edgecolor(), 'blue')"
 },
 {
  "docstring": "Test that the edge colors are cycled when there are fewer specified\ncolors than edges.",
  "code": "def test_fewer_edge_colors_than_num_edges_directed():\n    G = barbell.to_directed()\n    pos = nx.random_layout(barbell)\n    edgecolors = ('r', 'g', 'b')\n    drawn_edges = nx.draw_networkx_edges(G, pos, edge_color=edgecolors)\n    for fap, expected in zip(drawn_edges, itertools.cycle(edgecolors)):\n        assert mpl.colors.same_color(fap.get_edgecolor(), expected)"
 },
 {
  "docstring": "Test that extra edge colors are ignored when there are more specified\ncolors than edges.",
  "code": "def test_more_edge_colors_than_num_edges_directed():\n    G = nx.path_graph(4, create_using=nx.DiGraph)\n    pos = nx.random_layout(barbell)\n    edgecolors = ('r', 'g', 'b', 'c')\n    drawn_edges = nx.draw_networkx_edges(G, pos, edge_color=edgecolors)\n    for fap, expected in zip(drawn_edges, edgecolors[:-1]):\n        assert mpl.colors.same_color(fap.get_edgecolor(), expected)"
 },
 {
  "docstring": "Test the default linewidth for edges drawn either via LineCollection or\nFancyArrowPatches.",
  "code": "@pytest.mark.parametrize('graph_type', (nx.Graph, nx.DiGraph))\ndef test_edge_width_default_value(graph_type):\n    G = nx.path_graph(2, create_using=graph_type)\n    pos = {n: (n, n) for n in range(len(G))}\n    drawn_edges = nx.draw_networkx_edges(G, pos)\n    if isinstance(drawn_edges, list):\n        drawn_edges = drawn_edges[0]\n    assert drawn_edges.get_linewidth() == 1"
 },
 {
  "docstring": "Test that edge_vmin and edge_vmax properly set the dynamic range of the\ncolor map when num edges == len(edge_colors).",
  "code": "def test_edge_color_with_edge_vmin_vmax():\n    G = nx.path_graph(3, create_using=nx.DiGraph)\n    pos = nx.random_layout(G)\n    drawn_edges = nx.draw_networkx_edges(G, pos, edge_color=[0, 1.0])\n    orig_colors = [e.get_edgecolor() for e in drawn_edges]\n    drawn_edges = nx.draw_networkx_edges(G, pos, edge_color=[0.2, 0.8], edge_vmin=0.2, edge_vmax=0.8)\n    scaled_colors = [e.get_edgecolor() for e in drawn_edges]\n    assert mpl.colors.same_color(orig_colors, scaled_colors)"
 },
 {
  "docstring": "Test default linestyle for edges drawn with FancyArrowPatches.",
  "code": "def test_directed_edges_linestyle_default():\n    G = nx.path_graph(4, create_using=nx.DiGraph)\n    pos = {n: (n, n) for n in range(len(G))}\n    drawn_edges = nx.draw_networkx_edges(G, pos)\n    assert len(drawn_edges) == 3\n    for fap in drawn_edges:\n        assert fap.get_linestyle() == 'solid'"
 },
 {
  "docstring": "Tests support for specifying linestyles with a single value to be applied to\nall edges in ``draw_networkx_edges`` for FancyArrowPatch outputs\n(e.g. directed edges).",
  "code": "@pytest.mark.parametrize('style', ('dashed', '--', (1, (1, 1))))\ndef test_directed_edges_linestyle_single_value(style):\n    G = nx.path_graph(4, create_using=nx.DiGraph)\n    pos = {n: (n, n) for n in range(len(G))}\n    drawn_edges = nx.draw_networkx_edges(G, pos, style=style)\n    assert len(drawn_edges) == 3\n    for fap in drawn_edges:\n        assert fap.get_linestyle() == style"
 },
 {
  "docstring": "Tests support for specifying linestyles with sequences in\n``draw_networkx_edges`` for FancyArrowPatch outputs (e.g. directed edges).",
  "code": "@pytest.mark.parametrize('style_seq', (['dashed'], ['--'], [(1, (1, 1))], ['--', '-', ':'], ['--', '-'], ['--', '-', ':', '-.']))\ndef test_directed_edges_linestyle_sequence(style_seq):\n    G = nx.path_graph(4, create_using=nx.DiGraph)\n    pos = {n: (n, n) for n in range(len(G))}\n    drawn_edges = nx.draw_networkx_edges(G, pos, style=style_seq)\n    assert len(drawn_edges) == 3\n    for fap, style in zip(drawn_edges, itertools.cycle(style_seq)):\n        assert fap.get_linestyle() == style"
 },
 {
  "docstring": "Test that there is a wider gap between the node and the start of an\nincident edge when min_source_margin is specified.\n\nThis test checks that the use of min_{source/target}_margin kwargs result\nin shorter (more padding) between the edges and source and target nodes.\nAs a crude visual example, let 's' and 't' represent source and target\nnodes, respectively:\n\n   Default:\n   s-----------------------------t\n\n   With margins:\n   s   -----------------------   t",
  "code": "@pytest.mark.parametrize('node_shape', ('o', 's'))\ndef test_draw_edges_min_source_target_margins(node_shape):\n    fig, ax = plt.subplots()\n    G = nx.DiGraph([(0, 1)])\n    pos = {0: (0, 0), 1: (1, 0)}\n    default_patch = nx.draw_networkx_edges(G, pos, ax=ax, node_shape=node_shape)[0]\n    default_extent = default_patch.get_extents().corners()[::2, 0]\n    padded_patch = nx.draw_networkx_edges(G, pos, ax=ax, node_shape=node_shape, min_source_margin=100, min_target_margin=100)[0]\n    padded_extent = padded_patch.get_extents().corners()[::2, 0]\n    assert padded_extent[0] > default_extent[0]\n    assert padded_extent[1] < default_extent[1]"
 },
 {
  "docstring": "Ensure that selfloop extent is non-zero when there is only one node.",
  "code": "def test_nonzero_selfloop_with_single_node():\n    fig, ax = plt.subplots()\n    G = nx.DiGraph()\n    G.add_node(0)\n    G.add_edge(0, 0)\n    patch = nx.draw_networkx_edges(G, {0: (0, 0)})[0]\n    bbox = patch.get_extents()\n    assert bbox.width > 0 and bbox.height > 0\n    plt.delaxes(ax)"
 },
 {
  "docstring": "Ensure that selfloop extent is non-zero when only a single edge is\nspecified in the edgelist.",
  "code": "def test_nonzero_selfloop_with_single_edge_in_edgelist():\n    fig, ax = plt.subplots()\n    G = nx.path_graph(2, create_using=nx.DiGraph)\n    G.add_edge(1, 1)\n    pos = {n: (n, n) for n in G.nodes}\n    patch = nx.draw_networkx_edges(G, pos, edgelist=[(1, 1)])[0]\n    bbox = patch.get_extents()\n    assert bbox.width > 0 and bbox.height > 0\n    plt.delaxes(ax)"
 },
 {
  "docstring": "Test apply_alpha when there is a mismatch between the number of\nsupplied colors and elements.",
  "code": "def test_apply_alpha():\n    nodelist = [0, 1, 2]\n    colorlist = ['r', 'g', 'b']\n    alpha = 0.5\n    rgba_colors = nx.drawing.nx_pylab.apply_alpha(colorlist, alpha, nodelist)\n    assert all(rgba_colors[:, -1] == alpha)"
 },
 {
  "docstring": "The `arrows` keyword argument is used as a 3-way switch to select which\ntype of object to use for drawing edges:\n  - ``arrows=None`` -> default (FancyArrowPatches for directed, else LineCollection)\n  - ``arrows=True`` -> FancyArrowPatches\n  - ``arrows=False`` -> LineCollection",
  "code": "def test_draw_edges_toggling_with_arrows_kwarg():\n    import matplotlib.collections\n    import matplotlib.patches\n    UG = nx.path_graph(3)\n    DG = nx.path_graph(3, create_using=nx.DiGraph)\n    pos = {n: (n, n) for n in UG}\n    for G in (UG, DG):\n        edges = nx.draw_networkx_edges(G, pos, arrows=True)\n        assert len(edges) == len(G.edges)\n        assert isinstance(edges[0], mpl.patches.FancyArrowPatch)\n    for G in (UG, DG):\n        edges = nx.draw_networkx_edges(G, pos, arrows=False)\n        assert isinstance(edges, mpl.collections.LineCollection)\n    edges = nx.draw_networkx_edges(UG, pos)\n    assert isinstance(edges, mpl.collections.LineCollection)\n    edges = nx.draw_networkx_edges(DG, pos)\n    assert len(edges) == len(G.edges)\n    assert isinstance(edges[0], mpl.patches.FancyArrowPatch)"
 },
 {
  "docstring": "draw_networkx_edge_labels should raise an informative error message when\nthe edge label includes keys",
  "code": "def test_draw_networkx_edge_label_multiedge_exception():\n    exception_msg = 'draw_networkx_edge_labels does not support multiedges'\n    G = nx.MultiGraph()\n    G.add_edge(0, 1, weight=10)\n    G.add_edge(0, 1, weight=20)\n    edge_labels = nx.get_edge_attributes(G, 'weight')\n    pos = {n: (n, n) for n in G}\n    with pytest.raises(nx.NetworkXError, match=exception_msg):\n        nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)"
 },
 {
  "docstring": "Regression test for draw_networkx_edge_labels with empty dict. See\ngh-5372.",
  "code": "def test_draw_networkx_edge_label_empty_dict():\n    G = nx.path_graph(3)\n    pos = {n: (n, n) for n in G.nodes}\n    assert nx.draw_networkx_edge_labels(G, pos, edge_labels={}) == {}"
 },
 {
  "docstring": "When an edgelist is supplied along with a sequence of colors, check that\nthe self-loops have the correct colors.",
  "code": "def test_draw_networkx_edges_undirected_selfloop_colors():\n    fig, ax = plt.subplots()\n    edgelist = [(1, 3), (1, 2), (2, 3), (1, 1), (3, 3), (2, 2)]\n    edge_colors = ['pink', 'cyan', 'black', 'red', 'blue', 'green']\n    G = nx.Graph(edgelist)\n    pos = {n: (n, n) for n in G.nodes}\n    nx.draw_networkx_edges(G, pos, ax=ax, edgelist=edgelist, edge_color=edge_colors)\n    assert len(ax.patches) == 3\n    sl_points = np.array(edgelist[-3:]) + np.array([0, 0.1])\n    for fap, clr, slp in zip(ax.patches, edge_colors[-3:], sl_points):\n        assert fap.get_path().contains_point(slp)\n        assert mpl.colors.same_color(fap.get_edgecolor(), clr)\n    plt.delaxes(ax)"
 },
 {
  "docstring": "Users should get a warning when they specify a non-default value for\none of the kwargs that applies only to edges drawn with FancyArrowPatches,\nbut FancyArrowPatches aren't being used under the hood.",
  "code": "@pytest.mark.parametrize('fap_only_kwarg', ({'arrowstyle': '-'}, {'arrowsize': 20}, {'connectionstyle': 'arc3,rad=0.2'}, {'min_source_margin': 10}, {'min_target_margin': 10}))\ndef test_user_warnings_for_unused_edge_drawing_kwargs(fap_only_kwarg):\n    G = nx.path_graph(3)\n    pos = {n: (n, n) for n in G}\n    fig, ax = plt.subplots()\n    kwarg_name = list(fap_only_kwarg.keys())[0]\n    with pytest.warns(UserWarning, match=f'\\n\\nThe {kwarg_name} keyword argument is not applicable'):\n        nx.draw_networkx_edges(G, pos, ax=ax, **fap_only_kwarg)\n    with warnings.catch_warnings():\n        warnings.simplefilter('error')\n        nx.draw_networkx_edges(G, pos, ax=ax, arrows=True, **fap_only_kwarg)\n    plt.delaxes(ax)"
 }
]