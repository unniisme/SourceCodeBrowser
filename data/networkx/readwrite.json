[
 {
  "docstring": "Generate a single line of the graph G in adjacency list format.\n\nParameters\n----------\nG : NetworkX graph\n\ndelimiter : string, optional\n   Separator for node labels\n\nReturns\n-------\nlines : string\n    Lines of data in adjlist format.\n\nExamples\n--------\n>>> G = nx.lollipop_graph(4, 3)\n>>> for line in nx.generate_adjlist(G):\n...     print(line)\n0 1 2 3\n1 2 3\n2 3\n3 4\n4 5\n5 6\n6\n\nSee Also\n--------\nwrite_adjlist, read_adjlist\n\n",
  "code": "def generate_adjlist(G, delimiter=' '):\n    directed = G.is_directed()\n    seen = set()\n    for s, nbrs in G.adjacency():\n        line = str(s) + delimiter\n        for t, data in nbrs.items():\n            if not directed and t in seen:\n                continue\n            if G.is_multigraph():\n                for d in data.values():\n                    line += str(t) + delimiter\n            else:\n                line += str(t) + delimiter\n        if not directed:\n            seen.add(s)\n        yield line[:-len(delimiter)]"
 },
 {
  "docstring": "Write graph G in single-line adjacency-list format to path.\n\n\nParameters\n----------\nG : NetworkX graph\n\npath : string or file\n   Filename or file handle for data output.\n   Filenames ending in .gz or .bz2 will be compressed.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels\n\nencoding : string, optional\n   Text encoding.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_adjlist(G, \"test.adjlist\")\n\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in 'wb' mode.\n\n>>> fh = open(\"test.adjlist\", \"wb\")\n>>> nx.write_adjlist(G, fh)\n\n",
  "code": "@open_file(1, mode='wb')\ndef write_adjlist(G, path, comments='#', delimiter=' ', encoding='utf-8'):\n    import sys\n    import time\n    pargs = comments + ' '.join(sys.argv) + '\\n'\n    header = pargs + comments + f' GMT {time.asctime(time.gmtime())}\\n' + comments + f' {G.name}\\n'\n    path.write(header.encode(encoding))\n    for line in generate_adjlist(G, delimiter):\n        line += '\\n'\n        path.write(line.encode(encoding))"
 },
 {
  "docstring": "Parse lines of a graph adjacency list representation.\n\nParameters\n----------\nlines : list or iterator of strings\n    Input data in adjlist format\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nnodetype : Python type, optional\n   Convert nodes to this type.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels.  The default is whitespace.\n\nReturns\n-------\nG: NetworkX graph\n    The graph corresponding to the lines in adjacency list format.\n\nExamples\n--------\n>>> lines = [\"1 2 5\", \"2 3 4\", \"3 5\", \"4\", \"5\"]\n>>> G = nx.parse_adjlist(lines, nodetype=int)\n>>> nodes = [1, 2, 3, 4, 5]\n>>> all(node in G for node in nodes)\nTrue\n>>> edges = [(1, 2), (1, 5), (2, 3), (2, 4), (3, 5)]\n>>> all((u, v) in G.edges() or (v, u) in G.edges() for (u, v) in edges)\nTrue\n\nSee Also\n--------\nread_adjlist",
  "code": "@nx._dispatch(graphs=None)\ndef parse_adjlist(lines, comments='#', delimiter=None, create_using=None, nodetype=None):\n    G = nx.empty_graph(0, create_using)\n    for line in lines:\n        p = line.find(comments)\n        if p >= 0:\n            line = line[:p]\n        if not len(line):\n            continue\n        vlist = line.strip().split(delimiter)\n        u = vlist.pop(0)\n        if nodetype is not None:\n            try:\n                u = nodetype(u)\n            except BaseException as err:\n                raise TypeError(f'Failed to convert node ({u}) to type {nodetype}') from err\n        G.add_node(u)\n        if nodetype is not None:\n            try:\n                vlist = list(map(nodetype, vlist))\n            except BaseException as err:\n                raise TypeError(f'Failed to convert nodes ({','.join(vlist)}) to type {nodetype}') from err\n        G.add_edges_from([(u, v) for v in vlist])\n    return G"
 },
 {
  "docstring": "Read graph in adjacency list format from path.\n\nParameters\n----------\npath : string or file\n   Filename or file handle to read.\n   Filenames ending in .gz or .bz2 will be uncompressed.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nnodetype : Python type, optional\n   Convert nodes to this type.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels.  The default is whitespace.\n\nReturns\n-------\nG: NetworkX graph\n    The graph corresponding to the lines in adjacency list format.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_adjlist(G, \"test.adjlist\")\n>>> G = nx.read_adjlist(\"test.adjlist\")\n\nThe path can be a filehandle or a string with the name of the file. If a\nfilehandle is provided, it has to be opened in 'rb' mode.\n\n>>> fh = open(\"test.adjlist\", \"rb\")\n>>> G = nx.read_adjlist(fh)\n\nFilenames ending in .gz or .bz2 will be compressed.\n\n>>> nx.write_adjlist(G, \"test.adjlist.gz\")\n>>> G = nx.read_adjlist(\"test.adjlist.gz\")\n\nThe optional nodetype is a function to convert node strings to nodetype.\n\nFor example\n\n>>> G = nx.read_adjlist(\"test.adjlist\", nodetype=int)\n\nwill attempt to convert all nodes to integer type.\n\nSince nodes must be hashable, the function nodetype must return hashable\ntypes (e.g. int, float, str, frozenset - or tuples of those, etc.)\n\nThe optional create_using parameter indicates the type of NetworkX graph\ncreated.  The default is `nx.Graph`, an undirected graph.\nTo read the data as a directed graph use\n\n>>> G = nx.read_adjlist(\"test.adjlist\", create_using=nx.DiGraph)\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_adjlist(path, comments='#', delimiter=None, create_using=None, nodetype=None, encoding='utf-8'):\n    lines = (line.decode(encoding) for line in path)\n    return parse_adjlist(lines, comments=comments, delimiter=delimiter, create_using=create_using, nodetype=nodetype)"
 },
 {
  "docstring": "Generate a single line of the graph G in edge list format.\n\nParameters\n----------\nG : NetworkX graph\n\ndelimiter : string, optional\n   Separator for node labels\n\ndata : bool or list of keys\n   If False generate no edge data.  If True use a dictionary\n   representation of edge data.  If a list of keys use a list of data\n   values corresponding to the keys.\n\nReturns\n-------\nlines : string\n    Lines of data in adjlist format.\n\nExamples\n--------\n>>> G = nx.lollipop_graph(4, 3)\n>>> G[1][2][\"weight\"] = 3\n>>> G[3][4][\"capacity\"] = 12\n>>> for line in nx.generate_edgelist(G, data=False):\n...     print(line)\n0 1\n0 2\n0 3\n1 2\n1 3\n2 3\n3 4\n4 5\n5 6\n\n>>> for line in nx.generate_edgelist(G):\n...     print(line)\n0 1 {}\n0 2 {}\n0 3 {}\n1 2 {'weight': 3}\n1 3 {}\n2 3 {}\n3 4 {'capacity': 12}\n4 5 {}\n5 6 {}\n\n>>> for line in nx.generate_edgelist(G, data=[\"weight\"]):\n...     print(line)\n0 1\n0 2\n0 3\n1 2 3\n1 3\n2 3\n3 4\n4 5\n5 6\n\nSee Also\n--------\nwrite_adjlist, read_adjlist",
  "code": "def generate_edgelist(G, delimiter=' ', data=True):\n    if data is True:\n        for u, v, d in G.edges(data=True):\n            e = (u, v, dict(d))\n            yield delimiter.join(map(str, e))\n    elif data is False:\n        for u, v in G.edges(data=False):\n            e = (u, v)\n            yield delimiter.join(map(str, e))\n    else:\n        for u, v, d in G.edges(data=True):\n            e = [u, v]\n            try:\n                e.extend((d[k] for k in data))\n            except KeyError:\n                pass\n            yield delimiter.join(map(str, e))"
 },
 {
  "docstring": "Write graph as a list of edges.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\npath : file or string\n   File or filename to write. If a file is provided, it must be\n   opened in 'wb' mode. Filenames ending in .gz or .bz2 will be compressed.\ncomments : string, optional\n   The character used to indicate the start of a comment\ndelimiter : string, optional\n   The string used to separate values.  The default is whitespace.\ndata : bool or list, optional\n   If False write no edge data.\n   If True write a string representation of the edge data dictionary..\n   If a list (or other iterable) is provided, write the  keys specified\n   in the list.\nencoding: string, optional\n   Specify which encoding to use when writing file.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_edgelist(G, \"test.edgelist\")\n>>> G = nx.path_graph(4)\n>>> fh = open(\"test.edgelist\", \"wb\")\n>>> nx.write_edgelist(G, fh)\n>>> nx.write_edgelist(G, \"test.edgelist.gz\")\n>>> nx.write_edgelist(G, \"test.edgelist.gz\", data=False)\n\n>>> G = nx.Graph()\n>>> G.add_edge(1, 2, weight=7, color=\"red\")\n>>> nx.write_edgelist(G, \"test.edgelist\", data=False)\n>>> nx.write_edgelist(G, \"test.edgelist\", data=[\"color\"])\n>>> nx.write_edgelist(G, \"test.edgelist\", data=[\"color\", \"weight\"])\n\nSee Also\n--------\nread_edgelist\nwrite_weighted_edgelist",
  "code": "@open_file(1, mode='wb')\ndef write_edgelist(G, path, comments='#', delimiter=' ', data=True, encoding='utf-8'):\n    for line in generate_edgelist(G, delimiter, data):\n        line += '\\n'\n        path.write(line.encode(encoding))"
 },
 {
  "docstring": "Parse lines of an edge list representation of a graph.\n\nParameters\n----------\nlines : list or iterator of strings\n    Input data in edgelist format\ncomments : string, optional\n   Marker for comment lines. Default is `'#'`. To specify that no character\n   should be treated as a comment, use ``comments=None``.\ndelimiter : string, optional\n   Separator for node labels. Default is `None`, meaning any whitespace.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\nnodetype : Python type, optional\n   Convert nodes to this type. Default is `None`, meaning no conversion is\n   performed.\ndata : bool or list of (label,type) tuples\n   If `False` generate no edge data or if `True` use a dictionary\n   representation of edge data or a list tuples specifying dictionary\n   key names and types for edge data.\n\nReturns\n-------\nG: NetworkX Graph\n    The graph corresponding to lines\n\nExamples\n--------\nEdgelist with no data:\n\n>>> lines = [\"1 2\", \"2 3\", \"3 4\"]\n>>> G = nx.parse_edgelist(lines, nodetype=int)\n>>> list(G)\n[1, 2, 3, 4]\n>>> list(G.edges())\n[(1, 2), (2, 3), (3, 4)]\n\nEdgelist with data in Python dictionary representation:\n\n>>> lines = [\"1 2 {'weight': 3}\", \"2 3 {'weight': 27}\", \"3 4 {'weight': 3.0}\"]\n>>> G = nx.parse_edgelist(lines, nodetype=int)\n>>> list(G)\n[1, 2, 3, 4]\n>>> list(G.edges(data=True))\n[(1, 2, {'weight': 3}), (2, 3, {'weight': 27}), (3, 4, {'weight': 3.0})]\n\nEdgelist with data in a list:\n\n>>> lines = [\"1 2 3\", \"2 3 27\", \"3 4 3.0\"]\n>>> G = nx.parse_edgelist(lines, nodetype=int, data=((\"weight\", float),))\n>>> list(G)\n[1, 2, 3, 4]\n>>> list(G.edges(data=True))\n[(1, 2, {'weight': 3.0}), (2, 3, {'weight': 27.0}), (3, 4, {'weight': 3.0})]\n\nSee Also\n--------\nread_weighted_edgelist",
  "code": "@nx._dispatch(graphs=None)\ndef parse_edgelist(lines, comments='#', delimiter=None, create_using=None, nodetype=None, data=True):\n    from ast import literal_eval\n    G = nx.empty_graph(0, create_using)\n    for line in lines:\n        if comments is not None:\n            p = line.find(comments)\n            if p >= 0:\n                line = line[:p]\n            if not line:\n                continue\n        s = line.strip().split(delimiter)\n        if len(s) < 2:\n            continue\n        u = s.pop(0)\n        v = s.pop(0)\n        d = s\n        if nodetype is not None:\n            try:\n                u = nodetype(u)\n                v = nodetype(v)\n            except Exception as err:\n                raise TypeError(f'Failed to convert nodes {u},{v} to type {nodetype}.') from err\n        if len(d) == 0 or data is False:\n            edgedata = {}\n        elif data is True:\n            try:\n                if delimiter == ',':\n                    edgedata_str = ','.join(d)\n                else:\n                    edgedata_str = ' '.join(d)\n                edgedata = dict(literal_eval(edgedata_str.strip()))\n            except Exception as err:\n                raise TypeError(f'Failed to convert edge data ({d}) to dictionary.') from err\n        else:\n            if len(d) != len(data):\n                raise IndexError(f'Edge data {d} and data_keys {data} are not the same length')\n            edgedata = {}\n            for (edge_key, edge_type), edge_value in zip(data, d):\n                try:\n                    edge_value = edge_type(edge_value)\n                except Exception as err:\n                    raise TypeError(f'Failed to convert {edge_key} data {edge_value} to type {edge_type}.') from err\n                edgedata.update({edge_key: edge_value})\n        G.add_edge(u, v, **edgedata)\n    return G"
 },
 {
  "docstring": "Read a graph from a list of edges.\n\nParameters\n----------\npath : file or string\n   File or filename to read. If a file is provided, it must be\n   opened in 'rb' mode.\n   Filenames ending in .gz or .bz2 will be uncompressed.\ncomments : string, optional\n   The character used to indicate the start of a comment. To specify that\n   no character should be treated as a comment, use ``comments=None``.\ndelimiter : string, optional\n   The string used to separate values.  The default is whitespace.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\nnodetype : int, float, str, Python type, optional\n   Convert node data from strings to specified type\ndata : bool or list of (label,type) tuples\n   Tuples specifying dictionary key names and types for edge data\nedgetype : int, float, str, Python type, optional OBSOLETE\n   Convert edge data from strings to specified type and use as 'weight'\nencoding: string, optional\n   Specify which encoding to use when reading file.\n\nReturns\n-------\nG : graph\n   A networkx Graph or other type specified with create_using\n\nExamples\n--------\n>>> nx.write_edgelist(nx.path_graph(4), \"test.edgelist\")\n>>> G = nx.read_edgelist(\"test.edgelist\")\n\n>>> fh = open(\"test.edgelist\", \"rb\")\n>>> G = nx.read_edgelist(fh)\n>>> fh.close()\n\n>>> G = nx.read_edgelist(\"test.edgelist\", nodetype=int)\n>>> G = nx.read_edgelist(\"test.edgelist\", create_using=nx.DiGraph)\n\nEdgelist with data in a list:\n\n>>> textline = \"1 2 3\"\n>>> fh = open(\"test.edgelist\", \"w\")\n>>> d = fh.write(textline)\n>>> fh.close()\n>>> G = nx.read_edgelist(\"test.edgelist\", nodetype=int, data=((\"weight\", float),))\n>>> list(G)\n[1, 2]\n>>> list(G.edges(data=True))\n[(1, 2, {'weight': 3.0})]\n\nSee parse_edgelist() for more examples of formatting.\n\nSee Also\n--------\nparse_edgelist\nwrite_edgelist\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_edgelist(path, comments='#', delimiter=None, create_using=None, nodetype=None, data=True, edgetype=None, encoding='utf-8'):\n    lines = (line if isinstance(line, str) else line.decode(encoding) for line in path)\n    return parse_edgelist(lines, comments=comments, delimiter=delimiter, create_using=create_using, nodetype=nodetype, data=data)"
 },
 {
  "docstring": "Write graph G as a list of edges with numeric weights.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\npath : file or string\n   File or filename to write. If a file is provided, it must be\n   opened in 'wb' mode.\n   Filenames ending in .gz or .bz2 will be compressed.\ncomments : string, optional\n   The character used to indicate the start of a comment\ndelimiter : string, optional\n   The string used to separate values.  The default is whitespace.\nencoding: string, optional\n   Specify which encoding to use when writing file.\n\nExamples\n--------\n>>> G = nx.Graph()\n>>> G.add_edge(1, 2, weight=7)\n>>> nx.write_weighted_edgelist(G, \"test.weighted.edgelist\")\n\nSee Also\n--------\nread_edgelist\nwrite_edgelist\nread_weighted_edgelist",
  "code": "def write_weighted_edgelist(G, path, comments='#', delimiter=' ', encoding='utf-8'):\n    write_edgelist(G, path, comments=comments, delimiter=delimiter, data=('weight',), encoding=encoding)"
 },
 {
  "docstring": "Read a graph as list of edges with numeric weights.\n\nParameters\n----------\npath : file or string\n   File or filename to read. If a file is provided, it must be\n   opened in 'rb' mode.\n   Filenames ending in .gz or .bz2 will be uncompressed.\ncomments : string, optional\n   The character used to indicate the start of a comment.\ndelimiter : string, optional\n   The string used to separate values.  The default is whitespace.\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\nnodetype : int, float, str, Python type, optional\n   Convert node data from strings to specified type\nencoding: string, optional\n   Specify which encoding to use when reading file.\n\nReturns\n-------\nG : graph\n   A networkx Graph or other type specified with create_using\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef read_weighted_edgelist(path, comments='#', delimiter=None, create_using=None, nodetype=None, encoding='utf-8'):\n    return read_edgelist(path, comments=comments, delimiter=delimiter, create_using=create_using, nodetype=nodetype, data=(('weight', float),), encoding=encoding)"
 },
 {
  "docstring": "Write G in GEXF format to path.\n\n\"GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\" [1]_.\n\nNode attributes are checked according to the version of the GEXF\nschemas used for parameters which are not user defined,\ne.g. visualization 'viz' [2]_. See example for usage.\n\nParameters\n----------\nG : graph\n   A NetworkX graph\npath : file or string\n   File or file name to write.\n   File names ending in .gz or .bz2 will be compressed.\nencoding : string (optional, default: 'utf-8')\n   Encoding for text data.\nprettyprint : bool (optional, default: True)\n   If True use line breaks and indenting in output XML.\nversion: string (optional, default: '1.2draft')\n   The version of GEXF to be used for nodes attributes checking\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_gexf(G, \"test.gexf\")\n\n# visualization data\n>>> G.nodes[0][\"viz\"] = {\"size\": 54}\n>>> G.nodes[0][\"viz\"][\"position\"] = {\"x\": 0, \"y\": 1}\n>>> G.nodes[0][\"viz\"][\"color\"] = {\"r\": 0, \"g\": 0, \"b\": 256}\n\n\n",
  "code": "@open_file(1, mode='wb')\ndef write_gexf(G, path, encoding='utf-8', prettyprint=True, version='1.2draft'):\n    writer = GEXFWriter(encoding=encoding, prettyprint=prettyprint, version=version)\n    writer.add_graph(G)\n    writer.write(path)"
 },
 {
  "docstring": "Generate lines of GEXF format representation of G.\n\n\"GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\" [1]_.\n\nParameters\n----------\nG : graph\nA NetworkX graph\nencoding : string (optional, default: 'utf-8')\nEncoding for text data.\nprettyprint : bool (optional, default: True)\nIf True use line breaks and indenting in output XML.\nversion : string (default: 1.2draft)\nVersion of GEFX File Format (see http://gexf.net/schema.html)\nSupported values: \"1.1draft\", \"1.2draft\"\n\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> linefeed = chr(10)  # linefeed=\n\n>>> s = linefeed.join(nx.generate_gexf(G))\n>>> for line in nx.generate_gexf(G):  # doctest: +SKIP\n...     print(line)\n\n",
  "code": "def generate_gexf(G, encoding='utf-8', prettyprint=True, version='1.2draft'):\n    writer = GEXFWriter(encoding=encoding, prettyprint=prettyprint, version=version)\n    writer.add_graph(G)\n    yield from str(writer).splitlines()"
 },
 {
  "docstring": "Read graph in GEXF format from path.\n\n\"GEXF (Graph Exchange XML Format) is a language for describing\ncomplex networks structures, their associated data and dynamics\" [1]_.\n\nParameters\n----------\npath : file or string\n   File or file name to read.\n   File names ending in .gz or .bz2 will be decompressed.\nnode_type: Python type (default: None)\n   Convert node ids to this type if not None.\nrelabel : bool (default: False)\n   If True relabel the nodes to use the GEXF node \"label\" attribute\n   instead of the node \"id\" attribute as the NetworkX node label.\nversion : string (default: 1.2draft)\nVersion of GEFX File Format (see http://gexf.net/schema.html)\n   Supported values: \"1.1draft\", \"1.2draft\"\n\nReturns\n-------\ngraph: NetworkX graph\n    If no parallel edges are found a Graph or DiGraph is returned.\n    Otherwise a MultiGraph or MultiDiGraph is returned.\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_gexf(path, node_type=None, relabel=False, version='1.2draft'):\n    reader = GEXFReader(node_type=node_type, version=version)\n    if relabel:\n        G = relabel_gexf_graph(reader(path))\n    else:\n        G = reader(path)\n    return G"
 },
 {
  "docstring": "Relabel graph using \"label\" node keyword for node label.\n\nParameters\n----------\nG : graph\n   A NetworkX graph read from GEXF data\n\nReturns\n-------\nH : graph\n  A NetworkX graph with relabeled nodes\n\nRaises\n------\nNetworkXError\n    If node labels are missing or not unique while relabel=True.\n\n",
  "code": "def relabel_gexf_graph(G):\n    try:\n        mapping = [(u, G.nodes[u]['label']) for u in G]\n    except KeyError as err:\n        raise nx.NetworkXError('Failed to relabel nodes: missing node labels found. Use relabel=False.') from err\n    x, y = zip(*mapping)\n    if len(set(y)) != len(G):\n        raise nx.NetworkXError('Failed to relabel nodes: duplicate node labels found. Use relabel=False.')\n    mapping = dict(mapping)\n    H = nx.relabel_nodes(G, mapping)\n    for n in G:\n        m = mapping[n]\n        H.nodes[m]['id'] = n\n        H.nodes[m].pop('label')\n        if 'pid' in H.nodes[m]:\n            H.nodes[m]['pid'] = mapping[G.nodes[n]['pid']]\n        if 'parents' in H.nodes[m]:\n            H.nodes[m]['parents'] = [mapping[p] for p in G.nodes[n]['parents']]\n    return H"
 },
 {
  "docstring": "Use XML character references to escape characters.\n\nUse XML character references for unprintable or non-ASCII\ncharacters, double quotes and ampersands in a string",
  "code": "def escape(text):\n\n    def fixup(m):\n        ch = m.group(0)\n        return '&#' + str(ord(ch)) + ';'\n    text = re.sub('[^ -~]|[&\"]', fixup, text)\n    return text if isinstance(text, str) else str(text)"
 },
 {
  "docstring": "Replace XML character references with the referenced characters",
  "code": "def unescape(text):\n\n    def fixup(m):\n        text = m.group(0)\n        if text[1] == '#':\n            if text[2] == 'x':\n                code = int(text[3:-1], 16)\n            else:\n                code = int(text[2:-1])\n        else:\n            try:\n                code = htmlentitydefs.name2codepoint[text[1:-1]]\n            except KeyError:\n                return text\n        try:\n            return chr(code)\n        except (ValueError, OverflowError):\n            return text\n    return re.sub('&(?:[0-9A-Za-z]+|#(?:[0-9]+|x[0-9A-Fa-f]+));', fixup, text)"
 },
 {
  "docstring": "Convert a Python literal to the value it represents.\n\nParameters\n----------\nrep : string\n    A Python literal.\n\nReturns\n-------\nvalue : object\n    The value of the Python literal.\n\nRaises\n------\nValueError\n    If `rep` is not a Python literal.",
  "code": "def literal_destringizer(rep):\n    if isinstance(rep, str):\n        orig_rep = rep\n        try:\n            return literal_eval(rep)\n        except SyntaxError as err:\n            raise ValueError(f'{orig_rep!r} is not a valid Python literal') from err\n    else:\n        raise ValueError(f'{rep!r} is not a string')"
 },
 {
  "docstring": "Read graph in GML format from `path`.\n\nParameters\n----------\npath : filename or filehandle\n    The filename or filehandle to read from.\n\nlabel : string, optional\n    If not None, the parsed nodes will be renamed according to node\n    attributes indicated by `label`. Default value: 'label'.\n\ndestringizer : callable, optional\n    A `destringizer` that recovers values stored as strings in GML. If it\n    cannot convert a string to a value, a `ValueError` is raised. Default\n    value : None.\n\nReturns\n-------\nG : NetworkX graph\n    The parsed graph.\n\nRaises\n------\nNetworkXError\n    If the input cannot be parsed.\n\nSee Also\n--------\nwrite_gml, parse_gml\nliteral_destringizer\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_gml(path, label='label', destringizer=None):\n\n    def filter_lines(lines):\n        for line in lines:\n            try:\n                line = line.decode('ascii')\n            except UnicodeDecodeError as err:\n                raise NetworkXError('input is not ASCII-encoded') from err\n            if not isinstance(line, str):\n                lines = str(lines)\n            if line and line[-1] == '\\n':\n                line = line[:-1]\n            yield line\n    G = parse_gml_lines(filter_lines(path), label, destringizer)\n    return G"
 },
 {
  "docstring": "Parse GML graph from a string or iterable.\n\nParameters\n----------\nlines : string or iterable of strings\n   Data in GML format.\n\nlabel : string, optional\n    If not None, the parsed nodes will be renamed according to node\n    attributes indicated by `label`. Default value: 'label'.\n\ndestringizer : callable, optional\n    A `destringizer` that recovers values stored as strings in GML. If it\n    cannot convert a string to a value, a `ValueError` is raised. Default\n    value : None.\n\nReturns\n-------\nG : NetworkX graph\n    The parsed graph.\n\nRaises\n------\nNetworkXError\n    If the input cannot be parsed.\n\nSee Also\n--------\nwrite_gml, read_gml\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef parse_gml(lines, label='label', destringizer=None):\n\n    def decode_line(line):\n        if isinstance(line, bytes):\n            try:\n                line.decode('ascii')\n            except UnicodeDecodeError as err:\n                raise NetworkXError('input is not ASCII-encoded') from err\n        if not isinstance(line, str):\n            line = str(line)\n        return line\n\n    def filter_lines(lines):\n        if isinstance(lines, str):\n            lines = decode_line(lines)\n            lines = lines.splitlines()\n            yield from lines\n        else:\n            for line in lines:\n                line = decode_line(line)\n                if line and line[-1] == '\\n':\n                    line = line[:-1]\n                if line.find('\\n') != -1:\n                    raise NetworkXError('input line contains newline')\n                yield line\n    G = parse_gml_lines(filter_lines(lines), label, destringizer)\n    return G"
 },
 {
  "docstring": "Parse GML `lines` into a graph.",
  "code": "def parse_gml_lines(lines, label, destringizer):\n\n    def tokenize():\n        patterns = ['[A-Za-z][0-9A-Za-z_]*\\\\b', '[+-]?(?:[0-9]*\\\\.[0-9]+|[0-9]+\\\\.[0-9]*|INF)(?:[Ee][+-]?[0-9]+)?', '[+-]?[0-9]+', '\".*?\"', '\\\\[', '\\\\]', '#.*$|\\\\s+']\n        tokens = re.compile('|'.join((f'({pattern})' for pattern in patterns)))\n        lineno = 0\n        multilines = []\n        for line in lines:\n            pos = 0\n            if multilines:\n                multilines.append(line.strip())\n                if line[-1] == '\"':\n                    line = ' '.join(multilines)\n                    multilines = []\n                else:\n                    lineno += 1\n                    continue\n            elif line.count('\"') == 1:\n                if line.strip()[0] != '\"' and line.strip()[-1] != '\"':\n                    multilines = [line.rstrip()]\n                    lineno += 1\n                    continue\n            length = len(line)\n            while pos < length:\n                match = tokens.match(line, pos)\n                if match is None:\n                    m = f'cannot tokenize {line[pos:]} at ({lineno + 1}, {pos + 1})'\n                    raise NetworkXError(m)\n                for i in range(len(patterns)):\n                    group = match.group(i + 1)\n                    if group is not None:\n                        if i == 0:\n                            value = group.rstrip()\n                        elif i == 1:\n                            value = float(group)\n                        elif i == 2:\n                            value = int(group)\n                        else:\n                            value = group\n                        if i != 6:\n                            yield Token(Pattern(i), value, lineno + 1, pos + 1)\n                        pos += len(group)\n                        break\n            lineno += 1\n        yield Token(None, None, lineno + 1, 1)\n\n    def unexpected(curr_token, expected):\n        category, value, lineno, pos = curr_token\n        value = repr(value) if value is not None else 'EOF'\n        raise NetworkXError(f'expected {expected}, found {value} at ({lineno}, {pos})')\n\n    def consume(curr_token, category, expected):\n        if curr_token.category == category:\n            return next(tokens)\n        unexpected(curr_token, expected)\n\n    def parse_kv(curr_token):\n        dct = defaultdict(list)\n        while curr_token.category == Pattern.KEYS:\n            key = curr_token.value\n            curr_token = next(tokens)\n            category = curr_token.category\n            if category == Pattern.REALS or category == Pattern.INTS:\n                value = curr_token.value\n                curr_token = next(tokens)\n            elif category == Pattern.STRINGS:\n                value = unescape(curr_token.value[1:-1])\n                if destringizer:\n                    try:\n                        value = destringizer(value)\n                    except ValueError:\n                        pass\n                if value == '()':\n                    value = ()\n                if value == '[]':\n                    value = []\n                curr_token = next(tokens)\n            elif category == Pattern.DICT_START:\n                curr_token, value = parse_dict(curr_token)\n            elif key in ('id', 'label', 'source', 'target'):\n                try:\n                    value = unescape(str(curr_token.value))\n                    if destringizer:\n                        try:\n                            value = destringizer(value)\n                        except ValueError:\n                            pass\n                    curr_token = next(tokens)\n                except Exception:\n                    msg = \"an int, float, string, '[' or string\" + ' convertible ASCII value for node id or label'\n                    unexpected(curr_token, msg)\n            elif curr_token.value in {'NAN', 'INF'}:\n                value = float(curr_token.value)\n                curr_token = next(tokens)\n            else:\n                unexpected(curr_token, \"an int, float, string or '['\")\n            dct[key].append(value)\n\n        def clean_dict_value(value):\n            if not isinstance(value, list):\n                return value\n            if len(value) == 1:\n                return value[0]\n            if value[0] == LIST_START_VALUE:\n                return value[1:]\n            return value\n        dct = {key: clean_dict_value(value) for key, value in dct.items()}\n        return (curr_token, dct)\n\n    def parse_dict(curr_token):\n        curr_token = consume(curr_token, Pattern.DICT_START, \"'['\")\n        curr_token, dct = parse_kv(curr_token)\n        curr_token = consume(curr_token, Pattern.DICT_END, \"']'\")\n        return (curr_token, dct)\n\n    def parse_graph():\n        curr_token, dct = parse_kv(next(tokens))\n        if curr_token.category is not None:\n            unexpected(curr_token, 'EOF')\n        if 'graph' not in dct:\n            raise NetworkXError('input contains no graph')\n        graph = dct['graph']\n        if isinstance(graph, list):\n            raise NetworkXError('input contains more than one graph')\n        return graph\n    tokens = tokenize()\n    graph = parse_graph()\n    directed = graph.pop('directed', False)\n    multigraph = graph.pop('multigraph', False)\n    if not multigraph:\n        G = nx.DiGraph() if directed else nx.Graph()\n    else:\n        G = nx.MultiDiGraph() if directed else nx.MultiGraph()\n    graph_attr = {k: v for k, v in graph.items() if k not in ('node', 'edge')}\n    G.graph.update(graph_attr)\n\n    def pop_attr(dct, category, attr, i):\n        try:\n            return dct.pop(attr)\n        except KeyError as err:\n            raise NetworkXError(f'{category} #{i} has no {attr!r} attribute') from err\n    nodes = graph.get('node', [])\n    mapping = {}\n    node_labels = set()\n    for i, node in enumerate(nodes if isinstance(nodes, list) else [nodes]):\n        id = pop_attr(node, 'node', 'id', i)\n        if id in G:\n            raise NetworkXError(f'node id {id!r} is duplicated')\n        if label is not None and label != 'id':\n            node_label = pop_attr(node, 'node', label, i)\n            if node_label in node_labels:\n                raise NetworkXError(f'node label {node_label!r} is duplicated')\n            node_labels.add(node_label)\n            mapping[id] = node_label\n        G.add_node(id, **node)\n    edges = graph.get('edge', [])\n    for i, edge in enumerate(edges if isinstance(edges, list) else [edges]):\n        source = pop_attr(edge, 'edge', 'source', i)\n        target = pop_attr(edge, 'edge', 'target', i)\n        if source not in G:\n            raise NetworkXError(f'edge #{i} has undefined source {source!r}')\n        if target not in G:\n            raise NetworkXError(f'edge #{i} has undefined target {target!r}')\n        if not multigraph:\n            if not G.has_edge(source, target):\n                G.add_edge(source, target, **edge)\n            else:\n                arrow = '->' if directed else '--'\n                msg = f'edge #{i} ({source!r}{arrow}{target!r}) is duplicated'\n                raise nx.NetworkXError(msg)\n        else:\n            key = edge.pop('key', None)\n            if key is not None and G.has_edge(source, target, key):\n                arrow = '->' if directed else '--'\n                msg = f'edge #{i} ({source!r}{arrow}{target!r}, {key!r})'\n                msg2 = 'Hint: If multigraph add \"multigraph 1\" to file header.'\n                raise nx.NetworkXError(msg + ' is duplicated\\n' + msg2)\n            G.add_edge(source, target, key, **edge)\n    if label is not None and label != 'id':\n        G = nx.relabel_nodes(G, mapping)\n    return G"
 },
 {
  "docstring": "Convert a `value` to a Python literal in GML representation.\n\nParameters\n----------\nvalue : object\n    The `value` to be converted to GML representation.\n\nReturns\n-------\nrep : string\n    A double-quoted Python literal representing value. Unprintable\n    characters are replaced by XML character references.\n\nRaises\n------\nValueError\n    If `value` cannot be converted to GML.\n\n",
  "code": "def literal_stringizer(value):\n\n    def stringize(value):\n        if isinstance(value, int | bool) or value is None:\n            if value is True:\n                buf.write(str(1))\n            elif value is False:\n                buf.write(str(0))\n            else:\n                buf.write(str(value))\n        elif isinstance(value, str):\n            text = repr(value)\n            if text[0] != 'u':\n                try:\n                    value.encode('latin1')\n                except UnicodeEncodeError:\n                    text = 'u' + text\n            buf.write(text)\n        elif isinstance(value, float | complex | str | bytes):\n            buf.write(repr(value))\n        elif isinstance(value, list):\n            buf.write('[')\n            first = True\n            for item in value:\n                if not first:\n                    buf.write(',')\n                else:\n                    first = False\n                stringize(item)\n            buf.write(']')\n        elif isinstance(value, tuple):\n            if len(value) > 1:\n                buf.write('(')\n                first = True\n                for item in value:\n                    if not first:\n                        buf.write(',')\n                    else:\n                        first = False\n                    stringize(item)\n                buf.write(')')\n            elif value:\n                buf.write('(')\n                stringize(value[0])\n                buf.write(',)')\n            else:\n                buf.write('()')\n        elif isinstance(value, dict):\n            buf.write('{')\n            first = True\n            for key, value in value.items():\n                if not first:\n                    buf.write(',')\n                else:\n                    first = False\n                stringize(key)\n                buf.write(':')\n                stringize(value)\n            buf.write('}')\n        elif isinstance(value, set):\n            buf.write('{')\n            first = True\n            for item in value:\n                if not first:\n                    buf.write(',')\n                else:\n                    first = False\n                stringize(item)\n            buf.write('}')\n        else:\n            msg = f'{value!r} cannot be converted into a Python literal'\n            raise ValueError(msg)\n    buf = StringIO()\n    stringize(value)\n    return buf.getvalue()"
 },
 {
  "docstring": "Generate a single entry of the graph `G` in GML format.\n\nParameters\n----------\nG : NetworkX graph\n    The graph to be converted to GML.\n\nstringizer : callable, optional\n    A `stringizer` which converts non-int/non-float/non-dict values into\n    strings. If it cannot convert a value into a string, it should raise a\n    `ValueError` to indicate that. Default value: None.\n\nReturns\n-------\nlines: generator of strings\n    Lines of GML data. Newlines are not appended.\n\nRaises\n------\nNetworkXError\n    If `stringizer` cannot convert a value into a string, or the value to\n    convert is not a string while `stringizer` is None.\n\nSee Also\n--------\nliteral_stringizer\n\n",
  "code": "def generate_gml(G, stringizer=None):\n    valid_keys = re.compile('^[A-Za-z][0-9A-Za-z_]*$')\n\n    def stringize(key, value, ignored_keys, indent, in_list=False):\n        if not isinstance(key, str):\n            raise NetworkXError(f'{key!r} is not a string')\n        if not valid_keys.match(key):\n            raise NetworkXError(f'{key!r} is not a valid key')\n        if not isinstance(key, str):\n            key = str(key)\n        if key not in ignored_keys:\n            if isinstance(value, int | bool):\n                if key == 'label':\n                    yield (indent + key + ' \"' + str(value) + '\"')\n                elif value is True:\n                    yield (indent + key + ' 1')\n                elif value is False:\n                    yield (indent + key + ' 0')\n                elif value < -2 ** 31 or value >= 2 ** 31:\n                    yield (indent + key + ' \"' + str(value) + '\"')\n                else:\n                    yield (indent + key + ' ' + str(value))\n            elif isinstance(value, float):\n                text = repr(value).upper()\n                if text == repr(float('inf')).upper():\n                    text = '+' + text\n                else:\n                    epos = text.rfind('E')\n                    if epos != -1 and text.find('.', 0, epos) == -1:\n                        text = text[:epos] + '.' + text[epos:]\n                if key == 'label':\n                    yield (indent + key + ' \"' + text + '\"')\n                else:\n                    yield (indent + key + ' ' + text)\n            elif isinstance(value, dict):\n                yield (indent + key + ' [')\n                next_indent = indent + '  '\n                for key, value in value.items():\n                    yield from stringize(key, value, (), next_indent)\n                yield (indent + ']')\n            elif isinstance(value, tuple) and key == 'label':\n                yield (indent + key + f' \"({','.join((repr(v) for v in value))})\"')\n            elif isinstance(value, list | tuple) and key != 'label' and (not in_list):\n                if len(value) == 0:\n                    yield (indent + key + ' ' + f'\"{value!r}\"')\n                if len(value) == 1:\n                    yield (indent + key + ' ' + f'\"{LIST_START_VALUE}\"')\n                for val in value:\n                    yield from stringize(key, val, (), indent, True)\n            else:\n                if stringizer:\n                    try:\n                        value = stringizer(value)\n                    except ValueError as err:\n                        raise NetworkXError(f'{value!r} cannot be converted into a string') from err\n                if not isinstance(value, str):\n                    raise NetworkXError(f'{value!r} is not a string')\n                yield (indent + key + ' \"' + escape(value) + '\"')\n    multigraph = G.is_multigraph()\n    yield 'graph ['\n    if G.is_directed():\n        yield '  directed 1'\n    if multigraph:\n        yield '  multigraph 1'\n    ignored_keys = {'directed', 'multigraph', 'node', 'edge'}\n    for attr, value in G.graph.items():\n        yield from stringize(attr, value, ignored_keys, '  ')\n    node_id = dict(zip(G, range(len(G))))\n    ignored_keys = {'id', 'label'}\n    for node, attrs in G.nodes.items():\n        yield '  node ['\n        yield ('    id ' + str(node_id[node]))\n        yield from stringize('label', node, (), '    ')\n        for attr, value in attrs.items():\n            yield from stringize(attr, value, ignored_keys, '    ')\n        yield '  ]'\n    ignored_keys = {'source', 'target'}\n    kwargs = {'data': True}\n    if multigraph:\n        ignored_keys.add('key')\n        kwargs['keys'] = True\n    for e in G.edges(**kwargs):\n        yield '  edge ['\n        yield ('    source ' + str(node_id[e[0]]))\n        yield ('    target ' + str(node_id[e[1]]))\n        if multigraph:\n            yield from stringize('key', e[2], (), '    ')\n        for attr, value in e[-1].items():\n            yield from stringize(attr, value, ignored_keys, '    ')\n        yield '  ]'\n    yield ']'"
 },
 {
  "docstring": "Write a graph `G` in GML format to the file or file handle `path`.\n\nParameters\n----------\nG : NetworkX graph\n    The graph to be converted to GML.\n\npath : filename or filehandle\n    The filename or filehandle to write. Files whose names end with .gz or\n    .bz2 will be compressed.\n\nstringizer : callable, optional\n    A `stringizer` which converts non-int/non-float/non-dict values into\n    strings. If it cannot convert a value into a string, it should raise a\n    `ValueError` to indicate that. Default value: None.\n\nRaises\n------\nNetworkXError\n    If `stringizer` cannot convert a value into a string, or the value to\n    convert is not a string while `stringizer` is None.\n\nSee Also\n--------\nread_gml, generate_gml\nliteral_stringizer\n\n",
  "code": "@open_file(1, mode='wb')\ndef write_gml(G, path, stringizer=None):\n    for line in generate_gml(G, stringizer):\n        path.write((line + '\\n').encode('ascii'))"
 },
 {
  "docstring": "Yield bytes in the graph6 encoding of a graph.\n\n`G` is an undirected simple graph. `nodes` is the list of nodes for\nwhich the node-induced subgraph will be encoded; if `nodes` is the\nlist of all nodes in the graph, the entire graph will be\nencoded. `header` is a Boolean that specifies whether to generate\nthe header ``b'>>graph6<<'`` before the remaining data.\n\nThis function generates `bytes` objects in the following order:\n\n1. the header (if requested),\n2. the encoding of the number of nodes,\n3. each character, one-at-a-time, in the encoding of the requested\n   node-induced subgraph,\n4. a newline character.\n\nThis function raises :exc:`ValueError` if the graph is too large for\nthe graph6 format (that is, greater than ``2 ** 36`` nodes).",
  "code": "def _generate_graph6_bytes(G, nodes, header):\n    n = len(G)\n    if n >= 2 ** 36:\n        raise ValueError('graph6 is only defined if number of nodes is less than 2 ** 36')\n    if header:\n        yield b'>>graph6<<'\n    for d in n_to_data(n):\n        yield str.encode(chr(d + 63))\n    bits = (nodes[j] in G[nodes[i]] for j in range(1, n) for i in range(j))\n    chunk = list(islice(bits, 6))\n    while chunk:\n        d = sum((b << 5 - i for i, b in enumerate(chunk)))\n        yield str.encode(chr(d + 63))\n        chunk = list(islice(bits, 6))\n    yield b'\\n'"
 },
 {
  "docstring": "Read a simple undirected graph in graph6 format from bytes.\n\nParameters\n----------\nbytes_in : bytes\n   Data in graph6 format, without a trailing newline.\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If bytes_in is unable to be parsed in graph6 format\n\nValueError\n    If any character ``c`` in bytes_in does not satisfy\n    ``63 <= ord(c) < 127``.\n\nExamples\n--------\n>>> G = nx.from_graph6_bytes(b\"A_\")\n>>> sorted(G.edges())\n[(0, 1)]\n\nSee Also\n--------\nread_graph6, write_graph6\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef from_graph6_bytes(bytes_in):\n\n    def bits():\n        \"\"\"Returns sequence of individual bits from 6-bit-per-value\n        list of data values.\"\"\"\n        for d in data:\n            for i in [5, 4, 3, 2, 1, 0]:\n                yield (d >> i & 1)\n    if bytes_in.startswith(b'>>graph6<<'):\n        bytes_in = bytes_in[10:]\n    data = [c - 63 for c in bytes_in]\n    if any((c > 63 for c in data)):\n        raise ValueError('each input character must be in range(63, 127)')\n    n, data = data_to_n(data)\n    nd = (n * (n - 1) // 2 + 5) // 6\n    if len(data) != nd:\n        raise NetworkXError(f'Expected {n * (n - 1) // 2} bits but got {len(data) * 6} in graph6')\n    G = nx.Graph()\n    G.add_nodes_from(range(n))\n    for (i, j), b in zip(((i, j) for j in range(1, n) for i in range(j)), bits()):\n        if b:\n            G.add_edge(i, j)\n    return G"
 },
 {
  "docstring": "Convert a simple undirected graph to bytes in graph6 format.\n\nParameters\n----------\nG : Graph (undirected)\n\nnodes: list or iterable\n   Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n   given by ``G.nodes()`` is used.\n\nheader: bool\n   If True add '>>graph6<<' bytes to head of data.\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed or is a multigraph.\n\nValueError\n    If the graph has at least ``2 ** 36`` nodes; the graph6 format\n    is only defined for graphs of order less than ``2 ** 36``.\n\nExamples\n--------\n>>> nx.to_graph6_bytes(nx.path_graph(2))\nb'>>graph6<<A_\\n'\n\nSee Also\n--------\nfrom_graph6_bytes, read_graph6, write_graph6_bytes\n\n",
  "code": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\ndef to_graph6_bytes(G, nodes=None, header=True):\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    H = nx.convert_node_labels_to_integers(G)\n    nodes = sorted(H.nodes())\n    return b''.join(_generate_graph6_bytes(H, nodes, header))"
 },
 {
  "docstring": "Read simple undirected graphs in graph6 format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to write.\n\nReturns\n-------\nG : Graph or list of Graphs\n   If the file contains multiple lines then a list of graphs is returned\n\nRaises\n------\nNetworkXError\n    If the string is unable to be parsed in graph6 format\n\nExamples\n--------\nYou can read a graph6 file by giving the path to the file::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n    ...     _ = f.write(b\">>graph6<<A_\\n\")\n    ...     _ = f.seek(0)\n    ...     G = nx.read_graph6(f.name)\n    >>> list(G.edges())\n    [(0, 1)]\n\nYou can also read a graph6 file by giving an open file-like object::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile() as f:\n    ...     _ = f.write(b\">>graph6<<A_\\n\")\n    ...     _ = f.seek(0)\n    ...     G = nx.read_graph6(f)\n    >>> list(G.edges())\n    [(0, 1)]\n\nSee Also\n--------\nfrom_graph6_bytes, write_graph6\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_graph6(path):\n    glist = []\n    for line in path:\n        line = line.strip()\n        if not len(line):\n            continue\n        glist.append(from_graph6_bytes(line))\n    if len(glist) == 1:\n        return glist[0]\n    else:\n        return glist"
 },
 {
  "docstring": "Write a simple undirected graph to a path in graph6 format.\n\nParameters\n----------\nG : Graph (undirected)\n\npath : str\n   The path naming the file to which to write the graph.\n\nnodes: list or iterable\n   Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n   given by ``G.nodes()`` is used.\n\nheader: bool\n   If True add '>>graph6<<' string to head of data\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed or is a multigraph.\n\nValueError\n    If the graph has at least ``2 ** 36`` nodes; the graph6 format\n    is only defined for graphs of order less than ``2 ** 36``.\n\nExamples\n--------\nYou can write a graph6 file by giving the path to a file::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n    ...     nx.write_graph6(nx.path_graph(2), f.name)\n    ...     _ = f.seek(0)\n    ...     print(f.read())\n    b'>>graph6<<A_\\n'\n\nSee Also\n--------\nfrom_graph6_bytes, read_graph6\n\n",
  "code": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\n@open_file(1, mode='wb')\ndef write_graph6(G, path, nodes=None, header=True):\n    return write_graph6_file(G, path, nodes=nodes, header=header)"
 },
 {
  "docstring": "Write a simple undirected graph to a file-like object in graph6 format.\n\nParameters\n----------\nG : Graph (undirected)\n\nf : file-like object\n   The file to write.\n\nnodes: list or iterable\n   Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n   given by ``G.nodes()`` is used.\n\nheader: bool\n   If True add '>>graph6<<' string to head of data\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed or is a multigraph.\n\nValueError\n    If the graph has at least ``2 ** 36`` nodes; the graph6 format\n    is only defined for graphs of order less than ``2 ** 36``.\n\nExamples\n--------\nYou can write a graph6 file by giving an open file-like object::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile() as f:\n    ...     nx.write_graph6(nx.path_graph(2), f)\n    ...     _ = f.seek(0)\n    ...     print(f.read())\n    b'>>graph6<<A_\\n'\n\nSee Also\n--------\nfrom_graph6_bytes, read_graph6\n\n",
  "code": "@not_implemented_for('directed')\n@not_implemented_for('multigraph')\ndef write_graph6_file(G, f, nodes=None, header=True):\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    H = nx.convert_node_labels_to_integers(G)\n    nodes = sorted(H.nodes())\n    for b in _generate_graph6_bytes(H, nodes, header):\n        f.write(b)"
 },
 {
  "docstring": "Read initial one-, four- or eight-unit value from graph6\ninteger sequence.\n\nReturn (value, rest of seq.)",
  "code": "def data_to_n(data):\n    if data[0] <= 62:\n        return (data[0], data[1:])\n    if data[1] <= 62:\n        return ((data[1] << 12) + (data[2] << 6) + data[3], data[4:])\n    return ((data[2] << 30) + (data[3] << 24) + (data[4] << 18) + (data[5] << 12) + (data[6] << 6) + data[7], data[8:])"
 },
 {
  "docstring": "Convert an integer to one-, four- or eight-unit graph6 sequence.\n\nThis function is undefined if `n` is not in ``range(2 ** 36)``.",
  "code": "def n_to_data(n):\n    if n <= 62:\n        return [n]\n    elif n <= 258047:\n        return [63, n >> 12 & 63, n >> 6 & 63, n & 63]\n    else:\n        return [63, 63, n >> 30 & 63, n >> 24 & 63, n >> 18 & 63, n >> 12 & 63, n >> 6 & 63, n & 63]"
 },
 {
  "docstring": "Returns sequence of individual bits from 6-bit-per-value\nlist of data values.",
  "code": "def bits():\n    for d in data:\n        for i in [5, 4, 3, 2, 1, 0]:\n            yield (d >> i & 1)"
 },
 {
  "docstring": "Write G in GraphML XML format to path\n\nParameters\n----------\nG : graph\n   A networkx graph\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be compressed.\nencoding : string (optional)\n   Encoding for text data.\nprettyprint : bool (optional)\n   If True use line breaks and indenting in output XML.\ninfer_numeric_types : boolean\n   Determine if numeric types should be generalized.\n   For example, if edges have both int and float 'weight' attributes,\n   we infer in GraphML that both are floats.\nnamed_key_ids : bool (optional)\n   If True use attr.name as value for key elements' id attribute.\nedge_id_from_attribute : dict key (optional)\n    If provided, the graphml edge id is set by looking up the corresponding\n    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,\n    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_graphml(G, \"test.graphml\")\n\n",
  "code": "@open_file(1, mode='wb')\ndef write_graphml_xml(G, path, encoding='utf-8', prettyprint=True, infer_numeric_types=False, named_key_ids=False, edge_id_from_attribute=None):\n    writer = GraphMLWriter(encoding=encoding, prettyprint=prettyprint, infer_numeric_types=infer_numeric_types, named_key_ids=named_key_ids, edge_id_from_attribute=edge_id_from_attribute)\n    writer.add_graph_element(G)\n    writer.dump(path)"
 },
 {
  "docstring": "Write G in GraphML XML format to path\n\nThis function uses the LXML framework and should be faster than\nthe version using the xml library.\n\nParameters\n----------\nG : graph\n   A networkx graph\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be compressed.\nencoding : string (optional)\n   Encoding for text data.\nprettyprint : bool (optional)\n   If True use line breaks and indenting in output XML.\ninfer_numeric_types : boolean\n   Determine if numeric types should be generalized.\n   For example, if edges have both int and float 'weight' attributes,\n   we infer in GraphML that both are floats.\nnamed_key_ids : bool (optional)\n   If True use attr.name as value for key elements' id attribute.\nedge_id_from_attribute : dict key (optional)\n    If provided, the graphml edge id is set by looking up the corresponding\n    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,\n    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_graphml_lxml(G, \"fourpath.graphml\")\n\n",
  "code": "@open_file(1, mode='wb')\ndef write_graphml_lxml(G, path, encoding='utf-8', prettyprint=True, infer_numeric_types=False, named_key_ids=False, edge_id_from_attribute=None):\n    try:\n        import lxml.etree as lxmletree\n    except ImportError:\n        return write_graphml_xml(G, path, encoding, prettyprint, infer_numeric_types, named_key_ids, edge_id_from_attribute)\n    writer = GraphMLWriterLxml(path, graph=G, encoding=encoding, prettyprint=prettyprint, infer_numeric_types=infer_numeric_types, named_key_ids=named_key_ids, edge_id_from_attribute=edge_id_from_attribute)\n    writer.dump()"
 },
 {
  "docstring": "Generate GraphML lines for G\n\nParameters\n----------\nG : graph\n   A networkx graph\nencoding : string (optional)\n   Encoding for text data.\nprettyprint : bool (optional)\n   If True use line breaks and indenting in output XML.\nnamed_key_ids : bool (optional)\n   If True use attr.name as value for key elements' id attribute.\nedge_id_from_attribute : dict key (optional)\n    If provided, the graphml edge id is set by looking up the corresponding\n    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,\n    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> linefeed = chr(10)  # linefeed = \n\n>>> s = linefeed.join(nx.generate_graphml(G))\n>>> for line in nx.generate_graphml(G):  # doctest: +SKIP\n...     print(line)\n\n",
  "code": "def generate_graphml(G, encoding='utf-8', prettyprint=True, named_key_ids=False, edge_id_from_attribute=None):\n    writer = GraphMLWriter(encoding=encoding, prettyprint=prettyprint, named_key_ids=named_key_ids, edge_id_from_attribute=edge_id_from_attribute)\n    writer.add_graph_element(G)\n    yield from str(writer).splitlines()"
 },
 {
  "docstring": "Read graph in GraphML format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be compressed.\n\nnode_type: Python type (default: str)\n   Convert node ids to this type\n\nedge_key_type: Python type (default: int)\n   Convert graphml edge ids to this type. Multigraphs use id as edge key.\n   Non-multigraphs add to edge attribute dict with name \"id\".\n\nforce_multigraph : bool (default: False)\n   If True, return a multigraph with edge keys. If False (the default)\n   return a multigraph when multiedges are in the graph.\n\nReturns\n-------\ngraph: NetworkX graph\n    If parallel edges are present or `force_multigraph=True` then\n    a MultiGraph or MultiDiGraph is returned. Otherwise a Graph/DiGraph.\n    The returned graph is directed if the file indicates it should be.\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_graphml(path, node_type=str, edge_key_type=int, force_multigraph=False):\n    reader = GraphMLReader(node_type, edge_key_type, force_multigraph)\n    glist = list(reader(path=path))\n    if len(glist) == 0:\n        header = b'<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\">'\n        path.seek(0)\n        old_bytes = path.read()\n        new_bytes = old_bytes.replace(b'<graphml>', header)\n        glist = list(reader(string=new_bytes))\n        if len(glist) == 0:\n            raise nx.NetworkXError('file not successfully read as graphml')\n    return glist[0]"
 },
 {
  "docstring": "Read graph in GraphML format from string.\n\nParameters\n----------\ngraphml_string : string\n   String containing graphml information\n   (e.g., contents of a graphml file).\n\nnode_type: Python type (default: str)\n   Convert node ids to this type\n\nedge_key_type: Python type (default: int)\n   Convert graphml edge ids to this type. Multigraphs use id as edge key.\n   Non-multigraphs add to edge attribute dict with name \"id\".\n\nforce_multigraph : bool (default: False)\n   If True, return a multigraph with edge keys. If False (the default)\n   return a multigraph when multiedges are in the graph.\n\n\nReturns\n-------\ngraph: NetworkX graph\n    If no parallel edges are found a Graph or DiGraph is returned.\n    Otherwise a MultiGraph or MultiDiGraph is returned.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> linefeed = chr(10)  # linefeed = \n\n>>> s = linefeed.join(nx.generate_graphml(G))\n>>> H = nx.parse_graphml(s)\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef parse_graphml(graphml_string, node_type=str, edge_key_type=int, force_multigraph=False):\n    reader = GraphMLReader(node_type, edge_key_type, force_multigraph)\n    glist = list(reader(string=graphml_string))\n    if len(glist) == 0:\n        header = '<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\">'\n        new_string = graphml_string.replace('<graphml>', header)\n        glist = list(reader(string=new_string))\n        if len(glist) == 0:\n            raise nx.NetworkXError('file not successfully read as graphml')\n    return glist[0]"
 },
 {
  "docstring": "Wrapper around the xml_type dict that raises a more informative\nexception message when a user attempts to use data of a type not\nsupported by GraphML.",
  "code": "def get_xml_type(self, key):\n    try:\n        return self.xml_type[key]\n    except KeyError as err:\n        raise TypeError(f'GraphML does not support type {key} as data values.') from err"
 },
 {
  "docstring": "Infer the attribute type of data named name. Currently this only\nsupports inference of numeric types.\n\nIf self.infer_numeric_types is false, type is used. Otherwise, pick the\nmost general of types found across all values with name and scope. This\nmeans edges with data named 'weight' are treated separately from nodes\nwith data named 'weight'.",
  "code": "def attr_type(self, name, scope, value):\n    if self.infer_numeric_types:\n        types = self.attribute_types[name, scope]\n        if len(types) > 1:\n            types = {self.get_xml_type(t) for t in types}\n            if 'string' in types:\n                return str\n            elif 'float' in types or 'double' in types:\n                return float\n            else:\n                return int\n        else:\n            return list(types)[0]\n    else:\n        return type(value)"
 },
 {
  "docstring": "Make a data element for an edge or a node. Keep a log of the\ntype in the keys table.",
  "code": "def add_data(self, name, element_type, value, scope='all', default=None):\n    if element_type not in self.xml_type:\n        raise nx.NetworkXError(f'GraphML writer does not support {element_type} as data values.')\n    keyid = self.get_key(name, self.get_xml_type(element_type), scope, default)\n    data_element = self.myElement('data', key=keyid)\n    data_element.text = str(value)\n    return data_element"
 },
 {
  "docstring": "Appends attribute data to edges or nodes, and stores type information\nto be added later. See add_graph_element.",
  "code": "def add_attributes(self, scope, xml_obj, data, default):\n    for k, v in data.items():\n        self.attribute_types[str(k), scope].add(type(v))\n        self.attributes[xml_obj].append([k, v, scope, default.get(k)])"
 },
 {
  "docstring": "Serialize graph G in GraphML to the stream.",
  "code": "def add_graph_element(self, G):\n    if G.is_directed():\n        default_edge_type = 'directed'\n    else:\n        default_edge_type = 'undirected'\n    graphid = G.graph.pop('id', None)\n    if graphid is None:\n        graph_element = self.myElement('graph', edgedefault=default_edge_type)\n    else:\n        graph_element = self.myElement('graph', edgedefault=default_edge_type, id=graphid)\n    default = {}\n    data = {k: v for k, v in G.graph.items() if k not in ['node_default', 'edge_default']}\n    self.add_attributes('graph', graph_element, data, default)\n    self.add_nodes(G, graph_element)\n    self.add_edges(G, graph_element)\n    for xml_obj, data in self.attributes.items():\n        for k, v, scope, default in data:\n            xml_obj.append(self.add_data(str(k), self.attr_type(k, scope, v), str(v), scope, default))\n    self.xml.append(graph_element)"
 },
 {
  "docstring": "Add many graphs to this GraphML document.",
  "code": "def add_graphs(self, graph_list):\n    for G in graph_list:\n        self.add_graph_element(G)"
 },
 {
  "docstring": "Serialize graph G in GraphML to the stream.",
  "code": "def add_graph_element(self, G):\n    if G.is_directed():\n        default_edge_type = 'directed'\n    else:\n        default_edge_type = 'undirected'\n    graphid = G.graph.pop('id', None)\n    if graphid is None:\n        graph_element = self._xml.element('graph', edgedefault=default_edge_type)\n    else:\n        graph_element = self._xml.element('graph', edgedefault=default_edge_type, id=graphid)\n    graphdata = {k: v for k, v in G.graph.items() if k not in ('node_default', 'edge_default')}\n    node_default = G.graph.get('node_default', {})\n    edge_default = G.graph.get('edge_default', {})\n    for k, v in graphdata.items():\n        self.attribute_types[str(k), 'graph'].add(type(v))\n    for k, v in graphdata.items():\n        element_type = self.get_xml_type(self.attr_type(k, 'graph', v))\n        self.get_key(str(k), element_type, 'graph', None)\n    for node, d in G.nodes(data=True):\n        for k, v in d.items():\n            self.attribute_types[str(k), 'node'].add(type(v))\n    for node, d in G.nodes(data=True):\n        for k, v in d.items():\n            T = self.get_xml_type(self.attr_type(k, 'node', v))\n            self.get_key(str(k), T, 'node', node_default.get(k))\n    if G.is_multigraph():\n        for u, v, ekey, d in G.edges(keys=True, data=True):\n            for k, v in d.items():\n                self.attribute_types[str(k), 'edge'].add(type(v))\n        for u, v, ekey, d in G.edges(keys=True, data=True):\n            for k, v in d.items():\n                T = self.get_xml_type(self.attr_type(k, 'edge', v))\n                self.get_key(str(k), T, 'edge', edge_default.get(k))\n    else:\n        for u, v, d in G.edges(data=True):\n            for k, v in d.items():\n                self.attribute_types[str(k), 'edge'].add(type(v))\n        for u, v, d in G.edges(data=True):\n            for k, v in d.items():\n                T = self.get_xml_type(self.attr_type(k, 'edge', v))\n                self.get_key(str(k), T, 'edge', edge_default.get(k))\n    for key in self.xml:\n        self._xml.write(key, pretty_print=self._prettyprint)\n    incremental_writer = IncrementalElement(self._xml, self._prettyprint)\n    with graph_element:\n        self.add_attributes('graph', incremental_writer, graphdata, {})\n        self.add_nodes(G, incremental_writer)\n        self.add_edges(G, incremental_writer)"
 },
 {
  "docstring": "Appends attribute data.",
  "code": "def add_attributes(self, scope, xml_obj, data, default):\n    for k, v in data.items():\n        data_element = self.add_data(str(k), self.attr_type(str(k), scope, v), str(v), scope, default.get(k))\n        xml_obj.append(data_element)"
 },
 {
  "docstring": "Add a node to the graph.",
  "code": "def add_node(self, G, node_xml, graphml_keys, defaults):\n    ports = node_xml.find(f'{{{self.NS_GRAPHML}}}port')\n    if ports is not None:\n        warnings.warn('GraphML port tag not supported.')\n    node_id = self.node_type(node_xml.get('id'))\n    data = self.decode_data_elements(graphml_keys, node_xml)\n    G.add_node(node_id, **data)\n    if node_xml.attrib.get('yfiles.foldertype') == 'group':\n        graph_xml = node_xml.find(f'{{{self.NS_GRAPHML}}}graph')\n        self.make_graph(graph_xml, graphml_keys, defaults, G)"
 },
 {
  "docstring": "Add an edge to the graph.",
  "code": "def add_edge(self, G, edge_element, graphml_keys):\n    ports = edge_element.find(f'{{{self.NS_GRAPHML}}}port')\n    if ports is not None:\n        warnings.warn('GraphML port tag not supported.')\n    directed = edge_element.get('directed')\n    if G.is_directed() and directed == 'false':\n        msg = 'directed=false edge found in directed graph.'\n        raise nx.NetworkXError(msg)\n    if not G.is_directed() and directed == 'true':\n        msg = 'directed=true edge found in undirected graph.'\n        raise nx.NetworkXError(msg)\n    source = self.node_type(edge_element.get('source'))\n    target = self.node_type(edge_element.get('target'))\n    data = self.decode_data_elements(graphml_keys, edge_element)\n    edge_id = edge_element.get('id')\n    if edge_id:\n        self.edge_ids[source, target] = edge_id\n        try:\n            edge_id = self.edge_key_type(edge_id)\n        except ValueError:\n            pass\n    else:\n        edge_id = data.get('key')\n    if G.has_edge(source, target):\n        self.multigraph = True\n    G.add_edges_from([(source, target, edge_id, data)])"
 },
 {
  "docstring": "Use the key information to decode the data XML if present.",
  "code": "def decode_data_elements(self, graphml_keys, obj_xml):\n    data = {}\n    for data_element in obj_xml.findall(f'{{{self.NS_GRAPHML}}}data'):\n        key = data_element.get('key')\n        try:\n            data_name = graphml_keys[key]['name']\n            data_type = graphml_keys[key]['type']\n        except KeyError as err:\n            raise nx.NetworkXError(f'Bad GraphML data: no key {key}') from err\n        text = data_element.text\n        if text is not None and len(list(data_element)) == 0:\n            if data_type == bool:\n                data[data_name] = self.convert_bool[text.lower()]\n            else:\n                data[data_name] = data_type(text)\n        elif len(list(data_element)) > 0:\n            node_label = None\n            gn = data_element.find(f'{{{self.NS_Y}}}GenericNode')\n            if gn:\n                data['shape_type'] = gn.get('configuration')\n            for node_type in ['GenericNode', 'ShapeNode', 'SVGNode', 'ImageNode']:\n                pref = f'{{{self.NS_Y}}}{node_type}/{{{self.NS_Y}}}'\n                geometry = data_element.find(f'{pref}Geometry')\n                if geometry is not None:\n                    data['x'] = geometry.get('x')\n                    data['y'] = geometry.get('y')\n                if node_label is None:\n                    node_label = data_element.find(f'{pref}NodeLabel')\n                shape = data_element.find(f'{pref}Shape')\n                if shape is not None:\n                    data['shape_type'] = shape.get('type')\n            if node_label is not None:\n                data['label'] = node_label.text\n            for edge_type in ['PolyLineEdge', 'SplineEdge', 'QuadCurveEdge', 'BezierEdge', 'ArcEdge']:\n                pref = f'{{{self.NS_Y}}}{edge_type}/{{{self.NS_Y}}}'\n                edge_label = data_element.find(f'{pref}EdgeLabel')\n                if edge_label is not None:\n                    break\n            if edge_label is not None:\n                data['label'] = edge_label.text\n    return data"
 },
 {
  "docstring": "Extracts all the keys and key defaults from the xml.",
  "code": "def find_graphml_keys(self, graph_element):\n    graphml_keys = {}\n    graphml_key_defaults = {}\n    for k in graph_element.findall(f'{{{self.NS_GRAPHML}}}key'):\n        attr_id = k.get('id')\n        attr_type = k.get('attr.type')\n        attr_name = k.get('attr.name')\n        yfiles_type = k.get('yfiles.type')\n        if yfiles_type is not None:\n            attr_name = yfiles_type\n            attr_type = 'yfiles'\n        if attr_type is None:\n            attr_type = 'string'\n            warnings.warn(f'No key type for id {attr_id}. Using string')\n        if attr_name is None:\n            raise nx.NetworkXError(f'Unknown key for id {attr_id}.')\n        graphml_keys[attr_id] = {'name': attr_name, 'type': self.python_type[attr_type], 'for': k.get('for')}\n        default = k.find(f'{{{self.NS_GRAPHML}}}default')\n        if default is not None:\n            python_type = graphml_keys[attr_id]['type']\n            if python_type == bool:\n                graphml_key_defaults[attr_id] = self.convert_bool[default.text.lower()]\n            else:\n                graphml_key_defaults[attr_id] = python_type(default.text)\n    return (graphml_keys, graphml_key_defaults)"
 },
 {
  "docstring": "Read graph in LEDA format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to read.  Filenames ending in .gz or .bz2  will be\n   uncompressed.\n\nReturns\n-------\nG : NetworkX graph\n\nExamples\n--------\nG=nx.read_leda('file.leda')\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_leda(path, encoding='UTF-8'):\n    lines = (line.decode(encoding) for line in path)\n    G = parse_leda(lines)\n    return G"
 },
 {
  "docstring": "Read graph in LEDA format from string or iterable.\n\nParameters\n----------\nlines : string or iterable\n   Data in LEDA format.\n\nReturns\n-------\nG : NetworkX graph\n\nExamples\n--------\nG=nx.parse_leda(string)\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef parse_leda(lines):\n    if isinstance(lines, str):\n        lines = iter(lines.split('\\n'))\n    lines = iter([line.rstrip('\\n') for line in lines if not (line.startswith(('#', '\\n')) or line == '')])\n    for i in range(3):\n        next(lines)\n    du = int(next(lines))\n    if du == -1:\n        G = nx.DiGraph()\n    else:\n        G = nx.Graph()\n    n = int(next(lines))\n    node = {}\n    for i in range(1, n + 1):\n        symbol = next(lines).rstrip().strip('|{}|  ')\n        if symbol == '':\n            symbol = str(i)\n        node[i] = symbol\n    G.add_nodes_from([s for i, s in node.items()])\n    m = int(next(lines))\n    for i in range(m):\n        try:\n            s, t, reversal, label = next(lines).split()\n        except BaseException as err:\n            raise NetworkXError(f'Too few fields in LEDA.GRAPH edge {i + 1}') from err\n        G.add_edge(node[int(s)], node[int(t)], label=label[2:-2])\n    return G"
 },
 {
  "docstring": "Generate a single line of the graph G in multiline adjacency list format.\n\nParameters\n----------\nG : NetworkX graph\n\ndelimiter : string, optional\n   Separator for node labels\n\nReturns\n-------\nlines : string\n    Lines of data in multiline adjlist format.\n\nExamples\n--------\n>>> G = nx.lollipop_graph(4, 3)\n>>> for line in nx.generate_multiline_adjlist(G):\n...     print(line)\n0 3\n1 {}\n2 {}\n3 {}\n1 2\n2 {}\n3 {}\n2 1\n3 {}\n3 1\n4 {}\n4 1\n5 {}\n5 1\n6 {}\n6 0\n\nSee Also\n--------\nwrite_multiline_adjlist, read_multiline_adjlist",
  "code": "def generate_multiline_adjlist(G, delimiter=' '):\n    if G.is_directed():\n        if G.is_multigraph():\n            for s, nbrs in G.adjacency():\n                nbr_edges = [(u, data) for u, datadict in nbrs.items() for key, data in datadict.items()]\n                deg = len(nbr_edges)\n                yield (str(s) + delimiter + str(deg))\n                for u, d in nbr_edges:\n                    if d is None:\n                        yield str(u)\n                    else:\n                        yield (str(u) + delimiter + str(d))\n        else:\n            for s, nbrs in G.adjacency():\n                deg = len(nbrs)\n                yield (str(s) + delimiter + str(deg))\n                for u, d in nbrs.items():\n                    if d is None:\n                        yield str(u)\n                    else:\n                        yield (str(u) + delimiter + str(d))\n    elif G.is_multigraph():\n        seen = set()\n        for s, nbrs in G.adjacency():\n            nbr_edges = [(u, data) for u, datadict in nbrs.items() if u not in seen for key, data in datadict.items()]\n            deg = len(nbr_edges)\n            yield (str(s) + delimiter + str(deg))\n            for u, d in nbr_edges:\n                if d is None:\n                    yield str(u)\n                else:\n                    yield (str(u) + delimiter + str(d))\n            seen.add(s)\n    else:\n        seen = set()\n        for s, nbrs in G.adjacency():\n            nbr_edges = [(u, d) for u, d in nbrs.items() if u not in seen]\n            deg = len(nbr_edges)\n            yield (str(s) + delimiter + str(deg))\n            for u, d in nbr_edges:\n                if d is None:\n                    yield str(u)\n                else:\n                    yield (str(u) + delimiter + str(d))\n            seen.add(s)"
 },
 {
  "docstring": "Write the graph G in multiline adjacency list format to path\n\nParameters\n----------\nG : NetworkX graph\n\npath : string or file\n   Filename or file handle to write to.\n   Filenames ending in .gz or .bz2 will be compressed.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels\n\nencoding : string, optional\n   Text encoding.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_multiline_adjlist(G, \"test.adjlist\")\n\nThe path can be a file handle or a string with the name of the file. If a\nfile handle is provided, it has to be opened in 'wb' mode.\n\n>>> fh = open(\"test.adjlist\", \"wb\")\n>>> nx.write_multiline_adjlist(G, fh)\n\nFilenames ending in .gz or .bz2 will be compressed.\n\n>>> nx.write_multiline_adjlist(G, \"test.adjlist.gz\")\n\nSee Also\n--------\nread_multiline_adjlist",
  "code": "@open_file(1, mode='wb')\ndef write_multiline_adjlist(G, path, delimiter=' ', comments='#', encoding='utf-8'):\n    import sys\n    import time\n    pargs = comments + ' '.join(sys.argv)\n    header = f'{pargs}\\n' + comments + f' GMT {time.asctime(time.gmtime())}\\n' + comments + f' {G.name}\\n'\n    path.write(header.encode(encoding))\n    for multiline in generate_multiline_adjlist(G, delimiter):\n        multiline += '\\n'\n        path.write(multiline.encode(encoding))"
 },
 {
  "docstring": "Parse lines of a multiline adjacency list representation of a graph.\n\nParameters\n----------\nlines : list or iterator of strings\n    Input data in multiline adjlist format\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nnodetype : Python type, optional\n   Convert nodes to this type.\n\nedgetype : Python type, optional\n   Convert edges to this type.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels.  The default is whitespace.\n\nReturns\n-------\nG: NetworkX graph\n    The graph corresponding to the lines in multiline adjacency list format.\n\nExamples\n--------\n>>> lines = [\n...     \"1 2\",\n...     \"2 {'weight':3, 'name': 'Frodo'}\",\n...     \"3 {}\",\n...     \"2 1\",\n...     \"5 {'weight':6, 'name': 'Saruman'}\",\n... ]\n>>> G = nx.parse_multiline_adjlist(iter(lines), nodetype=int)\n>>> list(G)\n[1, 2, 3, 5]",
  "code": "@nx._dispatch(graphs=None)\ndef parse_multiline_adjlist(lines, comments='#', delimiter=None, create_using=None, nodetype=None, edgetype=None):\n    from ast import literal_eval\n    G = nx.empty_graph(0, create_using)\n    for line in lines:\n        p = line.find(comments)\n        if p >= 0:\n            line = line[:p]\n        if not line:\n            continue\n        try:\n            u, deg = line.strip().split(delimiter)\n            deg = int(deg)\n        except BaseException as err:\n            raise TypeError(f'Failed to read node and degree on line ({line})') from err\n        if nodetype is not None:\n            try:\n                u = nodetype(u)\n            except BaseException as err:\n                raise TypeError(f'Failed to convert node ({u}) to type {nodetype}') from err\n        G.add_node(u)\n        for i in range(deg):\n            while True:\n                try:\n                    line = next(lines)\n                except StopIteration as err:\n                    msg = f'Failed to find neighbor for node ({u})'\n                    raise TypeError(msg) from err\n                p = line.find(comments)\n                if p >= 0:\n                    line = line[:p]\n                if line:\n                    break\n            vlist = line.strip().split(delimiter)\n            numb = len(vlist)\n            if numb < 1:\n                continue\n            v = vlist.pop(0)\n            data = ''.join(vlist)\n            if nodetype is not None:\n                try:\n                    v = nodetype(v)\n                except BaseException as err:\n                    raise TypeError(f'Failed to convert node ({v}) to type {nodetype}') from err\n            if edgetype is not None:\n                try:\n                    edgedata = {'weight': edgetype(data)}\n                except BaseException as err:\n                    raise TypeError(f'Failed to convert edge data ({data}) to type {edgetype}') from err\n            else:\n                try:\n                    edgedata = literal_eval(data)\n                except:\n                    edgedata = {}\n            G.add_edge(u, v, **edgedata)\n    return G"
 },
 {
  "docstring": "Read graph in multi-line adjacency list format from path.\n\nParameters\n----------\npath : string or file\n   Filename or file handle to read.\n   Filenames ending in .gz or .bz2 will be uncompressed.\n\ncreate_using : NetworkX graph constructor, optional (default=nx.Graph)\n   Graph type to create. If graph instance, then cleared before populated.\n\nnodetype : Python type, optional\n   Convert nodes to this type.\n\nedgetype : Python type, optional\n   Convert edge data to this type.\n\ncomments : string, optional\n   Marker for comment lines\n\ndelimiter : string, optional\n   Separator for node labels.  The default is whitespace.\n\nReturns\n-------\nG: NetworkX graph\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_multiline_adjlist(G, \"test.adjlist\")\n>>> G = nx.read_multiline_adjlist(\"test.adjlist\")\n\nThe path can be a file or a string with the name of the file. If a\nfile s provided, it has to be opened in 'rb' mode.\n\n>>> fh = open(\"test.adjlist\", \"rb\")\n>>> G = nx.read_multiline_adjlist(fh)\n\nFilenames ending in .gz or .bz2 will be compressed.\n\n>>> nx.write_multiline_adjlist(G, \"test.adjlist.gz\")\n>>> G = nx.read_multiline_adjlist(\"test.adjlist.gz\")\n\nThe optional nodetype is a function to convert node strings to nodetype.\n\nFor example\n\n>>> G = nx.read_multiline_adjlist(\"test.adjlist\", nodetype=int)\n\nwill attempt to convert all nodes to integer type.\n\nThe optional edgetype is a function to convert edge data strings to\nedgetype.\n\n>>> G = nx.read_multiline_adjlist(\"test.adjlist\")\n\nThe optional create_using parameter is a NetworkX graph container.\nThe default is Graph(), an undirected graph.  To read the data as\na directed graph use\n\n>>> G = nx.read_multiline_adjlist(\"test.adjlist\", create_using=nx.DiGraph)\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_multiline_adjlist(path, comments='#', delimiter=None, create_using=None, nodetype=None, edgetype=None, encoding='utf-8'):\n    lines = (line.decode(encoding) for line in path)\n    return parse_multiline_adjlist(lines, comments=comments, delimiter=delimiter, create_using=create_using, nodetype=nodetype, edgetype=edgetype)"
 },
 {
  "docstring": "Write NetworkX graph in p2g format.\n\n",
  "code": "@open_file(1, mode='w')\ndef write_p2g(G, path, encoding='utf-8'):\n    path.write(f'{G.name}\\n'.encode(encoding))\n    path.write(f'{G.order()} {G.size()}\\n'.encode(encoding))\n    nodes = list(G)\n    nodenumber = dict(zip(nodes, range(len(nodes))))\n    for n in nodes:\n        path.write(f'{n}\\n'.encode(encoding))\n        for nbr in G.neighbors(n):\n            path.write(f'{nodenumber[nbr]} '.encode(encoding))\n        path.write('\\n'.encode(encoding))"
 },
 {
  "docstring": "Read graph in p2g format from path.\n\nReturns\n-------\nMultiDiGraph\n\n",
  "code": "@open_file(0, mode='r')\n@nx._dispatch(graphs=None)\ndef read_p2g(path, encoding='utf-8'):\n    lines = (line.decode(encoding) for line in path)\n    G = parse_p2g(lines)\n    return G"
 },
 {
  "docstring": "Parse p2g format graph from string or iterable.\n\nReturns\n-------\nMultiDiGraph",
  "code": "@nx._dispatch(graphs=None)\ndef parse_p2g(lines):\n    description = next(lines).strip()\n    G = nx.MultiDiGraph(name=description, selfloops=True)\n    nnodes, nedges = map(int, next(lines).split())\n    nodelabel = {}\n    nbrs = {}\n    for i in range(nnodes):\n        n = next(lines).strip()\n        nodelabel[i] = n\n        G.add_node(n)\n        nbrs[n] = map(int, next(lines).split())\n    for n in G:\n        for nbr in nbrs[n]:\n            G.add_edge(n, nodelabel[nbr])\n    return G"
 },
 {
  "docstring": "Generate lines in Pajek graph format.\n\nParameters\n----------\nG : graph\n   A Networkx graph\n\n",
  "code": "def generate_pajek(G):\n    if G.name == '':\n        name = 'NetworkX'\n    else:\n        name = G.name\n    yield f'*vertices {G.order()}'\n    nodes = list(G)\n    nodenumber = dict(zip(nodes, range(1, len(nodes) + 1)))\n    for n in nodes:\n        na = G.nodes.get(n, {}).copy()\n        x = na.pop('x', 0.0)\n        y = na.pop('y', 0.0)\n        try:\n            id = int(na.pop('id', nodenumber[n]))\n        except ValueError as err:\n            err.args += (\"Pajek format requires 'id' to be an int(). Refer to the 'Relabeling nodes' section.\",)\n            raise\n        nodenumber[n] = id\n        shape = na.pop('shape', 'ellipse')\n        s = ' '.join(map(make_qstr, (id, n, x, y, shape)))\n        for k, v in na.items():\n            if isinstance(v, str) and v.strip() != '':\n                s += f' {make_qstr(k)} {make_qstr(v)}'\n            else:\n                warnings.warn(f'Node attribute {k} is not processed. {('Empty attribute' if isinstance(v, str) else 'Non-string attribute')}.')\n        yield s\n    if G.is_directed():\n        yield '*arcs'\n    else:\n        yield '*edges'\n    for u, v, edgedata in G.edges(data=True):\n        d = edgedata.copy()\n        value = d.pop('weight', 1.0)\n        s = ' '.join(map(make_qstr, (nodenumber[u], nodenumber[v], value)))\n        for k, v in d.items():\n            if isinstance(v, str) and v.strip() != '':\n                s += f' {make_qstr(k)} {make_qstr(v)}'\n            else:\n                warnings.warn(f'Edge attribute {k} is not processed. {('Empty attribute' if isinstance(v, str) else 'Non-string attribute')}.')\n        yield s"
 },
 {
  "docstring": "Write graph in Pajek format to path.\n\nParameters\n----------\nG : graph\n   A Networkx graph\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be compressed.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_pajek(G, \"test.net\")\n\nWarnings\n--------\nOptional node attributes and edge attributes must be non-empty strings.\nOtherwise it will not be written into the file. You will need to\nconvert those attributes to strings if you want to keep them.\n\n",
  "code": "@open_file(1, mode='wb')\ndef write_pajek(G, path, encoding='UTF-8'):\n    for line in generate_pajek(G):\n        line += '\\n'\n        path.write(line.encode(encoding))"
 },
 {
  "docstring": "Read graph in Pajek format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to write.\n   Filenames ending in .gz or .bz2 will be uncompressed.\n\nReturns\n-------\nG : NetworkX MultiGraph or MultiDiGraph.\n\nExamples\n--------\n>>> G = nx.path_graph(4)\n>>> nx.write_pajek(G, \"test.net\")\n>>> G = nx.read_pajek(\"test.net\")\n\nTo create a Graph instead of a MultiGraph use\n\n>>> G1 = nx.Graph(G)\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_pajek(path, encoding='UTF-8'):\n    lines = (line.decode(encoding) for line in path)\n    return parse_pajek(lines)"
 },
 {
  "docstring": "Parse Pajek format graph from string or iterable.\n\nParameters\n----------\nlines : string or iterable\n   Data in Pajek format.\n\nReturns\n-------\nG : NetworkX graph\n\nSee Also\n--------\nread_pajek",
  "code": "@nx._dispatch(graphs=None)\ndef parse_pajek(lines):\n    import shlex\n    if isinstance(lines, str):\n        lines = iter(lines.split('\\n'))\n    lines = iter([line.rstrip('\\n') for line in lines])\n    G = nx.MultiDiGraph()\n    labels = []\n    while lines:\n        try:\n            l = next(lines)\n        except:\n            break\n        if l.lower().startswith('*network'):\n            try:\n                label, name = l.split(None, 1)\n            except ValueError:\n                pass\n            else:\n                G.graph['name'] = name\n        elif l.lower().startswith('*vertices'):\n            nodelabels = {}\n            l, nnodes = l.split()\n            for i in range(int(nnodes)):\n                l = next(lines)\n                try:\n                    splitline = [x.decode('utf-8') for x in shlex.split(str(l).encode('utf-8'))]\n                except AttributeError:\n                    splitline = shlex.split(str(l))\n                id, label = splitline[0:2]\n                labels.append(label)\n                G.add_node(label)\n                nodelabels[id] = label\n                G.nodes[label]['id'] = id\n                try:\n                    x, y, shape = splitline[2:5]\n                    G.nodes[label].update({'x': float(x), 'y': float(y), 'shape': shape})\n                except:\n                    pass\n                extra_attr = zip(splitline[5::2], splitline[6::2])\n                G.nodes[label].update(extra_attr)\n        elif l.lower().startswith('*edges') or l.lower().startswith('*arcs'):\n            if l.lower().startswith('*edge'):\n                G = nx.MultiGraph(G)\n            if l.lower().startswith('*arcs'):\n                G = G.to_directed()\n            for l in lines:\n                try:\n                    splitline = [x.decode('utf-8') for x in shlex.split(str(l).encode('utf-8'))]\n                except AttributeError:\n                    splitline = shlex.split(str(l))\n                if len(splitline) < 2:\n                    continue\n                ui, vi = splitline[0:2]\n                u = nodelabels.get(ui, ui)\n                v = nodelabels.get(vi, vi)\n                edge_data = {}\n                try:\n                    w = splitline[2:3]\n                    edge_data.update({'weight': float(w[0])})\n                except:\n                    pass\n                extra_attr = zip(splitline[3::2], splitline[4::2])\n                edge_data.update(extra_attr)\n                G.add_edge(u, v, **edge_data)\n        elif l.lower().startswith('*matrix'):\n            G = nx.DiGraph(G)\n            adj_list = ((labels[row], labels[col], {'weight': int(data)}) for row, line in enumerate(lines) for col, data in enumerate(line.split()) if int(data) != 0)\n            G.add_edges_from(adj_list)\n    return G"
 },
 {
  "docstring": "Returns the string representation of t.\nAdd outer double-quotes if the string has a space.",
  "code": "def make_qstr(t):\n    if not isinstance(t, str):\n        t = str(t)\n    if ' ' in t:\n        t = f'\"{t}\"'\n    return t"
 },
 {
  "docstring": "Yield bytes in the sparse6 encoding of a graph.\n\n`G` is an undirected simple graph. `nodes` is the list of nodes for\nwhich the node-induced subgraph will be encoded; if `nodes` is the\nlist of all nodes in the graph, the entire graph will be\nencoded. `header` is a Boolean that specifies whether to generate\nthe header ``b'>>sparse6<<'`` before the remaining data.\n\nThis function generates `bytes` objects in the following order:\n\n1. the header (if requested),\n2. the encoding of the number of nodes,\n3. each character, one-at-a-time, in the encoding of the requested\n   node-induced subgraph,\n4. a newline character.\n\nThis function raises :exc:`ValueError` if the graph is too large for\nthe graph6 format (that is, greater than ``2 ** 36`` nodes).",
  "code": "def _generate_sparse6_bytes(G, nodes, header):\n    n = len(G)\n    if n >= 2 ** 36:\n        raise ValueError('sparse6 is only defined if number of nodes is less than 2 ** 36')\n    if header:\n        yield b'>>sparse6<<'\n    yield b':'\n    for d in n_to_data(n):\n        yield str.encode(chr(d + 63))\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def enc(x):\n        \"\"\"Big endian k-bit encoding of x\"\"\"\n        return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]\n    edges = sorted(((max(u, v), min(u, v)) for u, v in G.edges()))\n    bits = []\n    curv = 0\n    for v, u in edges:\n        if v == curv:\n            bits.append(0)\n            bits.extend(enc(u))\n        elif v == curv + 1:\n            curv += 1\n            bits.append(1)\n            bits.extend(enc(u))\n        else:\n            curv = v\n            bits.append(1)\n            bits.extend(enc(v))\n            bits.append(0)\n            bits.extend(enc(u))\n    if k < 6 and n == 1 << k and (-len(bits) % 6 >= k) and (curv < n - 1):\n        bits.append(0)\n        bits.extend([1] * (-len(bits) % 6))\n    else:\n        bits.extend([1] * (-len(bits) % 6))\n    data = [(bits[i + 0] << 5) + (bits[i + 1] << 4) + (bits[i + 2] << 3) + (bits[i + 3] << 2) + (bits[i + 4] << 1) + (bits[i + 5] << 0) for i in range(0, len(bits), 6)]\n    for d in data:\n        yield str.encode(chr(d + 63))\n    yield b'\\n'"
 },
 {
  "docstring": "Read an undirected graph in sparse6 format from string.\n\nParameters\n----------\nstring : string\n   Data in sparse6 format\n\nReturns\n-------\nG : Graph\n\nRaises\n------\nNetworkXError\n    If the string is unable to be parsed in sparse6 format\n\nExamples\n--------\n>>> G = nx.from_sparse6_bytes(b\":A_\")\n>>> sorted(G.edges())\n[(0, 1), (0, 1), (0, 1)]\n\nSee Also\n--------\nread_sparse6, write_sparse6\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef from_sparse6_bytes(string):\n    if string.startswith(b'>>sparse6<<'):\n        string = string[11:]\n    if not string.startswith(b':'):\n        raise NetworkXError('Expected leading colon in sparse6')\n    chars = [c - 63 for c in string[1:]]\n    n, data = data_to_n(chars)\n    k = 1\n    while 1 << k < n:\n        k += 1\n\n    def parseData():\n        \"\"\"Returns stream of pairs b[i], x[i] for sparse6 format.\"\"\"\n        chunks = iter(data)\n        d = None\n        dLen = 0\n        while 1:\n            if dLen < 1:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n            dLen -= 1\n            b = d >> dLen & 1\n            x = d & (1 << dLen) - 1\n            xLen = dLen\n            while xLen < k:\n                try:\n                    d = next(chunks)\n                except StopIteration:\n                    return\n                dLen = 6\n                x = (x << 6) + d\n                xLen += 6\n            x = x >> xLen - k\n            dLen = xLen - k\n            yield (b, x)\n    v = 0\n    G = nx.MultiGraph()\n    G.add_nodes_from(range(n))\n    multigraph = False\n    for b, x in parseData():\n        if b == 1:\n            v += 1\n        if x >= n or v >= n:\n            break\n        elif x > v:\n            v = x\n        else:\n            if G.has_edge(x, v):\n                multigraph = True\n            G.add_edge(x, v)\n    if not multigraph:\n        G = nx.Graph(G)\n    return G"
 },
 {
  "docstring": "Convert an undirected graph to bytes in sparse6 format.\n\nParameters\n----------\nG : Graph (undirected)\n\nnodes: list or iterable\n   Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n   given by ``G.nodes()`` is used.\n\nheader: bool\n   If True add '>>sparse6<<' bytes to head of data.\n\nRaises\n------\nNetworkXNotImplemented\n    If the graph is directed.\n\nValueError\n    If the graph has at least ``2 ** 36`` nodes; the sparse6 format\n    is only defined for graphs of order less than ``2 ** 36``.\n\nExamples\n--------\n>>> nx.to_sparse6_bytes(nx.path_graph(2))\nb'>>sparse6<<:An\\n'\n\nSee Also\n--------\nto_sparse6_bytes, read_sparse6, write_sparse6_bytes\n\n",
  "code": "def to_sparse6_bytes(G, nodes=None, header=True):\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    return b''.join(_generate_sparse6_bytes(G, nodes, header))"
 },
 {
  "docstring": "Read an undirected graph in sparse6 format from path.\n\nParameters\n----------\npath : file or string\n   File or filename to write.\n\nReturns\n-------\nG : Graph/Multigraph or list of Graphs/MultiGraphs\n   If the file contains multiple lines then a list of graphs is returned\n\nRaises\n------\nNetworkXError\n    If the string is unable to be parsed in sparse6 format\n\nExamples\n--------\nYou can read a sparse6 file by giving the path to the file::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n    ...     _ = f.write(b\">>sparse6<<:An\\n\")\n    ...     _ = f.seek(0)\n    ...     G = nx.read_sparse6(f.name)\n    >>> list(G.edges())\n    [(0, 1)]\n\nYou can also read a sparse6 file by giving an open file-like object::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile() as f:\n    ...     _ = f.write(b\">>sparse6<<:An\\n\")\n    ...     _ = f.seek(0)\n    ...     G = nx.read_sparse6(f)\n    >>> list(G.edges())\n    [(0, 1)]\n\nSee Also\n--------\nread_sparse6, from_sparse6_bytes\n\n",
  "code": "@open_file(0, mode='rb')\n@nx._dispatch(graphs=None)\ndef read_sparse6(path):\n    glist = []\n    for line in path:\n        line = line.strip()\n        if not len(line):\n            continue\n        glist.append(from_sparse6_bytes(line))\n    if len(glist) == 1:\n        return glist[0]\n    else:\n        return glist"
 },
 {
  "docstring": "Write graph G to given path in sparse6 format.\n\nParameters\n----------\nG : Graph (undirected)\n\npath : file or string\n   File or filename to write\n\nnodes: list or iterable\n   Nodes are labeled 0...n-1 in the order provided.  If None the ordering\n   given by G.nodes() is used.\n\nheader: bool\n   If True add '>>sparse6<<' string to head of data\n\nRaises\n------\nNetworkXError\n    If the graph is directed\n\nExamples\n--------\nYou can write a sparse6 file by giving the path to the file::\n\n    >>> import tempfile\n    >>> with tempfile.NamedTemporaryFile(delete=False) as f:\n    ...     nx.write_sparse6(nx.path_graph(2), f.name)\n    ...     print(f.read())\n    b'>>sparse6<<:An\\n'\n\nYou can also write a sparse6 file by giving an open file-like object::\n\n    >>> with tempfile.NamedTemporaryFile() as f:\n    ...     nx.write_sparse6(nx.path_graph(2), f)\n    ...     _ = f.seek(0)\n    ...     print(f.read())\n    b'>>sparse6<<:An\\n'\n\nSee Also\n--------\nread_sparse6, from_sparse6_bytes\n\n",
  "code": "@not_implemented_for('directed')\n@open_file(1, mode='wb')\ndef write_sparse6(G, path, nodes=None, header=True):\n    if nodes is not None:\n        G = G.subgraph(nodes)\n    G = nx.convert_node_labels_to_integers(G, ordering='sorted')\n    for b in _generate_sparse6_bytes(G, nodes, header):\n        path.write(b)"
 },
 {
  "docstring": "Big endian k-bit encoding of x",
  "code": "def enc(x):\n    return [1 if x & 1 << k - 1 - i else 0 for i in range(k)]"
 },
 {
  "docstring": "Returns stream of pairs b[i], x[i] for sparse6 format.",
  "code": "def parseData():\n    chunks = iter(data)\n    d = None\n    dLen = 0\n    while 1:\n        if dLen < 1:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n        dLen -= 1\n        b = d >> dLen & 1\n        x = d & (1 << dLen) - 1\n        xLen = dLen\n        while xLen < k:\n            try:\n                d = next(chunks)\n            except StopIteration:\n                return\n            dLen = 6\n            x = (x << 6) + d\n            xLen += 6\n        x = x >> xLen - k\n        dLen = xLen - k\n        yield (b, x)"
 },
 {
  "docstring": "Generate lines in the \"network text\" format\n\nThis works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented.\n\nThis notation is original to networkx, although it is simple enough that it\nmay be known in existing literature. See #5602 for details. The procedure\nis summarized as follows:\n\n1. Given a set of source nodes (which can be specified, or automatically\ndiscovered via finding the (strongly) connected components and choosing one\nnode with minimum degree from each), we traverse the graph in depth first\norder.\n\n2. Each reachable node will be printed exactly once on it's own line.\n\n3. Edges are indicated in one of four ways:\n\n    a. a parent \"L-style\" connection on the upper left. This corresponds to\n    a traversal in the directed DFS tree.\n\n    b. a backref \"<-style\" connection shown directly on the right. For\n    directed graphs, these are drawn for any incoming edges to a node that\n    is not a parent edge. For undirected graphs, these are drawn for only\n    the non-parent edges that have already been represented (The edges that\n    have not been represented will be handled in the recursive case).\n\n    c. a child \"L-style\" connection on the lower right. Drawing of the\n    children are handled recursively.\n\n    d. if ``vertical_chains`` is true, and a parent node only has one child\n    a \"vertical-style\" edge is drawn between them.\n\n4. The children of each node (wrt the directed DFS tree) are drawn\nunderneath and to the right of it. In the case that a child node has already\nbeen drawn the connection is replaced with an ellipsis (\"...\") to indicate\nthat there is one or more connections represented elsewhere.\n\n5. If a maximum depth is specified, an edge to nodes past this maximum\ndepth will be represented by an ellipsis.\n\n6. If a a node has a truthy \"collapse\" value, then we do not traverse past\nthat node.\n\nParameters\n----------\ngraph : nx.DiGraph | nx.Graph\n    Graph to represent\n\nwith_labels : bool | str\n    If True will use the \"label\" attribute of a node to display if it\n    exists otherwise it will use the node value itself. If given as a\n    string, then that attribute name will be used instead of \"label\".\n    Defaults to True.\n\nsources : List\n    Specifies which nodes to start traversal from. Note: nodes that are not\n    reachable from one of these sources may not be shown. If unspecified,\n    the minimal set of nodes needed to reach all others will be used.\n\nmax_depth : int | None\n    The maximum depth to traverse before stopping. Defaults to None.\n\nascii_only : Boolean\n    If True only ASCII characters are used to construct the visualization\n\nvertical_chains : Boolean\n    If True, chains of nodes will be drawn vertically when possible.\n\nYields\n------\nstr : a line of generated text\n\nExamples\n--------\n>>> graph = nx.path_graph(10)\n>>> graph.add_node('A')\n>>> graph.add_node('B')\n>>> graph.add_node('C')\n>>> graph.add_node('D')\n>>> graph.add_edge(9, 'A')\n>>> graph.add_edge(9, 'B')\n>>> graph.add_edge(9, 'C')\n>>> graph.add_edge('C', 'D')\n>>> graph.add_edge('C', 'E')\n>>> graph.add_edge('C', 'F')\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u2514\u2500\u2500 1\n        \u2514\u2500\u2500 2\n            \u2514\u2500\u2500 3\n                \u2514\u2500\u2500 4\n                    \u2514\u2500\u2500 5\n                        \u2514\u2500\u2500 6\n                            \u2514\u2500\u2500 7\n                                \u2514\u2500\u2500 8\n                                    \u2514\u2500\u2500 9\n                                        \u251c\u2500\u2500 A\n                                        \u251c\u2500\u2500 B\n                                        \u2514\u2500\u2500 C\n                                            \u251c\u2500\u2500 D\n                                            \u251c\u2500\u2500 E\n                                            \u2514\u2500\u2500 F\n>>> nx.write_network_text(graph, vertical_chains=True)\n\u2559\u2500\u2500 0\n    \u2502\n    1\n    \u2502\n    2\n    \u2502\n    3\n    \u2502\n    4\n    \u2502\n    5\n    \u2502\n    6\n    \u2502\n    7\n    \u2502\n    8\n    \u2502\n    9\n    \u251c\u2500\u2500 A\n    \u251c\u2500\u2500 B\n    \u2514\u2500\u2500 C\n        \u251c\u2500\u2500 D\n        \u251c\u2500\u2500 E\n        \u2514\u2500\u2500 F",
  "code": "def generate_network_text(graph, with_labels=True, sources=None, max_depth=None, ascii_only=False, vertical_chains=False):\n    from typing import Any, NamedTuple\n\n    class StackFrame(NamedTuple):\n        parent: Any\n        node: Any\n        indents: list\n        this_islast: bool\n        this_vertical: bool\n    collapse_attr = 'collapse'\n    is_directed = graph.is_directed()\n    if is_directed:\n        glyphs = AsciiDirectedGlyphs if ascii_only else UtfDirectedGlyphs\n        succ = graph.succ\n        pred = graph.pred\n    else:\n        glyphs = AsciiUndirectedGlyphs if ascii_only else UtfUndirectedGlyphs\n        succ = graph.adj\n        pred = graph.adj\n    if isinstance(with_labels, str):\n        label_attr = with_labels\n    elif with_labels:\n        label_attr = 'label'\n    else:\n        label_attr = None\n    if max_depth == 0:\n        yield (glyphs.empty + ' ...')\n    elif len(graph.nodes) == 0:\n        yield glyphs.empty\n    else:\n        if sources is None:\n            sources = _find_sources(graph)\n        last_idx = len(sources) - 1\n        stack = [StackFrame(None, node, [], idx == last_idx, False) for idx, node in enumerate(sources)][::-1]\n        num_skipped_children = defaultdict(lambda: 0)\n        seen_nodes = set()\n        while stack:\n            parent, node, indents, this_islast, this_vertical = stack.pop()\n            if node is not Ellipsis:\n                skip = node in seen_nodes\n                if skip:\n                    num_skipped_children[parent] += 1\n                if this_islast:\n                    if num_skipped_children[parent] and parent is not None:\n                        next_islast = True\n                        try_frame = StackFrame(node, Ellipsis, indents, next_islast, False)\n                        stack.append(try_frame)\n                        next_islast = False\n                        try_frame = StackFrame(parent, node, indents, next_islast, this_vertical)\n                        stack.append(try_frame)\n                        continue\n                if skip:\n                    continue\n                seen_nodes.add(node)\n            if not indents:\n                if this_islast:\n                    this_vertical = False\n                    this_prefix = indents + [glyphs.newtree_last]\n                    next_prefix = indents + [glyphs.endof_forest]\n                else:\n                    this_prefix = indents + [glyphs.newtree_mid]\n                    next_prefix = indents + [glyphs.within_forest]\n            elif this_vertical:\n                this_prefix = indents\n                next_prefix = indents\n            elif this_islast:\n                this_prefix = indents + [glyphs.last]\n                next_prefix = indents + [glyphs.endof_forest]\n            else:\n                this_prefix = indents + [glyphs.mid]\n                next_prefix = indents + [glyphs.within_tree]\n            if node is Ellipsis:\n                label = ' ...'\n                suffix = ''\n                children = []\n            else:\n                if label_attr is not None:\n                    label = str(graph.nodes[node].get(label_attr, node))\n                else:\n                    label = str(node)\n                if collapse_attr is not None:\n                    collapse = graph.nodes[node].get(collapse_attr, False)\n                else:\n                    collapse = False\n                if is_directed:\n                    children = list(succ[node])\n                    handled_parents = {parent}\n                else:\n                    children = [child for child in succ[node] if child not in seen_nodes]\n                    handled_parents = {*children, parent}\n                if max_depth is not None and len(indents) == max_depth - 1:\n                    if children:\n                        children = [Ellipsis]\n                    handled_parents = {parent}\n                if collapse:\n                    if children:\n                        children = [Ellipsis]\n                    handled_parents = {parent}\n                other_parents = [p for p in pred[node] if p not in handled_parents]\n                if other_parents:\n                    if label_attr is not None:\n                        other_parents_labels = ', '.join([str(graph.nodes[p].get(label_attr, p)) for p in other_parents])\n                    else:\n                        other_parents_labels = ', '.join([str(p) for p in other_parents])\n                    suffix = ' '.join(['', glyphs.backedge, other_parents_labels])\n                else:\n                    suffix = ''\n            if this_vertical:\n                yield ''.join(this_prefix + [glyphs.vertical_edge])\n            yield ''.join(this_prefix + [label, suffix])\n            if vertical_chains:\n                if is_directed:\n                    num_children = len(set(children))\n                else:\n                    num_children = len(set(children) - {parent})\n                next_is_vertical = num_children == 1\n            else:\n                next_is_vertical = False\n            for idx, child in enumerate(children[::-1]):\n                next_islast = idx == 0\n                try_frame = StackFrame(node, child, next_prefix, next_islast, next_is_vertical)\n                stack.append(try_frame)"
 },
 {
  "docstring": "Creates a nice text representation of a graph\n\nThis works via a depth-first traversal of the graph and writing a line for\neach unique node encountered. Non-tree edges are written to the right of\neach node, and connection to a non-tree edge is indicated with an ellipsis.\nThis representation works best when the input graph is a forest, but any\ngraph can be represented.\n\nParameters\n----------\ngraph : nx.DiGraph | nx.Graph\n    Graph to represent\n\npath : string or file or callable or None\n   Filename or file handle for data output.\n   if a function, then it will be called for each generated line.\n   if None, this will default to \"sys.stdout.write\"\n\nwith_labels : bool | str\n    If True will use the \"label\" attribute of a node to display if it\n    exists otherwise it will use the node value itself. If given as a\n    string, then that attribute name will be used instead of \"label\".\n    Defaults to True.\n\nsources : List\n    Specifies which nodes to start traversal from. Note: nodes that are not\n    reachable from one of these sources may not be shown. If unspecified,\n    the minimal set of nodes needed to reach all others will be used.\n\nmax_depth : int | None\n    The maximum depth to traverse before stopping. Defaults to None.\n\nascii_only : Boolean\n    If True only ASCII characters are used to construct the visualization\n\nend : string\n    The line ending character\n\nvertical_chains : Boolean\n    If True, chains of nodes will be drawn vertically when possible.\n\nExamples\n--------\n>>> graph = nx.balanced_tree(r=2, h=2, create_using=nx.DiGraph)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u251c\u2500\u257c 1\n    \u2502   \u251c\u2500\u257c 3\n    \u2502   \u2514\u2500\u257c 4\n    \u2514\u2500\u257c 2\n        \u251c\u2500\u257c 5\n        \u2514\u2500\u257c 6\n\n>>> # A near tree with one non-tree edge\n>>> graph.add_edge(5, 1)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u251c\u2500\u257c 1 \u257e 5\n    \u2502   \u251c\u2500\u257c 3\n    \u2502   \u2514\u2500\u257c 4\n    \u2514\u2500\u257c 2\n        \u251c\u2500\u257c 5\n        \u2502   \u2514\u2500\u257c  ...\n        \u2514\u2500\u257c 6\n\n>>> graph = nx.cycle_graph(5)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u251c\u2500\u2500 1\n    \u2502   \u2514\u2500\u2500 2\n    \u2502       \u2514\u2500\u2500 3\n    \u2502           \u2514\u2500\u2500 4 \u2500 0\n    \u2514\u2500\u2500  ...\n\n>>> graph = nx.cycle_graph(5, nx.DiGraph)\n>>> nx.write_network_text(graph, vertical_chains=True)\n\u2559\u2500\u2500 0 \u257e 4\n    \u257d\n    1\n    \u257d\n    2\n    \u257d\n    3\n    \u257d\n    4\n    \u2514\u2500\u257c  ...\n\n>>> nx.write_network_text(graph, vertical_chains=True, ascii_only=True)\n+-- 0 <- 4\n    !\n    1\n    !\n    2\n    !\n    3\n    !\n    4\n    L->  ...\n\n>>> graph = nx.generators.barbell_graph(4, 2)\n>>> nx.write_network_text(graph, vertical_chains=False)\n\u2559\u2500\u2500 4\n    \u251c\u2500\u2500 5\n    \u2502   \u2514\u2500\u2500 6\n    \u2502       \u251c\u2500\u2500 7\n    \u2502       \u2502   \u251c\u2500\u2500 8 \u2500 6\n    \u2502       \u2502   \u2502   \u2514\u2500\u2500 9 \u2500 6, 7\n    \u2502       \u2502   \u2514\u2500\u2500  ...\n    \u2502       \u2514\u2500\u2500  ...\n    \u2514\u2500\u2500 3\n        \u251c\u2500\u2500 0\n        \u2502   \u251c\u2500\u2500 1 \u2500 3\n        \u2502   \u2502   \u2514\u2500\u2500 2 \u2500 0, 3\n        \u2502   \u2514\u2500\u2500  ...\n        \u2514\u2500\u2500  ...\n>>> nx.write_network_text(graph, vertical_chains=True)\n\u2559\u2500\u2500 4\n    \u251c\u2500\u2500 5\n    \u2502   \u2502\n    \u2502   6\n    \u2502   \u251c\u2500\u2500 7\n    \u2502   \u2502   \u251c\u2500\u2500 8 \u2500 6\n    \u2502   \u2502   \u2502   \u2502\n    \u2502   \u2502   \u2502   9 \u2500 6, 7\n    \u2502   \u2502   \u2514\u2500\u2500  ...\n    \u2502   \u2514\u2500\u2500  ...\n    \u2514\u2500\u2500 3\n        \u251c\u2500\u2500 0\n        \u2502   \u251c\u2500\u2500 1 \u2500 3\n        \u2502   \u2502   \u2502\n        \u2502   \u2502   2 \u2500 0, 3\n        \u2502   \u2514\u2500\u2500  ...\n        \u2514\u2500\u2500  ...\n\n>>> graph = nx.complete_graph(5, create_using=nx.Graph)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0\n    \u251c\u2500\u2500 1\n    \u2502   \u251c\u2500\u2500 2 \u2500 0\n    \u2502   \u2502   \u251c\u2500\u2500 3 \u2500 0, 1\n    \u2502   \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 0, 1, 2\n    \u2502   \u2502   \u2514\u2500\u2500  ...\n    \u2502   \u2514\u2500\u2500  ...\n    \u2514\u2500\u2500  ...\n\n>>> graph = nx.complete_graph(3, create_using=nx.DiGraph)\n>>> nx.write_network_text(graph)\n\u2559\u2500\u2500 0 \u257e 1, 2\n    \u251c\u2500\u257c 1 \u257e 2\n    \u2502   \u251c\u2500\u257c 2 \u257e 0\n    \u2502   \u2502   \u2514\u2500\u257c  ...\n    \u2502   \u2514\u2500\u257c  ...\n    \u2514\u2500\u257c  ...",
  "code": "@open_file(1, 'w')\ndef write_network_text(graph, path=None, with_labels=True, sources=None, max_depth=None, ascii_only=False, end='\\n', vertical_chains=False):\n    if path is None:\n        _write = sys.stdout.write\n    elif hasattr(path, 'write'):\n        _write = path.write\n    elif callable(path):\n        _write = path\n    else:\n        raise TypeError(type(path))\n    for line in generate_network_text(graph, with_labels=with_labels, sources=sources, max_depth=max_depth, ascii_only=ascii_only, vertical_chains=vertical_chains):\n        _write(line + end)"
 },
 {
  "docstring": "Determine a minimal set of nodes such that the entire graph is reachable",
  "code": "def _find_sources(graph):\n    if graph.is_directed():\n        sccs = list(nx.strongly_connected_components(graph))\n        scc_graph = nx.condensation(graph, sccs)\n        supernode_to_nodes = {sn: [] for sn in scc_graph.nodes()}\n        mapping = scc_graph.graph['mapping']\n        for n in graph.nodes:\n            sn = mapping[n]\n            supernode_to_nodes[sn].append(n)\n        sources = []\n        for sn in scc_graph.nodes():\n            if scc_graph.in_degree[sn] == 0:\n                scc = supernode_to_nodes[sn]\n                node = min(scc, key=lambda n: graph.in_degree[n])\n                sources.append(node)\n    else:\n        sources = [min(cc, key=lambda n: graph.degree[n]) for cc in nx.connected_components(graph)]\n        sources = sorted(sources, key=lambda n: graph.degree[n])\n    return sources"
 },
 {
  "docstring": "Creates a nice utf8 representation of a forest\n\nThis function has been superseded by\n:func:`nx.readwrite.text.generate_network_text`, which should be used\ninstead.\n\nParameters\n----------\ngraph : nx.DiGraph | nx.Graph\n    Graph to represent (must be a tree, forest, or the empty graph)\n\nwith_labels : bool\n    If True will use the \"label\" attribute of a node to display if it\n    exists otherwise it will use the node value itself. Defaults to True.\n\nsources : List\n    Mainly relevant for undirected forests, specifies which nodes to list\n    first. If unspecified the root nodes of each tree will be used for\n    directed forests; for undirected forests this defaults to the nodes\n    with the smallest degree.\n\nwrite : callable\n    Function to use to write to, if None new lines are appended to\n    a list and returned. If set to the `print` function, lines will\n    be written to stdout as they are generated. If specified,\n    this function will return None. Defaults to None.\n\nascii_only : Boolean\n    If True only ASCII characters are used to construct the visualization\n\nReturns\n-------\nstr | None :\n    utf8 representation of the tree / forest\n\nExamples\n--------\n>>> graph = nx.balanced_tree(r=2, h=3, create_using=nx.DiGraph)\n>>> print(nx.forest_str(graph))\n\u2559\u2500\u2500 0\n    \u251c\u2500\u257c 1\n    \u2502   \u251c\u2500\u257c 3\n    \u2502   \u2502   \u251c\u2500\u257c 7\n    \u2502   \u2502   \u2514\u2500\u257c 8\n    \u2502   \u2514\u2500\u257c 4\n    \u2502       \u251c\u2500\u257c 9\n    \u2502       \u2514\u2500\u257c 10\n    \u2514\u2500\u257c 2\n        \u251c\u2500\u257c 5\n        \u2502   \u251c\u2500\u257c 11\n        \u2502   \u2514\u2500\u257c 12\n        \u2514\u2500\u257c 6\n            \u251c\u2500\u257c 13\n            \u2514\u2500\u257c 14\n\n\n>>> graph = nx.balanced_tree(r=1, h=2, create_using=nx.Graph)\n>>> print(nx.forest_str(graph))\n\u2559\u2500\u2500 0\n    \u2514\u2500\u2500 1\n        \u2514\u2500\u2500 2\n\n>>> print(nx.forest_str(graph, ascii_only=True))\n+-- 0\n    L-- 1\n        L-- 2",
  "code": "def forest_str(graph, with_labels=True, sources=None, write=None, ascii_only=False):\n    msg = '\\nforest_str is deprecated as of version 3.1 and will be removed in version 3.3. Use generate_network_text or write_network_text instead.\\n'\n    warnings.warn(msg, DeprecationWarning)\n    if len(graph.nodes) > 0:\n        if not nx.is_forest(graph):\n            raise nx.NetworkXNotImplemented('input must be a forest or the empty graph')\n    printbuf = []\n    if write is None:\n        _write = printbuf.append\n    else:\n        _write = write\n    write_network_text(graph, _write, with_labels=with_labels, sources=sources, ascii_only=ascii_only, end='')\n    if write is None:\n        return '\\n'.join(printbuf)"
 },
 {
  "docstring": "Reconstructs a graph from a network text representation.\n\nThis is mainly used for testing.  Network text is for display, not\nserialization, as such this cannot parse all network text representations\nbecause node labels can be ambiguous with the glyphs and indentation used\nto represent edge structure. Additionally, there is no way to determine if\ndisconnected graphs were originally directed or undirected.\n\nParameters\n----------\nlines : list or iterator of strings\n    Input data in network text format\n\nReturns\n-------\nG: NetworkX graph\n    The graph corresponding to the lines in network text format.",
  "code": "def _parse_network_text(lines):\n    from itertools import chain\n    from typing import Any, NamedTuple, Union\n\n    class ParseStackFrame(NamedTuple):\n        node: Any\n        indent: int\n        has_vertical_child: int | None\n    initial_line_iter = iter(lines)\n    is_ascii = None\n    is_directed = None\n    initial_lines = []\n    try:\n        first_line = next(initial_line_iter)\n    except StopIteration:\n        ...\n    else:\n        initial_lines.append(first_line)\n        first_char = first_line[0]\n        if first_char in {UtfBaseGlyphs.empty, UtfBaseGlyphs.newtree_mid[0], UtfBaseGlyphs.newtree_last[0]}:\n            is_ascii = False\n        elif first_char in {AsciiBaseGlyphs.empty, AsciiBaseGlyphs.newtree_mid[0], AsciiBaseGlyphs.newtree_last[0]}:\n            is_ascii = True\n        else:\n            raise AssertionError(f'Unexpected first character: {first_char}')\n    if is_ascii:\n        directed_glyphs = AsciiDirectedGlyphs.as_dict()\n        undirected_glyphs = AsciiUndirectedGlyphs.as_dict()\n    else:\n        directed_glyphs = UtfDirectedGlyphs.as_dict()\n        undirected_glyphs = UtfUndirectedGlyphs.as_dict()\n    directed_items = set(directed_glyphs.values())\n    undirected_items = set(undirected_glyphs.values())\n    unambiguous_directed_items = []\n    for item in directed_items:\n        other_items = undirected_items\n        other_supersets = [other for other in other_items if item in other]\n        if not other_supersets:\n            unambiguous_directed_items.append(item)\n    unambiguous_undirected_items = []\n    for item in undirected_items:\n        other_items = directed_items\n        other_supersets = [other for other in other_items if item in other]\n        if not other_supersets:\n            unambiguous_undirected_items.append(item)\n    for line in initial_line_iter:\n        initial_lines.append(line)\n        if any((item in line for item in unambiguous_undirected_items)):\n            is_directed = False\n            break\n        elif any((item in line for item in unambiguous_directed_items)):\n            is_directed = True\n            break\n    if is_directed is None:\n        is_directed = False\n    glyphs = directed_glyphs if is_directed else undirected_glyphs\n    backedge_symbol = ' ' + glyphs['backedge'] + ' '\n    parsing_line_iter = chain(initial_lines, initial_line_iter)\n    edges = []\n    nodes = []\n    is_empty = None\n    noparent = object()\n    stack = [ParseStackFrame(noparent, -1, None)]\n    for line in parsing_line_iter:\n        if line == glyphs['empty']:\n            is_empty = True\n            continue\n        if backedge_symbol in line:\n            node_part, backedge_part = line.split(backedge_symbol)\n            backedge_nodes = [u.strip() for u in backedge_part.split(', ')]\n            node_part = node_part.rstrip()\n            prefix, node = node_part.rsplit(' ', 1)\n            node = node.strip()\n            edges.extend([(u, node) for u in backedge_nodes])\n        else:\n            prefix, node = line.rsplit(' ', 1)\n            node = node.strip()\n        prev = stack.pop()\n        if node in glyphs['vertical_edge']:\n            modified_prev = ParseStackFrame(prev.node, prev.indent, True)\n            stack.append(modified_prev)\n            continue\n        indent = len(prefix)\n        curr = ParseStackFrame(node, indent, None)\n        if prev.has_vertical_child:\n            ...\n        else:\n            while curr.indent <= prev.indent:\n                prev = stack.pop()\n        if node == '...':\n            stack.append(prev)\n        else:\n            stack.append(prev)\n            stack.append(curr)\n            nodes.append(curr.node)\n            if prev.node is not noparent:\n                edges.append((prev.node, curr.node))\n    if is_empty:\n        assert len(nodes) == 0\n    cls = nx.DiGraph if is_directed else nx.Graph\n    new = cls()\n    new.add_nodes_from(nodes)\n    new.add_edges_from(edges)\n    return new"
 },
 {
  "docstring": "Returns data in adjacency format that is suitable for JSON serialization\nand use in JavaScript documents.\n\nParameters\n----------\nG : NetworkX graph\n\nattrs : dict\n    A dictionary that contains two keys 'id' and 'key'. The corresponding\n    values provide the attribute names for storing NetworkX-internal graph\n    data. The values should be unique. Default value:\n    :samp:`dict(id='id', key='key')`.\n\n    If some user-defined graph data use these attribute names as data keys,\n    they may be silently dropped.\n\nReturns\n-------\ndata : dict\n   A dictionary with adjacency formatted data.\n\nRaises\n------\nNetworkXError\n    If values in attrs are not unique.\n\nExamples\n--------\n>>> from networkx.readwrite import json_graph\n>>> G = nx.Graph([(1, 2)])\n>>> data = json_graph.adjacency_data(G)\n\nTo serialize with json\n\n>>> import json\n>>> s = json.dumps(data)\n\n",
  "code": "def adjacency_data(G, attrs=_attrs):\n    multigraph = G.is_multigraph()\n    id_ = attrs['id']\n    key = None if not multigraph else attrs['key']\n    if id_ == key:\n        raise nx.NetworkXError('Attribute names are not unique.')\n    data = {}\n    data['directed'] = G.is_directed()\n    data['multigraph'] = multigraph\n    data['graph'] = list(G.graph.items())\n    data['nodes'] = []\n    data['adjacency'] = []\n    for n, nbrdict in G.adjacency():\n        data['nodes'].append({**G.nodes[n], id_: n})\n        adj = []\n        if multigraph:\n            for nbr, keys in nbrdict.items():\n                for k, d in keys.items():\n                    adj.append({**d, id_: nbr, key: k})\n        else:\n            for nbr, d in nbrdict.items():\n                adj.append({**d, id_: nbr})\n        data['adjacency'].append(adj)\n    return data"
 },
 {
  "docstring": "Returns graph from adjacency data format.\n\nParameters\n----------\ndata : dict\n    Adjacency list formatted graph data\n\ndirected : bool\n    If True, and direction not specified in data, return a directed graph.\n\nmultigraph : bool\n    If True, and multigraph not specified in data, return a multigraph.\n\nattrs : dict\n    A dictionary that contains two keys 'id' and 'key'. The corresponding\n    values provide the attribute names for storing NetworkX-internal graph\n    data. The values should be unique. Default value:\n    :samp:`dict(id='id', key='key')`.\n\nReturns\n-------\nG : NetworkX graph\n   A NetworkX graph object\n\nExamples\n--------\n>>> from networkx.readwrite import json_graph\n>>> G = nx.Graph([(1, 2)])\n>>> data = json_graph.adjacency_data(G)\n>>> H = json_graph.adjacency_graph(data)\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef adjacency_graph(data, directed=False, multigraph=True, attrs=_attrs):\n    multigraph = data.get('multigraph', multigraph)\n    directed = data.get('directed', directed)\n    if multigraph:\n        graph = nx.MultiGraph()\n    else:\n        graph = nx.Graph()\n    if directed:\n        graph = graph.to_directed()\n    id_ = attrs['id']\n    key = None if not multigraph else attrs['key']\n    graph.graph = dict(data.get('graph', []))\n    mapping = []\n    for d in data['nodes']:\n        node_data = d.copy()\n        node = node_data.pop(id_)\n        mapping.append(node)\n        graph.add_node(node)\n        graph.nodes[node].update(node_data)\n    for i, d in enumerate(data['adjacency']):\n        source = mapping[i]\n        for tdata in d:\n            target_data = tdata.copy()\n            target = target_data.pop(id_)\n            if not multigraph:\n                graph.add_edge(source, target)\n                graph[source][target].update(target_data)\n            else:\n                ky = target_data.pop(key, None)\n                graph.add_edge(source, target, key=ky)\n                graph[source][target][ky].update(target_data)\n    return graph"
 },
 {
  "docstring": "Returns data in Cytoscape JSON format (cyjs).\n\nParameters\n----------\nG : NetworkX Graph\n    The graph to convert to cytoscape format\nname : string\n    A string which is mapped to the 'name' node element in cyjs format.\n    Must not have the same value as `ident`.\nident : string\n    A string which is mapped to the 'id' node element in cyjs format.\n    Must not have the same value as `name`.\n\nReturns\n-------\ndata: dict\n    A dictionary with cyjs formatted data.\n\nRaises\n------\nNetworkXError\n    If the values for `name` and `ident` are identical.\n\nSee Also\n--------\ncytoscape_graph: convert a dictionary in cyjs format to a graph\n\n",
  "code": "def cytoscape_data(G, name='name', ident='id'):\n    if name == ident:\n        raise nx.NetworkXError('name and ident must be different.')\n    jsondata = {'data': list(G.graph.items())}\n    jsondata['directed'] = G.is_directed()\n    jsondata['multigraph'] = G.is_multigraph()\n    jsondata['elements'] = {'nodes': [], 'edges': []}\n    nodes = jsondata['elements']['nodes']\n    edges = jsondata['elements']['edges']\n    for i, j in G.nodes.items():\n        n = {'data': j.copy()}\n        n['data']['id'] = j.get(ident) or str(i)\n        n['data']['value'] = i\n        n['data']['name'] = j.get(name) or str(i)\n        nodes.append(n)\n    if G.is_multigraph():\n        for e in G.edges(keys=True):\n            n = {'data': G.adj[e[0]][e[1]][e[2]].copy()}\n            n['data']['source'] = e[0]\n            n['data']['target'] = e[1]\n            n['data']['key'] = e[2]\n            edges.append(n)\n    else:\n        for e in G.edges():\n            n = {'data': G.adj[e[0]][e[1]].copy()}\n            n['data']['source'] = e[0]\n            n['data']['target'] = e[1]\n            edges.append(n)\n    return jsondata"
 },
 {
  "docstring": "Create a NetworkX graph from a dictionary in cytoscape JSON format.\n\nParameters\n----------\ndata : dict\n    A dictionary of data conforming to cytoscape JSON format.\nname : string\n    A string which is mapped to the 'name' node element in cyjs format.\n    Must not have the same value as `ident`.\nident : string\n    A string which is mapped to the 'id' node element in cyjs format.\n    Must not have the same value as `name`.\n\nReturns\n-------\ngraph : a NetworkX graph instance\n    The `graph` can be an instance of `Graph`, `DiGraph`, `MultiGraph`, or\n    `MultiDiGraph` depending on the input data.\n\nRaises\n------\nNetworkXError\n    If the `name` and `ident` attributes are identical.\n\nSee Also\n--------\ncytoscape_data: convert a NetworkX graph to a dict in cyjs format\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef cytoscape_graph(data, name='name', ident='id'):\n    if name == ident:\n        raise nx.NetworkXError('name and ident must be different.')\n    multigraph = data.get('multigraph')\n    directed = data.get('directed')\n    if multigraph:\n        graph = nx.MultiGraph()\n    else:\n        graph = nx.Graph()\n    if directed:\n        graph = graph.to_directed()\n    graph.graph = dict(data.get('data'))\n    for d in data['elements']['nodes']:\n        node_data = d['data'].copy()\n        node = d['data']['value']\n        if d['data'].get(name):\n            node_data[name] = d['data'].get(name)\n        if d['data'].get(ident):\n            node_data[ident] = d['data'].get(ident)\n        graph.add_node(node)\n        graph.nodes[node].update(node_data)\n    for d in data['elements']['edges']:\n        edge_data = d['data'].copy()\n        sour = d['data']['source']\n        targ = d['data']['target']\n        if multigraph:\n            key = d['data'].get('key', 0)\n            graph.add_edge(sour, targ, key=key)\n            graph.edges[sour, targ, key].update(edge_data)\n        else:\n            graph.add_edge(sour, targ)\n            graph.edges[sour, targ].update(edge_data)\n    return graph"
 },
 {
  "docstring": "Converts lists to tuples, including nested lists.\n\nAll other non-list inputs are passed through unmodified. This function is\nintended to be used to convert potentially nested lists from json files\ninto valid nodes.\n\nExamples\n--------\n>>> _to_tuple([1, 2, [3, 4]])\n(1, 2, (3, 4))",
  "code": "def _to_tuple(x):\n    if not isinstance(x, tuple | list):\n        return x\n    return tuple(map(_to_tuple, x))"
 },
 {
  "docstring": "Returns data in node-link format that is suitable for JSON serialization\nand use in JavaScript documents.\n\nParameters\n----------\nG : NetworkX graph\nsource : string\n    A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\ntarget : string\n    A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\nname : string\n    A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\nkey : string\n    A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\nlink : string\n    A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\n\nReturns\n-------\ndata : dict\n   A dictionary with node-link formatted data.\n\nRaises\n------\nNetworkXError\n    If the values of 'source', 'target' and 'key' are not unique.\n\nExamples\n--------\n>>> G = nx.Graph([(\"A\", \"B\")])\n>>> data1 = nx.node_link_data(G)\n>>> data1\n{'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\n\nTo serialize with JSON\n\n>>> import json\n>>> s1 = json.dumps(data1)\n>>> s1\n'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\n\nA graph can also be serialized by passing `node_link_data` as an encoder function. The two methods are equivalent.\n\n>>> s1 = json.dumps(G, default=nx.node_link_data)\n>>> s1\n'{\"directed\": false, \"multigraph\": false, \"graph\": {}, \"nodes\": [{\"id\": \"A\"}, {\"id\": \"B\"}], \"links\": [{\"source\": \"A\", \"target\": \"B\"}]}'\n\nThe attribute names for storing NetworkX-internal graph data can\nbe specified as keyword options.\n\n>>> H = nx.gn_graph(2)\n>>> data2 = nx.node_link_data(H, link=\"edges\", source=\"from\", target=\"to\")\n>>> data2\n{'directed': True, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 0}, {'id': 1}], 'edges': [{'from': 1, 'to': 0}]}\n\n",
  "code": "def node_link_data(G, *, source='source', target='target', name='id', key='key', link='links'):\n    multigraph = G.is_multigraph()\n    key = None if not multigraph else key\n    if len({source, target, key}) < 3:\n        raise nx.NetworkXError('Attribute names are not unique.')\n    data = {'directed': G.is_directed(), 'multigraph': multigraph, 'graph': G.graph, 'nodes': [{**G.nodes[n], name: n} for n in G]}\n    if multigraph:\n        data[link] = [{**d, source: u, target: v, key: k} for u, v, k, d in G.edges(keys=True, data=True)]\n    else:\n        data[link] = [{**d, source: u, target: v} for u, v, d in G.edges(data=True)]\n    return data"
 },
 {
  "docstring": "Returns graph from node-link data format.\nUseful for de-serialization from JSON.\n\nParameters\n----------\ndata : dict\n    node-link formatted graph data\n\ndirected : bool\n    If True, and direction not specified in data, return a directed graph.\n\nmultigraph : bool\n    If True, and multigraph not specified in data, return a multigraph.\n\nsource : string\n    A string that provides the 'source' attribute name for storing NetworkX-internal graph data.\ntarget : string\n    A string that provides the 'target' attribute name for storing NetworkX-internal graph data.\nname : string\n    A string that provides the 'name' attribute name for storing NetworkX-internal graph data.\nkey : string\n    A string that provides the 'key' attribute name for storing NetworkX-internal graph data.\nlink : string\n    A string that provides the 'link' attribute name for storing NetworkX-internal graph data.\n\nReturns\n-------\nG : NetworkX graph\n    A NetworkX graph object\n\nExamples\n--------\n\nCreate data in node-link format by converting a graph.\n\n>>> G = nx.Graph([('A', 'B')])\n>>> data = nx.node_link_data(G)\n>>> data\n{'directed': False, 'multigraph': False, 'graph': {}, 'nodes': [{'id': 'A'}, {'id': 'B'}], 'links': [{'source': 'A', 'target': 'B'}]}\n\nRevert data in node-link format to a graph.\n\n>>> H = nx.node_link_graph(data)\n>>> print(H.edges)\n[('A', 'B')]\n\nTo serialize and deserialize a graph with JSON,\n\n>>> import json\n>>> d = json.dumps(node_link_data(G))\n>>> H = node_link_graph(json.loads(d))\n>>> print(G.edges, H.edges)\n[('A', 'B')] [('A', 'B')]\n\n\n",
  "code": "@nx._dispatch(graphs=None)\ndef node_link_graph(data, directed=False, multigraph=True, *, source='source', target='target', name='id', key='key', link='links'):\n    multigraph = data.get('multigraph', multigraph)\n    directed = data.get('directed', directed)\n    if multigraph:\n        graph = nx.MultiGraph()\n    else:\n        graph = nx.Graph()\n    if directed:\n        graph = graph.to_directed()\n    key = None if not multigraph else key\n    graph.graph = data.get('graph', {})\n    c = count()\n    for d in data['nodes']:\n        node = _to_tuple(d.get(name, next(c)))\n        nodedata = {str(k): v for k, v in d.items() if k != name}\n        graph.add_node(node, **nodedata)\n    for d in data[link]:\n        src = tuple(d[source]) if isinstance(d[source], list) else d[source]\n        tgt = tuple(d[target]) if isinstance(d[target], list) else d[target]\n        if not multigraph:\n            edgedata = {str(k): v for k, v in d.items() if k != source and k != target}\n            graph.add_edge(src, tgt, **edgedata)\n        else:\n            ky = d.get(key, None)\n            edgedata = {str(k): v for k, v in d.items() if k != source and k != target and (k != key)}\n            graph.add_edge(src, tgt, ky, **edgedata)\n    return graph"
 },
 {
  "docstring": "Returns data in tree format that is suitable for JSON serialization\nand use in JavaScript documents.\n\nParameters\n----------\nG : NetworkX graph\n   G must be an oriented tree\n\nroot : node\n   The root of the tree\n\nident : string\n    Attribute name for storing NetworkX-internal graph data. `ident` must\n    have a different value than `children`. The default is 'id'.\n\nchildren : string\n    Attribute name for storing NetworkX-internal graph data. `children`\n    must have a different value than `ident`. The default is 'children'.\n\nReturns\n-------\ndata : dict\n   A dictionary with node-link formatted data.\n\nRaises\n------\nNetworkXError\n    If `children` and `ident` attributes are identical.\n\nExamples\n--------\n>>> from networkx.readwrite import json_graph\n>>> G = nx.DiGraph([(1, 2)])\n>>> data = json_graph.tree_data(G, root=1)\n\nTo serialize with json\n\n>>> import json\n>>> s = json.dumps(data)\n\n",
  "code": "def tree_data(G, root, ident='id', children='children'):\n    if G.number_of_nodes() != G.number_of_edges() + 1:\n        raise TypeError('G is not a tree.')\n    if not G.is_directed():\n        raise TypeError('G is not directed.')\n    if not nx.is_weakly_connected(G):\n        raise TypeError('G is not weakly connected.')\n    if ident == children:\n        raise nx.NetworkXError('The values for `id` and `children` must be different.')\n\n    def add_children(n, G):\n        nbrs = G[n]\n        if len(nbrs) == 0:\n            return []\n        children_ = []\n        for child in nbrs:\n            d = {**G.nodes[child], ident: child}\n            c = add_children(child, G)\n            if c:\n                d[children] = c\n            children_.append(d)\n        return children_\n    return {**G.nodes[root], ident: root, children: add_children(root, G)}"
 },
 {
  "docstring": "Returns graph from tree data format.\n\nParameters\n----------\ndata : dict\n    Tree formatted graph data\n\nident : string\n    Attribute name for storing NetworkX-internal graph data. `ident` must\n    have a different value than `children`. The default is 'id'.\n\nchildren : string\n    Attribute name for storing NetworkX-internal graph data. `children`\n    must have a different value than `ident`. The default is 'children'.\n\nReturns\n-------\nG : NetworkX DiGraph\n\nExamples\n--------\n>>> from networkx.readwrite import json_graph\n>>> G = nx.DiGraph([(1, 2)])\n>>> data = json_graph.tree_data(G, root=1)\n>>> H = json_graph.tree_graph(data)\n\nSee Also\n--------\ntree_data, node_link_data, adjacency_data",
  "code": "@nx._dispatch(graphs=None)\ndef tree_graph(data, ident='id', children='children'):\n    graph = nx.DiGraph()\n\n    def add_children(parent, children_):\n        for data in children_:\n            child = data[ident]\n            graph.add_edge(parent, child)\n            grandchildren = data.get(children, [])\n            if grandchildren:\n                add_children(child, grandchildren)\n            nodedata = {str(k): v for k, v in data.items() if k != ident and k != children}\n            graph.add_node(child, **nodedata)\n    root = data[ident]\n    children_ = data.get(children, [])\n    nodedata = {str(k): v for k, v in data.items() if k != ident and k != children}\n    graph.add_node(root, **nodedata)\n    add_children(root, children_)\n    return graph"
 },
 {
  "docstring": "Test for reading many graphs from a file into a list.",
  "code": "def test_read_many_graph6(self):\n    data = b'DF{\\nD`{\\nDqK\\nD~{\\n'\n    fh = BytesIO(data)\n    glist = nx.read_graph6(fh)\n    assert len(glist) == 4\n    for G in glist:\n        assert sorted(G) == list(range(5))"
 },
 {
  "docstring": "Test that a detailed exception is raised when an attribute is of a type\nnot supported by GraphML, e.g. a list",
  "code": "def test_exception_for_unsupported_datatype_node_attr():\n    pytest.importorskip('lxml.etree')\n    G = nx.Graph()\n    G.add_node(0, my_list_attribute=[0, 1, 2])\n    fh = io.BytesIO()\n    with pytest.raises(TypeError, match='GraphML does not support'):\n        nx.write_graphml(G, fh)"
 },
 {
  "docstring": "Test that a detailed exception is raised when an attribute is of a type\nnot supported by GraphML, e.g. a list",
  "code": "def test_exception_for_unsupported_datatype_edge_attr():\n    pytest.importorskip('lxml.etree')\n    G = nx.Graph()\n    G.add_edge(0, 1, my_list_attribute=[0, 1, 2])\n    fh = io.BytesIO()\n    with pytest.raises(TypeError, match='GraphML does not support'):\n        nx.write_graphml(G, fh)"
 },
 {
  "docstring": "Test that a detailed exception is raised when an attribute is of a type\nnot supported by GraphML, e.g. a list",
  "code": "def test_exception_for_unsupported_datatype_graph_attr():\n    pytest.importorskip('lxml.etree')\n    G = nx.Graph()\n    G.graph['my_list_attribute'] = [0, 1, 2]\n    fh = io.BytesIO()\n    with pytest.raises(TypeError, match='GraphML does not support'):\n        nx.write_graphml(G, fh)"
 },
 {
  "docstring": "Test that data and keys of edges are preserved on consequent\nwrite and reads",
  "code": "def test_preserve_multi_edge_data(self):\n    G = nx.MultiGraph()\n    G.add_node(1)\n    G.add_node(2)\n    G.add_edges_from([(1, 2), (1, 2, {'key': 'data_key1'}), (1, 2, {'id': 'data_id2'}), (1, 2, {'key': 'data_key3', 'id': 'data_id3'}), (1, 2, 103, {'key': 'data_key4'}), (1, 2, 104, {'id': 'data_id5'}), (1, 2, 105, {'key': 'data_key6', 'id': 'data_id7'})])\n    fh = io.BytesIO()\n    nx.write_graphml(G, fh)\n    fh.seek(0)\n    H = nx.read_graphml(fh, node_type=int)\n    assert edges_equal(G.edges(data=True, keys=True), H.edges(data=True, keys=True))\n    assert G._adj == H._adj\n    Gadj = {str(node): {str(nbr): {str(ekey): dd for ekey, dd in key_dict.items()} for nbr, key_dict in nbr_dict.items()} for node, nbr_dict in G._adj.items()}\n    fh.seek(0)\n    HH = nx.read_graphml(fh, node_type=str, edge_key_type=str)\n    assert Gadj == HH._adj\n    fh.seek(0)\n    string_fh = fh.read()\n    HH = nx.parse_graphml(string_fh, node_type=str, edge_key_type=str)\n    assert Gadj == HH._adj"
 },
 {
  "docstring": "Writing keys as edge id attributes means keys become strings.\nThe original keys are stored as data, so read them back in\nif `str(key) == edge_id`\nThis allows the adjacency to remain the same.",
  "code": "def test_more_multigraph_keys(self):\n    G = nx.MultiGraph()\n    G.add_edges_from([('a', 'b', 2), ('a', 'b', 3)])\n    fd, fname = tempfile.mkstemp()\n    self.writer(G, fname)\n    H = nx.read_graphml(fname)\n    assert H.is_multigraph()\n    assert edges_equal(G.edges(keys=True), H.edges(keys=True))\n    assert G._adj == H._adj\n    os.close(fd)\n    os.unlink(fname)"
 },
 {
  "docstring": "When sources are directly specified, we won't be able to determine when we\nare in the last component, so there will always be a trailing, leftmost\npipe.",
  "code": "def test_forest_str_overspecified_sources():\n    graph = nx.disjoint_union_all([nx.balanced_tree(r=2, h=1, create_using=nx.DiGraph), nx.balanced_tree(r=1, h=2, create_using=nx.DiGraph), nx.balanced_tree(r=2, h=1, create_using=nx.DiGraph)])\n    target1 = dedent('\\n        \u255f\u2500\u2500 0\\n        \u254e   \u251c\u2500\u257c 1\\n        \u254e   \u2514\u2500\u257c 2\\n        \u255f\u2500\u2500 3\\n        \u254e   \u2514\u2500\u257c 4\\n        \u254e       \u2514\u2500\u257c 5\\n        \u255f\u2500\u2500 6\\n        \u254e   \u251c\u2500\u257c 7\\n        \u254e   \u2514\u2500\u257c 8\\n        ').strip()\n    target2 = dedent('\\n        \u255f\u2500\u2500 0\\n        \u254e   \u251c\u2500\u257c 1\\n        \u254e   \u2514\u2500\u257c 2\\n        \u255f\u2500\u2500 3\\n        \u254e   \u2514\u2500\u257c 4\\n        \u254e       \u2514\u2500\u257c 5\\n        \u2559\u2500\u2500 6\\n            \u251c\u2500\u257c 7\\n            \u2514\u2500\u257c 8\\n        ').strip()\n    lines = []\n    nx.forest_str(graph, write=lines.append, sources=graph.nodes)\n    got1 = '\\n'.join(lines)\n    print('got1: ')\n    print(got1)\n    lines = []\n    nx.forest_str(graph, write=lines.append)\n    got2 = '\\n'.join(lines)\n    print('got2: ')\n    print(got2)\n    assert got1 == target1\n    assert got2 == target2"
 },
 {
  "docstring": "Walk through the cases going from a disconnected to fully connected graph",
  "code": "def test_write_network_text_iterative_add_directed_edges():\n    graph = nx.DiGraph()\n    graph.add_nodes_from([1, 2, 3, 4])\n    lines = []\n    write = lines.append\n    write('--- initial state ---')\n    nx.write_network_text(graph, path=write, end='')\n    for i, j in product(graph.nodes, graph.nodes):\n        write(f'--- add_edge({i}, {j}) ---')\n        graph.add_edge(i, j)\n        nx.write_network_text(graph, path=write, end='')\n    text = '\\n'.join(lines)\n    print(text)\n    target = dedent('\\n        --- initial state ---\\n        \u255f\u2500\u2500 1\\n        \u255f\u2500\u2500 2\\n        \u255f\u2500\u2500 3\\n        \u2559\u2500\u2500 4\\n        --- add_edge(1, 1) ---\\n        \u255f\u2500\u2500 1 \u257e 1\\n        \u254e   \u2514\u2500\u257c  ...\\n        \u255f\u2500\u2500 2\\n        \u255f\u2500\u2500 3\\n        \u2559\u2500\u2500 4\\n        --- add_edge(1, 2) ---\\n        \u255f\u2500\u2500 1 \u257e 1\\n        \u254e   \u251c\u2500\u257c 2\\n        \u254e   \u2514\u2500\u257c  ...\\n        \u255f\u2500\u2500 3\\n        \u2559\u2500\u2500 4\\n        --- add_edge(1, 3) ---\\n        \u255f\u2500\u2500 1 \u257e 1\\n        \u254e   \u251c\u2500\u257c 2\\n        \u254e   \u251c\u2500\u257c 3\\n        \u254e   \u2514\u2500\u257c  ...\\n        \u2559\u2500\u2500 4\\n        --- add_edge(1, 4) ---\\n        \u2559\u2500\u2500 1 \u257e 1\\n            \u251c\u2500\u257c 2\\n            \u251c\u2500\u257c 3\\n            \u251c\u2500\u257c 4\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(2, 1) ---\\n        \u2559\u2500\u2500 2 \u257e 1\\n            \u2514\u2500\u257c 1 \u257e 1\\n                \u251c\u2500\u257c 3\\n                \u251c\u2500\u257c 4\\n                \u2514\u2500\u257c  ...\\n        --- add_edge(2, 2) ---\\n        \u2559\u2500\u2500 1 \u257e 1, 2\\n            \u251c\u2500\u257c 2 \u257e 2\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u251c\u2500\u257c 3\\n            \u251c\u2500\u257c 4\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(2, 3) ---\\n        \u2559\u2500\u2500 1 \u257e 1, 2\\n            \u251c\u2500\u257c 2 \u257e 2\\n            \u2502   \u251c\u2500\u257c 3 \u257e 1\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u251c\u2500\u257c 4\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(2, 4) ---\\n        \u2559\u2500\u2500 1 \u257e 1, 2\\n            \u251c\u2500\u257c 2 \u257e 2\\n            \u2502   \u251c\u2500\u257c 3 \u257e 1\\n            \u2502   \u251c\u2500\u257c 4 \u257e 1\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(3, 1) ---\\n        \u2559\u2500\u2500 2 \u257e 1, 2\\n            \u251c\u2500\u257c 1 \u257e 1, 3\\n            \u2502   \u251c\u2500\u257c 3 \u257e 2\\n            \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u251c\u2500\u257c 4 \u257e 2\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(3, 2) ---\\n        \u2559\u2500\u2500 3 \u257e 1, 2\\n            \u251c\u2500\u257c 1 \u257e 1, 2\\n            \u2502   \u251c\u2500\u257c 2 \u257e 2, 3\\n            \u2502   \u2502   \u251c\u2500\u257c 4 \u257e 1\\n            \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(3, 3) ---\\n        \u2559\u2500\u2500 1 \u257e 1, 2, 3\\n            \u251c\u2500\u257c 2 \u257e 2, 3\\n            \u2502   \u251c\u2500\u257c 3 \u257e 1, 3\\n            \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u251c\u2500\u257c 4 \u257e 1\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(3, 4) ---\\n        \u2559\u2500\u2500 1 \u257e 1, 2, 3\\n            \u251c\u2500\u257c 2 \u257e 2, 3\\n            \u2502   \u251c\u2500\u257c 3 \u257e 1, 3\\n            \u2502   \u2502   \u251c\u2500\u257c 4 \u257e 1, 2\\n            \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(4, 1) ---\\n        \u2559\u2500\u2500 2 \u257e 1, 2, 3\\n            \u251c\u2500\u257c 1 \u257e 1, 3, 4\\n            \u2502   \u251c\u2500\u257c 3 \u257e 2, 3\\n            \u2502   \u2502   \u251c\u2500\u257c 4 \u257e 1, 2\\n            \u2502   \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(4, 2) ---\\n        \u2559\u2500\u2500 3 \u257e 1, 2, 3\\n            \u251c\u2500\u257c 1 \u257e 1, 2, 4\\n            \u2502   \u251c\u2500\u257c 2 \u257e 2, 3, 4\\n            \u2502   \u2502   \u251c\u2500\u257c 4 \u257e 1, 3\\n            \u2502   \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(4, 3) ---\\n        \u2559\u2500\u2500 4 \u257e 1, 2, 3\\n            \u251c\u2500\u257c 1 \u257e 1, 2, 3\\n            \u2502   \u251c\u2500\u257c 2 \u257e 2, 3, 4\\n            \u2502   \u2502   \u251c\u2500\u257c 3 \u257e 1, 3, 4\\n            \u2502   \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u2514\u2500\u257c  ...\\n        --- add_edge(4, 4) ---\\n        \u2559\u2500\u2500 1 \u257e 1, 2, 3, 4\\n            \u251c\u2500\u257c 2 \u257e 2, 3, 4\\n            \u2502   \u251c\u2500\u257c 3 \u257e 1, 3, 4\\n            \u2502   \u2502   \u251c\u2500\u257c 4 \u257e 1, 2, 4\\n            \u2502   \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2502   \u2514\u2500\u257c  ...\\n            \u2502   \u2514\u2500\u257c  ...\\n            \u2514\u2500\u257c  ...\\n        ').strip()\n    assert target == text"
 },
 {
  "docstring": "Walk through the cases going from a disconnected to fully connected graph",
  "code": "def test_write_network_text_iterative_add_undirected_edges():\n    graph = nx.Graph()\n    graph.add_nodes_from([1, 2, 3, 4])\n    lines = []\n    write = lines.append\n    write('--- initial state ---')\n    nx.write_network_text(graph, path=write, end='')\n    for i, j in product(graph.nodes, graph.nodes):\n        if i == j:\n            continue\n        write(f'--- add_edge({i}, {j}) ---')\n        graph.add_edge(i, j)\n        nx.write_network_text(graph, path=write, end='')\n    text = '\\n'.join(lines)\n    print(text)\n    target = dedent('\\n        --- initial state ---\\n        \u255f\u2500\u2500 1\\n        \u255f\u2500\u2500 2\\n        \u255f\u2500\u2500 3\\n        \u2559\u2500\u2500 4\\n        --- add_edge(1, 2) ---\\n        \u255f\u2500\u2500 3\\n        \u255f\u2500\u2500 4\\n        \u2559\u2500\u2500 1\\n            \u2514\u2500\u2500 2\\n        --- add_edge(1, 3) ---\\n        \u255f\u2500\u2500 4\\n        \u2559\u2500\u2500 2\\n            \u2514\u2500\u2500 1\\n                \u2514\u2500\u2500 3\\n        --- add_edge(1, 4) ---\\n        \u2559\u2500\u2500 2\\n            \u2514\u2500\u2500 1\\n                \u251c\u2500\u2500 3\\n                \u2514\u2500\u2500 4\\n        --- add_edge(2, 1) ---\\n        \u2559\u2500\u2500 2\\n            \u2514\u2500\u2500 1\\n                \u251c\u2500\u2500 3\\n                \u2514\u2500\u2500 4\\n        --- add_edge(2, 3) ---\\n        \u2559\u2500\u2500 4\\n            \u2514\u2500\u2500 1\\n                \u251c\u2500\u2500 2\\n                \u2502   \u2514\u2500\u2500 3 \u2500 1\\n                \u2514\u2500\u2500  ...\\n        --- add_edge(2, 4) ---\\n        \u2559\u2500\u2500 3\\n            \u251c\u2500\u2500 1\\n            \u2502   \u251c\u2500\u2500 2 \u2500 3\\n            \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 1\\n            \u2502   \u2514\u2500\u2500  ...\\n            \u2514\u2500\u2500  ...\\n        --- add_edge(3, 1) ---\\n        \u2559\u2500\u2500 3\\n            \u251c\u2500\u2500 1\\n            \u2502   \u251c\u2500\u2500 2 \u2500 3\\n            \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 1\\n            \u2502   \u2514\u2500\u2500  ...\\n            \u2514\u2500\u2500  ...\\n        --- add_edge(3, 2) ---\\n        \u2559\u2500\u2500 3\\n            \u251c\u2500\u2500 1\\n            \u2502   \u251c\u2500\u2500 2 \u2500 3\\n            \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 1\\n            \u2502   \u2514\u2500\u2500  ...\\n            \u2514\u2500\u2500  ...\\n        --- add_edge(3, 4) ---\\n        \u2559\u2500\u2500 1\\n            \u251c\u2500\u2500 2\\n            \u2502   \u251c\u2500\u2500 3 \u2500 1\\n            \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 1, 2\\n            \u2502   \u2514\u2500\u2500  ...\\n            \u2514\u2500\u2500  ...\\n        --- add_edge(4, 1) ---\\n        \u2559\u2500\u2500 1\\n            \u251c\u2500\u2500 2\\n            \u2502   \u251c\u2500\u2500 3 \u2500 1\\n            \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 1, 2\\n            \u2502   \u2514\u2500\u2500  ...\\n            \u2514\u2500\u2500  ...\\n        --- add_edge(4, 2) ---\\n        \u2559\u2500\u2500 1\\n            \u251c\u2500\u2500 2\\n            \u2502   \u251c\u2500\u2500 3 \u2500 1\\n            \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 1, 2\\n            \u2502   \u2514\u2500\u2500  ...\\n            \u2514\u2500\u2500  ...\\n        --- add_edge(4, 3) ---\\n        \u2559\u2500\u2500 1\\n            \u251c\u2500\u2500 2\\n            \u2502   \u251c\u2500\u2500 3 \u2500 1\\n            \u2502   \u2502   \u2514\u2500\u2500 4 \u2500 1, 2\\n            \u2502   \u2514\u2500\u2500  ...\\n            \u2514\u2500\u2500  ...\\n        ').strip()\n    assert target == text"
 },
 {
  "docstring": "Walk through the cases going from a disconnected to fully connected graph",
  "code": "def test_write_network_text_iterative_add_random_directed_edges():\n    rng = random.Random(724466096)\n    graph = nx.DiGraph()\n    graph.add_nodes_from([1, 2, 3, 4, 5])\n    possible_edges = list(product(graph.nodes, graph.nodes))\n    rng.shuffle(possible_edges)\n    graph.add_edges_from(possible_edges[0:8])\n    lines = []\n    write = lines.append\n    write('--- initial state ---')\n    nx.write_network_text(graph, path=write, end='')\n    for i, j in possible_edges[8:12]:\n        write(f'--- add_edge({i}, {j}) ---')\n        graph.add_edge(i, j)\n        nx.write_network_text(graph, path=write, end='')\n    text = '\\n'.join(lines)\n    print(text)\n    target = dedent('\\n        --- initial state ---\\n        \u2559\u2500\u2500 3 \u257e 5\\n            \u2514\u2500\u257c 2 \u257e 2\\n                \u251c\u2500\u257c 4 \u257e 4\\n                \u2502   \u251c\u2500\u257c 5\\n                \u2502   \u2502   \u251c\u2500\u257c 1 \u257e 1\\n                \u2502   \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2514\u2500\u257c  ...\\n                \u2514\u2500\u257c  ...\\n        --- add_edge(4, 1) ---\\n        \u2559\u2500\u2500 3 \u257e 5\\n            \u2514\u2500\u257c 2 \u257e 2\\n                \u251c\u2500\u257c 4 \u257e 4\\n                \u2502   \u251c\u2500\u257c 5\\n                \u2502   \u2502   \u251c\u2500\u257c 1 \u257e 1, 4\\n                \u2502   \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2514\u2500\u257c  ...\\n                \u2514\u2500\u257c  ...\\n        --- add_edge(2, 1) ---\\n        \u2559\u2500\u2500 3 \u257e 5\\n            \u2514\u2500\u257c 2 \u257e 2\\n                \u251c\u2500\u257c 4 \u257e 4\\n                \u2502   \u251c\u2500\u257c 5\\n                \u2502   \u2502   \u251c\u2500\u257c 1 \u257e 1, 4, 2\\n                \u2502   \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2514\u2500\u257c  ...\\n                \u2514\u2500\u257c  ...\\n        --- add_edge(5, 2) ---\\n        \u2559\u2500\u2500 3 \u257e 5\\n            \u2514\u2500\u257c 2 \u257e 2, 5\\n                \u251c\u2500\u257c 4 \u257e 4\\n                \u2502   \u251c\u2500\u257c 5\\n                \u2502   \u2502   \u251c\u2500\u257c 1 \u257e 1, 4, 2\\n                \u2502   \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2514\u2500\u257c  ...\\n                \u2514\u2500\u257c  ...\\n        --- add_edge(1, 5) ---\\n        \u2559\u2500\u2500 3 \u257e 5\\n            \u2514\u2500\u257c 2 \u257e 2, 5\\n                \u251c\u2500\u257c 4 \u257e 4\\n                \u2502   \u251c\u2500\u257c 5 \u257e 1\\n                \u2502   \u2502   \u251c\u2500\u257c 1 \u257e 1, 4, 2\\n                \u2502   \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2502   \u2514\u2500\u257c  ...\\n                \u2502   \u2514\u2500\u257c  ...\\n                \u2514\u2500\u257c  ...\\n\\n        ').strip()\n    assert target == text"
 },
 {
  "docstring": "Generate a gauntlet of different test graphs with different properties",
  "code": "def generate_test_graphs():\n    import random\n    rng = random.Random(976689776)\n    num_randomized = 3\n    for directed in [0, 1]:\n        cls = nx.DiGraph if directed else nx.Graph\n        for num_nodes in range(17):\n            graph = cls()\n            graph.add_nodes_from(range(num_nodes))\n            yield graph\n            if num_nodes > 0:\n                for p in [0.1, 0.3, 0.5, 0.7, 0.9]:\n                    for seed in range(num_randomized):\n                        graph = nx.erdos_renyi_graph(num_nodes, p, directed=directed, seed=rng)\n                        yield graph\n                yield nx.complete_graph(num_nodes, cls)\n        yield nx.path_graph(3, create_using=cls)\n        yield nx.balanced_tree(r=1, h=3, create_using=cls)\n        if not directed:\n            yield nx.circular_ladder_graph(4, create_using=cls)\n            yield nx.star_graph(5, create_using=cls)\n            yield nx.lollipop_graph(4, 2, create_using=cls)\n            yield nx.wheel_graph(7, create_using=cls)\n            yield nx.dorogovtsev_goltsev_mendes_graph(4, create_using=cls)"
 },
 {
  "docstring": "Write the graph to network text format, then parse it back in, assert it is\nthe same as the original graph. Passing this test is strong validation of\nboth the format generator and parser.",
  "code": "@pytest.mark.parametrize(('vertical_chains', 'ascii_only'), tuple([(vertical_chains, ascii_only) for vertical_chains in [0, 1] for ascii_only in [0, 1]]))\ndef test_network_text_round_trip(vertical_chains, ascii_only):\n    from networkx.readwrite.text import _parse_network_text\n    for graph in generate_test_graphs():\n        graph = nx.relabel_nodes(graph, {n: str(n) for n in graph.nodes})\n        lines = list(nx.generate_network_text(graph, vertical_chains=vertical_chains, ascii_only=ascii_only))\n        new = _parse_network_text(lines)\n        try:\n            assert new.nodes == graph.nodes\n            assert new.edges == graph.edges\n        except Exception:\n            print('ERROR in round trip with graph')\n            nx.write_network_text(graph)\n            raise"
 }
]