[
 {
  "docstring": "Returns the k-core decomposition of G.\n\nThe k-core decomposition is the subgraph of G that each node has `k` or more degree.\n\nParameters\n----------\nG : NetworkX graph\n  A graph or directed graph\nk : int\n  Value of the decomposition\ncore_number : dictionary, optional\n  Precomputed core numbers for the graph G.\n\nReturns\n-------\nG : NetworkX graph\n  The k-core decomposition\n\nRaises\n------\nNetworkXNotImplemented\n  The k-core decomposition is not defined for multigraphs or graphs with self loops.\n\nSee Also\n--------\ncore_number",
  "code": "@nx.utils.not_implemented_for('multigraph')\ndef k_core_decomposition(G, k, core_number=None):\n    return nx.k_core(G, k=k, core_number=core_number)"
 },
 {
  "docstring": "Returns the k-core degeneracy of G.\n\nThe k-core degeneracy is the subgraph of G that each node has maximum core number degree.\n\nParameters\n----------\nG : NetworkX graph\n  A graph or directed graph\ncore_number : dictionary, optional\n  Precomputed core numbers for the graph G.\n\nReturns\n-------\nG : NetworkX graph\n  The k-core degeneracy\n\nRaises\n------\nNetworkXNotImplemented\n  The k-core degeneracy is not defined for multigraphs or graphs with self loops.\n\n",
  "code": "@nx.utils.not_implemented_for('multigraph')\ndef k_core_degeneracy(G, core_number=None):\n    if core_number is None:\n        core_number = nx.core_number(G)\n    k = max(core_number.values())\n    return nx.k_core(G, k=k, core_number=core_number)"
 },
 {
  "docstring": "Returns the k-peak decomposition of G.\n\nThe k-peak decomposition is the subgraph of G that each node has `k` or more degree within each other.\n\nParameters\n----------\nG : NetworkX graph\n  A graph or directed graph\nk : int\n  Value of the decomposition\ncore_number : dictionary, optional\n  Precomputed core numbers for the graph G.\npeak_number : dictionary, optional\n  Precomputed peak numbers for the graph G.\n\nReturns\n-------\nG : NetworkX graph\n  The k-peak decomposition\n\nRaises\n------\nNetworkXNotImplemented\n  The k-peak decomposition is not defined for multigraphs or graphs with self loops.\n\nSee Also\n--------\npeak_number\ncore_number",
  "code": "def k_peak_decomposition(G, k, core_number=None, peak_number=None):\n    return nx.k_peak(G, k=k, cores=core_number, peaks=peak_number)"
 },
 {
  "docstring": "Returns the k-peak degeneracy of G.\n\nThe k-peak degeneracy is the subgraph of G that each node has maximum peak number degree.\n\nParameters\n----------\nG : NetworkX graph\n  A graph or directed graph\ncore_number : dictionary, optional\n  Precomputed core numbers for the graph G.\npeak_number : dictionary, optional\n  Precomputed peak numbers for the graph G.\n\nReturns\n-------\nG : NetworkX graph\n  The k-peak degeneracy\n\nRaises\n------\nNetworkXNotImplemented\n  The k-peak degeneracy is not defined for multigraphs or graphs with self loops.\n\n",
  "code": "def k_peak_degeneracy(G, core_number=None, peak_number=None):\n    if peaks is None:\n        peaks = peak_number(G, cores=core_number)\n    k = max(peaks.values())\n    return nx.k_peak(G, k=k, cores=core_number, peaks=peak_number)"
 },
 {
  "docstring": "Returns a minimum edge coloring of the bipartite graph `G`.\n\nAn edge coloring is an assignment of colors to the edges of a graph such\nthat no two adjacent edges share the same color. In the case of bipartite\ngraphs, the coloring ensures that no two edges incident on the same node\nhave the same color.\n\n\nParameters\n----------\nG : NetworkX graph\n\nOptional Parameter\n------------------\ntop_nodes : list, optional\n    List of nodes that belong to one node set.\nstrategy : str, optional\n    The strategy to use for edge coloring. Currently, the following strategies are supported :\n    \"iterated-matching\" :\n    \"kempe-chain\" :\n    The default strategy is \"kempe-chain\".\n\nReturns\n--------\nedge_colors : dict\n    The edge coloring is returned as a dictionary, `edge_colors`, such that\n    `edge_colors[e]` is the color assigned to edge `e`. Colors are represented\n    as integers.\n\n",
  "code": "@nx.utils.not_implemented_for('directed')\n@nx.utils.not_implemented_for('multigraph')\n@nx._dispatch(name='bipartite_edge_coloring')\ndef bipartite_edge_coloring(G, top_nodes=None, strategy='kempe-chain'):\n    if not nx.is_bipartite(G):\n        raise nx.NetworkXError('Not a Bipartite Graph')\n    if strategy == 'iterated-matching':\n        if not nx.is_connected(G) and top_nodes is None:\n            raise nx.AmbiguousSolution('Disconnected graph: Ambiguous solution for bipartite sets.')\n        if top_nodes is None:\n            top_nodes, _ = nx.bipartite.sets(G)\n        coloring = iterated_matching_edge_coloring(G, top_nodes)\n    else:\n        coloring = kempe_chain_bipartite_edge_coloring(G)\n    return coloring"
 },
 {
  "docstring": "Returns the minimum edge coloring of the bipartite graph `graph`.\n\nThis function uses the procedure augment to color the edges of the bipartite\ngraph such that no two adjacent edges have the same color.\n\nParameters\n----------\nG : NetworkX graph\n    The input bipartite graph.\ntop_nodes : list\n    List of nodes that belong to one node set.\n\nReturns\n-------\ncoloring : dict\n    The edge coloring represented as a dictionary, where `coloring[e]`\n    is the color assigned to edge `e`. Colors are represented as integers.",
  "code": "@nx.utils.not_implemented_for('directed')\n@nx.utils.not_implemented_for('multigraph')\n@nx._dispatch(name='kempe_chain_bipartite_edge_coloring')\ndef kempe_chain_bipartite_edge_coloring(G):\n    degrees = dict(G.degree())\n    delta = max(degrees.values())\n    colors = set(range(delta))\n    coloring = {}\n    used_colors = {node: {} for node in G.nodes}\n    for u, v in G.edges:\n        u_colors = set(used_colors[u].keys())\n        v_colors = set(used_colors[v].keys())\n        available_colors = colors - (u_colors | v_colors)\n        if available_colors:\n            color = min(available_colors)\n            used_colors[u][color] = v\n            used_colors[v][color] = u\n            coloring[u, v] = color\n            coloring[v, u] = color\n        else:\n            u_color = next(iter(colors - set(used_colors[u])))\n            v_color = next(iter(colors - set(used_colors[v])))\n            u1 = u\n            v1 = v\n            color = v_color\n            while True:\n                used_colors[v1][color] = u1\n                coloring[u1, v1] = color\n                coloring[v1, u1] = color\n                if color not in used_colors[u1]:\n                    used_colors[u1][color] = v1\n                    color = v_color if color == u_color else u_color\n                    used_colors[u1].pop(color)\n                    break\n                u_new = used_colors[u1][color]\n                used_colors[u1][color] = v1\n                v1 = u1\n                u1 = u_new\n                color = v_color if color == u_color else u_color\n    return coloring"
 },
 {
  "docstring": "Returns the minimum edge coloring of the bipartite graph `G`.\n\nThis function uses the procedure one-color to color the edges of the bipartite\ngraph such that no two adjacent edges have the same color.\n\nParameters\n----------\nG : NetworkX graph\n    The input bipartite graph.\ntop_nodes : list\n    List of nodes that belong to one node set.\n\nReturns\n-------\ncoloring : dict\n    The edge coloring represented as a dictionary, where `coloring[e]`\n    is the color assigned to edge `e`. Colors are represented as integers.",
  "code": "@nx.utils.not_implemented_for('directed')\n@nx.utils.not_implemented_for('multigraph')\n@nx._dispatch(name='iterated_matching_edge_coloring')\ndef iterated_matching_edge_coloring(G, top_nodes):\n    coloring = {}\n    i = 0\n    G1 = G.copy()\n    while G1.edges:\n        matching = _matching_saturating_max_degree(G1, top_nodes)\n        for u, v in list(matching.items()):\n            edge = (u, v) if u != v else (v, u)\n            coloring[edge] = i\n        G1.remove_edges_from(list(matching.items()))\n        i += 1\n    return coloring"
 },
 {
  "docstring": "Returns a maximum-degree saturating matching in the bipartite graph `graph`.\n\nParameters\n----------\nG : NetworkX graph\n    The input bipartite graph.\ntop_nodes : list, optional\n    List of nodes that belong to the top node set.\n\nReturns\n-------\nmatching : dict\n    A dictionary representing the maximum-degree saturating matching.",
  "code": "def _matching_saturating_max_degree(G, top_nodes=None):\n    degrees = dict(G.degree())\n    max_degree = max(degrees.values())\n    max_degree_vertices = {node for node, deg in degrees.items() if deg == max_degree}\n    part_a, part_b = nx.bipartite.sets(G, top_nodes)\n    A_major_nodes = part_a & max_degree_vertices | part_b\n    B_major_nodes = part_b & max_degree_vertices | part_a\n    A_major = G.subgraph(A_major_nodes)\n    B_major = G.subgraph(B_major_nodes)\n    top_nodes_A = top_nodes & A_major_nodes\n    top_nodes_B = top_nodes & B_major_nodes\n    M1 = nx.bipartite.maximum_matching(A_major, top_nodes_A)\n    M2 = nx.bipartite.maximum_matching(B_major, top_nodes_B)\n    return _combine_matchings(M1, M2, part_a, part_b)"
 },
 {
  "docstring": "Combines two matchings `M1` and `M2` in the bipartite graph.\n\nParameters\n----------\nM1 : dict\n    Dictionary representing the first matching.\nM2 : dict\n    Dictionary representing the second matching.\nA : set\n    Set of nodes in the first part of the bipartite graph.\nB : set\n    Set of nodes in the second part of the bipartite graph.\n\nReturns\n-------\nfinal_matching : dict\n    A dictionary representing the combined matching.",
  "code": "def _combine_matchings(M1, M2, A, B):\n    final_matching = {}\n    visited = set()\n    for u, v in list(M1.items()) + list(M2.items()):\n        if (u, v) in visited:\n            continue\n        u1 = u\n        edges = [(u, v)]\n        visited.update([(u, v), (v, u)])\n        M = M2\n        while v in M and v != u1:\n            u = v\n            v = M[v]\n            edges.append((u, v))\n            visited.update([(u, v), (v, u)])\n            M = M1 if M is M2 else M2\n        if v not in M:\n            u, v = (v, u)\n            edges = [(u, v)]\n            visited.update([(u, v), (v, u)])\n            while v in M:\n                u = v\n                v = M[v]\n                edges.append((u, v))\n                visited.update([(u, v), (v, u)])\n                M = M1 if M is M2 else M2\n            u, v = edges[0]\n            if len(edges) % 2 == 1 or (u in M1 and M1[u] == v and (u in A) or (u in M2 and M2[u] == v and (u in B))):\n                k = 0\n            else:\n                k = 1\n            for u1, v1 in edges[k::2]:\n                final_matching[u1] = v1\n                final_matching[v1] = u1\n        elif v == u1:\n            for i in range(0, len(edges), 2):\n                u, v = edges[i]\n                final_matching[u] = v\n                final_matching[v] = u\n        else:\n            raise ValueError('Bleh')\n    return final_matching"
 },
 {
  "docstring": "Returns the peak number for each vertex.\n\nA k-peak of a graph is a maximal subgraph that contains nodes of degree k or more within each other.\n\nParameters\n----------\nG : NetworkX graph\n   A graph or directed graph\ncores : dictionary, optional\n  Precomputed core numbers for the graph G.\n\nReturns\n-------\npeak_number : dictionary\n   A dictionary keyed by node to the peak number.\n\nRaises\n------\nNetworkXError\n    The k-peak is not implemented for graphs with self loops\n    or parallel edges.\n\n",
  "code": "@not_implemented_for('multigraph')\n@nx._dispatch\ndef peak_number(G, cores=None):\n    if nx.number_of_selfloops(G) > 0:\n        msg = 'Input graph has self loops which is not permitted; Consider using G.remove_edges_from(nx.selfloop_edges(G)).'\n        raise NetworkXError(msg)\n    if cores is None:\n        cores = nx.core_number(G)\n    H = G.copy()\n    peak_number = {}\n    while H.nodes():\n        core_degeneracy = nx.k_core(H, core_number=cores)\n        peak_number.update({node: cores[node] for node in core_degeneracy})\n        H.remove_nodes_from(core_degeneracy.nodes())\n        cores = nx.core_number(H)\n    return peak_number"
 },
 {
  "docstring": "Returns the k-peak of G.\n\nA k-peak of a graph is a maximal subgraph that contains nodes of degree k or more within each other.\n\nParameters\n----------\nG : NetworkX graph\n   A graph or directed graph\nk : int, optional\n  The order of the peak.  If not specified return the max peak.\ncores : dictionary, optional\n  Precomputed core numbers for the graph G.\npeaks : dictionary, optional\n  Precomputed peak numbers for the graph G.\n\nReturns\n-------\nG : NetworkX graph\n  The k-peak subgraph\n\nRaises\n------\nNetworkXError\n    The k-peak is not implemented for graphs with self loops\n    or parallel edges.\n\n",
  "code": "@nx._dispatch(preserve_all_attrs=True)\ndef k_peak(G, k=None, cores=None, peaks=None):\n    if peaks is None:\n        peaks = peak_number(G, cores=cores)\n    if k is None:\n        k = max(peaks.values())\n    H = G.copy()\n    H.remove_nodes_from([key for key, value in peaks.items() if value < k])\n    return H"
 },
 {
  "docstring": "Returns the k-contour of G.\n\nA k-contour of a graph is a maximal subgraph that contains nodes of degree k within each other.\n\nParameters\n----------\nG : NetworkX graph\n   A graph or directed graph\nk : int, optional\n  The order of the peak.  If not specified return the max peak.\ncores : dictionary, optional\n  Precomputed core numbers for the graph G.\npeaks : dictionary, optional\n  Precomputed peak numbers for the graph G.\n\nReturns\n-------\nG : NetworkX graph\n  The k-contour subgraph\n\nRaises\n------\nNetworkXError\n    The k-contour is not implemented for graphs with self loops\n    or parallel edges.\n\n",
  "code": "@nx._dispatch(preserve_all_attrs=True)\ndef k_contour(G, k=None, cores=None, peaks=None):\n    if peaks is None:\n        peaks = peak_number(G, cores=cores)\n    if k is None:\n        k = max(peaks.values())\n    H = G.copy()\n    H.remove_nodes_from([key for key, value in peaks.items() if value != k])\n    return H"
 }
]